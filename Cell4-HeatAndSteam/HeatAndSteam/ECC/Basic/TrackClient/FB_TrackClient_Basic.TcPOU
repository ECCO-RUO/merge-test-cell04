<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.5">
  <POU Name="FB_TrackClient_Basic" Id="{1ac5e215-eb59-4502-99b0-c2a46163e22f}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_TrackClient_Basic
VAR_INPUT
	bEnable			: BOOL;
	bEStopOK		: BOOL;
	bSuspend		: BOOL;
	bReset			: BOOL;
	abStation1Ready	: ARRAY [1..5] OF BOOL;	// TRUE when station is ready for a vehicle at input
	abStation2Ready	: ARRAY [1..5] OF BOOL; // TRUE when station is ready for a vehicle at output
	abStation1Done	: ARRAY [1..5] OF BOOL;	// TRUE when station picked up last from vehicle at input
	abStation2Done	: ARRAY [1..5] OF BOOL; // TRUE when station placed last at vehicle at output
	abStation1ReworkReq	: ARRAY [1..5] OF BOOL;	// TRUE when station signals that rework is needed for carrier at station 1 (input) 
	abStation2ReworkReq	: ARRAY [1..5] OF BOOL;	// TRUE when station signals that rework is needed for carrier at station 2 (output)
	abStation1ReworkDone: ARRAY [1..5] OF BOOL;	// TRUE when station signals that rework is done for carrier at station 1 (input) 
	abStation2ReworkDone: ARRAY [1..5] OF BOOL;	// TRUE when station signals that rework is done for carrier at station 2 (output)
END_VAR
VAR_OUTPUT
	{attribute 'OPC.UA.DA':='1'}
	{attribute 'OPC.UA.DA.Access' := '1'}
	{attribute 'OPC.UA.DA.Description' := 'TRUE if connected to call methods on Track server'}
	{attribute 'OPC.UA.DA.DisplayName' := 'TRUE if connected to call methods on Track server'}
	bConnectedMethod: BOOL;
	{attribute 'OPC.UA.DA':='1'}
	{attribute 'OPC.UA.DA.Access' := '1'}
	{attribute 'OPC.UA.DA.Description' := 'TRUE if connected for data reading from Track Server'}
	{attribute 'OPC.UA.DA.DisplayName' := 'TRUE if connected for data reading from Track Server'}
	bConnectedNode	: BOOL;
	{attribute 'OPC.UA.DA':='1'}
	{attribute 'OPC.UA.DA.Access' := '1'}
	{attribute 'OPC.UA.DA.Description' := 'TRUE if cell info is created on track server'}
	{attribute 'OPC.UA.DA.DisplayName' := 'TRUE if cell info is created on track server'}
	bTrackInitDone	: BOOL;
	{attribute 'OPC.UA.DA':='0'}
	bBusyMethod		: BOOL;
	bVehicleInitDone: BOOL;
	bErrorMethod	: BOOL;
	nErrorMethodID	: E_OPC_UA_Errors;
	bErrorNode		: BOOL;
	nErrorNodeID	: E_OPC_UA_Errors;
	bStarted		: BOOL;
	bSuspended		: BOOL;
	bReadyStationIn	: ARRAY [1..5] OF BOOL;
	bReadyStationOut: ARRAY [1..5] OF BOOL;
	stErrorWarning	: ST_OutputErrorWarning;
END_VAR
VAR_IN_OUT
	// Inputs
	stCommand		: ST_InputTransportCommand;
	stMappingIn		: ST_InputTransportMapping;
	stAdditionalDataIn: ST_InputTransportAdditionalData;
	// Outputs
	stStatus		: ST_OutputTransportStatus;
	stMappingOut	: ST_OutputTransportMapping;
	stAdditionaldataOut: ST_OutputTransportAdditionalData;	
END_VAR
VAR
	sNameSpaceUri			: STRING := 'urn:BeckhoffAutomation:Ua:PLC1';
	sObjectIDentifier		: STRING := 'MAIN.fbMMServer';
	sTrackServerSymbol		: STRING;
// FB's for method calls
	bCallMethod		: BOOL;
	(* Server connect *)
	fbConnectMethod			: UA_Connect;
	stConnectInfoMethod		: ST_UASessionConnectInfo;
	nConnectHdlMethod		: DWORD;
	(* Server disconnect *)
	fbDisconnectMethod	 	: UA_Disconnect;
	(* Namespace *)
	fbGetNamespaceMethod	: UA_GetNamespaceIndex;
	nNameSpaceIndexMethod	: UINT;
	(* Get/Release Method handle *)
	fbGetHandleMethod		: UA_MethodGetHandle;
	fbReleaseHandleMethod	: UA_MethodReleaseHandle;
	nHandleMethod			: DWORD;
	stObjectNodeID			: ST_UANodeID;
	stMethodNodeID			: ST_UANodeID;
	sMethodIdentifier		: STRING := '';
	(* Method call *)
	fbCallMethod			: UA_MethodCall;
	(* Declarations for state machine for method calling (OPC-UA to TrackServer) *)
	eStateMethod			: E_TrackClientState;
	eLastErrorMethodID		: E_OPC_UA_Errors;
	(* Method call data *)
	(* Input variables *)
	nNoOfInputArgs			: BYTE;
	aInputArgInfo			: ARRAY[1..10] OF ST_UAMethodArgInfo;	// change according to input parameters
	aInputData				: ARRAY[1..500] OF BYTE;				// Data area for input arguments data	
	(* Output variables *)
	nNoOfOutputArgs			: BYTE;
	aOutputArgInfo			: ARRAY[1..10] OF ST_UAMethodArgInfo; // change according to input parameters

// Method specific data structs
	stAddStationSingleData	: ST_AddStationSingleData;
	stAddStationDoubleData	: ST_AddStationDoubleData;
	stRemoveStationData		: ST_RemoveStationData;
	stEnableStationData		: ST_EnableStationData;
	stAdjustBufferPosData	: ST_AdjustBufferPosData;
	
	stGetCellIndexData		: ST_GetCellIndexData;

	stAddPathData			: ST_AddPathData;
	stRemovePathData		: ST_RemovePathData;
	stStartPathData			: ST_StartPathData;
	stResetPathData			: ST_ResetPathData;
	stSuspendPathData		: ST_SuspendPathData;
	stResumePathData		: ST_ResumePathData;

	stAddTrafficLightData	: ST_AddTrafficLightData;
	stRemoveTrafficLightData: ST_RemoveTrafficLightData;
	stTrafficLightColorData	: ST_TrafficLightColorData;
	stSetTrafficLightColorData: ST_SetTrafficLightColorData;
	
	stMoveToStationInData	: ST_MoveToStationInData;
	stMoveToStationOutData	: ST_MoveToStationOutData;
	stMoveToPositionData	: ST_MoveToPositionData;
	stMoveToBufferData		: ST_MoveToBufferData;
	stMoveToDecisionPointData: ST_MoveToDecisionPointData;
	stMoveToScannerData		: ST_MoveToScannerData;
	stMoveVehicleStatusData	: ST_MoveVehicleStatusData;
	
//	stUpdateVehicleDataData	: ST_UpdateVehicleDataData;
	stUpdateVehicleReservationDataData : ST_UpdateVehicleReservationDataData;
	stUpdateVehicleMappingDataData : ST_UpdateVehicleMappingDataData;
	stUpdateVehicleReworkDataData : ST_UpdateVehicleReworkDataData;
	stUpdateVehicleMontageData : ST_UpdateVehicleMontageData;
	stUpdateStationBufferData: ST_UpdateStationBufferData;
	stUpdateVehicleOwnerData: ST_UpdateVehicleOwnerData;
	stAddReservationData	: ST_AddReservationData;
	stRemoveReservationData	: ST_RemoveReservationData;

	stAddPathSegmentData : ST_AddPathSegmentData;
	stRemovePathSegmentData : ST_RemovePathSegmentData;
	stGetPathSegmentVehicleCountData: ST_GetPathSegmentVehicleCountData;

(* FB's for node reading *)
	(* Server connect *)
	fbConnectNodes			: UA_Connect;
	stConnectInfoNodes		: ST_UASessionConnectInfo;
	nConnectHandleNodes		: DWORD;
	(* Server disconnect *)
	fbDisconnectNodes	 	: UA_Disconnect;
	(* Namespace *)
	fbGetNamespaceNodes		: UA_GetNamespaceIndex;
	nNameSpaceIndexNodes	: UINT;
	(* Get/Release node handles *)
	fbGetHandleNodes		: UA_NodeGetHandleList;
	fbReleaseHandleNodes	: UA_NodeReleaseHandleList;
	anHandleNodes			: ARRAY [1..nMaxNodeIDsInList] OF DWORD;		// Handles to all the remote nodes
	(* Read nodes data *)
	fbReadNodes				: UA_ReadList;
	nNoOfNodes				: UINT;
	aNodeIDs				: ARRAY [1..nMaxNodeIDsInList] OF ST_UANodeID;	// Node ID's ((infor for remote variable to read)
	astNodeAddInfo			: ARRAY [1..nMaxNodeIDsInList] OF ST_UANodeAdditionalInfo;
	acbDatas				: ARRAY [1..nMaxNodeIDsInList] OF UDINT;
	cbDataTotal				: UDINT;
	eReadType				: E_OPC_NodeType;
	iReadIndex				: UINT;
	pReadNodeData			: PVOID;
	bReadDecPointVehicle	: BOOL := TRUE;	// Force reading of the vehicle at decision point before other vehicles
	bReadDecPointVehicleBusy: BOOL := FALSE;// 
	bReadDecPointCell		: BOOL;
	bReadDecPointCellDone	: BOOL;			// Used in decision point to make sure reservation data is read from cell before handling vehicle
	anExtraVehicles			: ARRAY [1..MM_MAX_NUMBER_OF_VEHICLE_ELEMENTS] OF UINT;	// Extra vehicle status data that should be read from track server
	anVehiclesToRead		: ARRAY [1..MM_MAX_NUMBER_OF_VEHICLE_ELEMENTS] OF UINT;	// Vehicles that should be read with triggered/evet-driven reading
	tonSkipPathRead			: TON;			// Skip path reading from Track Server if paths are initialized (State = Starting in M_StateMachine)
	(* Declarations for state machine for reading nodes *)
	eStateNode				: E_TrackClientState;
	tonReadInterval			: TON;
	tonErrorReset			: TON;
	rReadInterval			: REAL := 0.1;	// [S] OPC UA data polling interval
	rErrorResetDelay		: REAL := 10;	// [S] Error automatic reset time/delay
	iReadTimeMS				: UINT;
	iLastReadTimeMS			: UINT;
	(* For reading status values form Track Server *)
	abControlledPaths		: ARRAY [1..MM_MAX_NUMBER_OF_PATH_ELEMENTS] OF BOOL;		(* Paths to control from this Track Client *)
	// Index for this cell on the track server Cell status data
	iThisCellIndex			: UINT;
	iThisStationIndex		: array [1..5] of UINT;
	iStatIndex				: UINT;
// Work-Around - ADS read of status values (NOTE: Requires a route to Track Server PLC!!)
	fbReadADS				: FB_ADS_Comm;

// Status from Track Server	
	aReadVehicleData		: ARRAY [1..MM_MAX_NUMBER_OF_VEHICLE_ELEMENTS] OF ST_ReadVehicleData;
	aReadPathData			: ARRAY [1..MM_MAX_NUMBER_OF_PATH_ELEMENTS] OF ST_ReadPathData;
	aReadStationData		: ARRAY [1..MM_MAX_NUMBER_OF_STATION_ELEMENTS] OF ST_ReadStationData;
	aReadCellData			: ST_ReadCellData;
// For comparing vehicle changes
	aOldVehicleData			: ARRAY [1..MM_MAX_NUMBER_OF_VEHICLE_ELEMENTS] OF ST_StatusVehicle;
	aOldVehicleTargetReachedCnt	: ARRAY [1..MM_MAX_NUMBER_OF_VEHICLE_ELEMENTS] OF UINT;
	iOldVehicleCount		: UINT;

	// State machine
	eTrackState				: E_TrackState;
	iStationID				: UINT;
	iVehicleIndex			: UINT;
	iPathID					: UINT;
	iPathIndex				: UINT;
	bPathsOperational		: BOOL;
	bPathsSuspended			: BOOL;
	bPathsResumed			: BOOL;
	bPathsReset				: BOOL;
	tonResetTime			: TON;
	bStationData1Done		: BOOL;
	bStationData2Done		: BOOL;
	
	// Decision Point
	nDecisionPointVehicleNo	: UINT;

	// Exit point
	stExitPointSeg1LocBegin	: ST_MMLocation;	// Starting point for segment 1
	stExitPointSeg1LocEnd	: ST_MMLocation;	// Starting point for segment 1
	stExitPointSeg2LocBegin	: ST_MMLocation;	// Starting point for segment 2
	stExitPointSeg2LocEnd	: ST_MMLocation;	// Starting point for segment 2
	
	// Status generation
	iVehicle				: UINT;
	iStation				: UINT;	
	bForceVehicleUpdateOPC	: BOOL;
	
	// Command Data
	eCommandDataState		: E_CommandDataState;
	iCommandDataVehicleID	: UINT;

	// Mapping data
	eMappingDataState		: E_MappingDataState;
	iMappingDataVehicleID	: UINT;

	// Rework data
	eReworkDataState		: E_ReworkDataState;
	iReworkDataStation		: UINT;
	iReworkDataStationNo	: UINT;
	iReworkDataVehicleID	: UINT;
	sReworkDataCarrierID	: STRING(30);
	bReworkValue			: BOOL;
	
	(* Misc *)
	nOffset					: UDINT;
	bInitDone				: BOOL;
	iMethodResult			: INT;
	fbGetTime				: NT_GetTime;
//	iNodeReadErrs: UINT;
//	iNodeReads: UINT;

	// Constants
	MIN_TRACK_DIST			: REAL := 0.25;	// [m] Minimum track distance 
	
END_VAR
VAR PERSISTENT
	{attribute 'OPC.UA.DA':='1'}
	{attribute 'OPC.UA.DA.Access' := '3'}
	{attribute 'OPC.UA.DA.Description' := 'URL for OPC-UA connection to Track Server'}
	{attribute 'OPC.UA.DA.DisplayName' := 'URL for OPC-UA connection to Track Server'}
	sTrackServerUrl			: STRING := 'opc.tcp://10.38.190.130:4840';		// OPC UA address for the track server PLC
	{attribute 'OPC.UA.DA':='0'}
	sCellID					: STRING(30):= 'Cxx';							// Cell identifier
	aStations				: ARRAY [1..5] OF ST_MMStation;					// Stations
	aStationPreBufAdj		: ARRAY [1..5] OF REAL;							// Adjustment of pre-buffer positions
	aStationPostBufAdj		: ARRAY [1..5] OF REAL;							// Adjustment of post-buffer positions
	stTrafficLightLocation	: ST_MMLocation;								// Traffic light location (outlet from cell)
	stTrafficLight2Location	: ST_MMLocation;								// Traffic light location (outlet from cell)
	eCellType				: E_CellType;									// Type of station
	{attribute 'OPC.UA.DA':='1'}
	{attribute 'OPC.UA.DA.Access' := '3'}
	{attribute 'OPC.UA.DA.Description' := 'AMS NetID for ADS connection to Track Server'}
	{attribute 'OPC.UA.DA.DisplayName' := 'AMS NetID for ADS connection to Track Server'}
	sTrackServerNetID		: STRING := '10.38.190.130.1.1';				// AMS NetID of the Track Server PLC
	{attribute 'OPC.UA.DA':='0'}
	nTrackServerPortNo		: UINT := 851;									// Port number of the Track Server PLC runtime (851 = Runtime 1)
	aPaths					: ARRAY[1..MM_MAX_NUMBER_OF_PATH_ELEMENTS] OF UINT;	// Paths controlled by this cell
	{attribute 'OPC.UA.DA':='1'}
	{attribute 'OPC.UA.DA.Access' := '3'}
	{attribute 'OPC.UA.DA.Description' := 'ID of the next station on the track (where to send vehicles after DP/operation'}
	{attribute 'OPC.UA.DA.DisplayName' := 'ID of the next station on the track (where to send vehicles after DP/operation'}
	sNextStationOnTrack		: STRING(30);									// Station ID for the next station on the track
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[// Init data
M_Init();

// Handle Command Data
M_CommandData();

// Handle Mapping Data
M_MappingData();

// Handle rework data
M_ReworkData();

// State machine for method calls
M_StateMachineMethod();

// State machine for node data read
//M_StateMachineNode();
M_StateMachineNode_ADS();

// Track init state machine
M_StateMachine();

// Run worker FB's
M_Run();

// Status values
M_UpdateStatus();

// Error Warning
M_ErrorWarning();]]></ST>
    </Implementation>
    <Method Name="M_CallAddPath" Id="{e402ea3c-7941-4e8e-9950-0a0e536fd4bc}">
      <Declaration><![CDATA[METHOD PROTECTED M_CallAddPath : INT
VAR_INPUT
	nPathNo			: UINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF (stAddPathData.iStatus = 2) OR (stAddPathData.iStatus = 3) THEN
	stAddPathData.iStatus := 0;
END_IF

IF (bConnectedMethod AND NOT bBusyMethod) THEN
	IF (stAddPathData.iStatus = 0) THEN
	(* Setup method calling parameters *)
		(* Method identifier *)
		sObjectIDentifier := stAddPathData.sObjectID;
		sMethodIdentifier := stAddPathData.sMethodID;
	
		(* Method Inputs *)
		stAddPathData.stInput.sCellID := sCellID;
		stAddPathData.stInput.iPath := nPathNo;
		stAddPathData.stInput.bPresent := TRUE;
		(* Fill input data area with method arguments *)
		MEMSET(ADR(aInputData), 0 ,SIZEOF(aInputData));
		nOffset := 0;
		nOffset := nOffset + MEMCPY(ADR(aInputData)+nOffset, ADR(stAddPathData.stInput), MIN(SIZEOF(stAddPathData.stInput), (SIZEOF(aInputData)-nOffset)) );
		(* Number of input arguments *)
		nNoOfInputArgs := stAddPathData.iNoOfInputArgs;
		(* Set up input argument information *)
		MEMSET(ADR(aInputArgInfo), 0, SIZEOF(aInputArgInfo));
		aInputArgInfo[1].DataType := eUAType_String;
		aInputArgInfo[1].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[1].nLenData := SIZEOF(stAddPathData.stInput.sCellID);
		aInputArgInfo[2].DataType := eUAType_UInt16;
		aInputArgInfo[2].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[2].nLenData := SIZEOF(stAddPathData.stInput.iPath);
		aInputArgInfo[3].DataType := eUAType_Boolean;
		aInputArgInfo[3].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[3].nLenData := SIZEOF(stAddPathData.stInput.bPresent);
		
		(* Method outputs *)
		(* Clear output data area *)
		(* Number of output arguments *)
		nNoOfOutputArgs := stAddPathData.iNoOfOutputArgs;
		(* Set up output argument information *)
		MEMSET(ADR(aOutputArgInfo), 0, SIZEOF(aOutputArgInfo));
		aOutputArgInfo[1].DataType := eUAType_Uint16;
		aOutputArgInfo[1].ValueRank := -1;
		aOutputArgInfo[1].nLenData := SIZEOF(stAddPathData.stOutput.eStatus);
		aOutputArgInfo[2].DataType := eUAType_String;
		aOutputArgInfo[2].ValueRank := -1;
		aOutputArgInfo[2].nLenData := SIZEOF(stAddPathData.stOutput.sMessage);
		(* Set up output  *)
		MEMSET(ADR(stAddPathData.stOutput), 0, SIZEOF(stAddPathData.stOutput));
		stAddPathData.stOutput.nNumberOfOutputArguments := nNoOfOutputArgs;
		stAddPathData.stOutput.stOutputArgInfo[1] := aOutputArgInfo[1];
		stAddPathData.stOutput.stOutputArgInfo[2] := aOutputArgInfo[2];
	
		(* Execute FB *)
		fbCallMethod.nNumberOfInputArguments := nNoOfInputArgs;
		fbCallMethod.pInputArgInfo := ADR(aInputArgInfo);
		fbCallMethod.cbInputArgInfo := (SIZEOF(aInputArgInfo[1])*nNoOfInputArgs);
		fbCallMethod.pInputArgData := ADR(aInputData);
		fbCallMethod.cbInputArgData := nOffset;
		fbCallMethod.nNumberOfOutputArguments := nNoOfOutputArgs; 
		fbCallMethod.pOutputArgInfo := ADR(aOutputArgInfo); 
		fbCallMethod.cbOutputArgInfo := (SIZEOF(aOutputArgInfo[1]) * nNoOfOutputArgs); 
		fbCallMethod.pOutputArgInfoAndData := ADR(stAddPathData.stOutput);
		fbCallMethod.cbOutputArgInfoAndData := SIZEOF(stAddPathData.stOutput);
		
		stAddPathData.iStatus := 1;
		bCallMethod := TRUE;
		
	ELSIF (stAddPathData.iStatus = 1) THEN
		// Method call Completed...
		IF (eStateMethod = E_TrackClientState.Connected) THEN
			// Method call OK
			IF (stAddPathData.stOutput.eStatus = E_MMServerStatus.eMMServerStatus_Success) THEN
				// Method returned OK
				stAddPathData.iStatus := 2;
			ELSE
				// Method returned with error
				stAddPathData.iStatus := 3;
				stAddPathData.stOutput.sMessage;
			END_IF
		ELSIF (eStateMethod = E_TrackClientState.Error) THEN
			// Method call failed
			stAddPathData.iStatus := 3;
		END_IF
		
	END_IF
END_IF

M_CallAddPath := stAddPathData.iStatus;	
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_CallAddPathSegment" Id="{b299dbc9-6201-4492-afc6-2d3445661ab5}">
      <Declaration><![CDATA[METHOD PROTECTED M_CallAddPathSegment : INT
VAR_INPUT
	iSegmentNo		: UINT;
	nPathNo			: UINT;
	rBeginPosition	: REAL;
	rEndPosition	: REAL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF (stAddPathSegmentData.iStatus = 2) OR (stAddPathSegmentData.iStatus = 3) THEN
	stAddPathSegmentData.iStatus := 0;
END_IF

IF (bConnectedMethod AND NOT bBusyMethod) THEN
	IF (stAddPathSegmentData.iStatus = 0) THEN
	(* Setup method calling parameters *)
		(* Method identifier *)
		sObjectIDentifier := stAddPathSegmentData.sObjectID;
		sMethodIdentifier := stAddPathSegmentData.sMethodID;
	
		(* Method Inputs *)
		stAddPathSegmentData.stInput.sCellID := sCellID;
		stAddPathSegmentData.stInput.sSegmentID := CONCAT(sCellID, '_PS');
		stAddPathSegmentData.stInput.sSegmentID := CONCAT(stAddPathSegmentData.stInput.sSegmentID, UINT_TO_STRING(iSegmentNo));			
		stAddPathSegmentData.stInput.iPath := nPathNo;
		stAddPathSegmentData.stInput.rBeginPosition := rBeginPosition;
		stAddPathSegmentData.stInput.rEndPosition := rEndPosition;
		(* Fill input data area with method arguments *)
		MEMSET(ADR(aInputData), 0 ,SIZEOF(aInputData));
		nOffset := 0;
		nOffset := nOffset + MEMCPY(ADR(aInputData)+nOffset, ADR(stAddPathSegmentData.stInput), MIN(SIZEOF(stAddPathSegmentData.stInput), (SIZEOF(aInputData)-nOffset)) );
		(* Number of input arguments *)
		nNoOfInputArgs := stAddPathSegmentData.iNoOfInputArgs;
		(* Set up input argument information *)
		MEMSET(ADR(aInputArgInfo), 0, SIZEOF(aInputArgInfo));
		aInputArgInfo[1].DataType := eUAType_String;
		aInputArgInfo[1].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[1].nLenData := SIZEOF(stAddPathSegmentData.stInput.sCellID);
		aInputArgInfo[2].DataType := eUAType_String;
		aInputArgInfo[2].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[2].nLenData := SIZEOF(stAddPathSegmentData.stInput.sSegmentID);
		aInputArgInfo[3].DataType := eUAType_UInt16;
		aInputArgInfo[3].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[3].nLenData := SIZEOF(stAddPathSegmentData.stInput.iPath);
		aInputArgInfo[4].DataType := eUAType_Float;
		aInputArgInfo[4].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[4].nLenData := SIZEOF(stAddPathSegmentData.stInput.rBeginPosition);
		aInputArgInfo[5].DataType := eUAType_Float;
		aInputArgInfo[5].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[5].nLenData := SIZEOF(stAddPathSegmentData.stInput.rEndPosition);
		
		(* Method outputs *)
		(* Clear output data area *)
		(* Number of output arguments *)
		nNoOfOutputArgs := stAddPathSegmentData.iNoOfOutputArgs;
		(* Set up output argument information *)
		MEMSET(ADR(aOutputArgInfo), 0, SIZEOF(aOutputArgInfo));
		aOutputArgInfo[1].DataType := eUAType_Uint16;
		aOutputArgInfo[1].ValueRank := -1;
		aOutputArgInfo[1].nLenData := SIZEOF(stAddPathSegmentData.stOutput.eStatus);
		aOutputArgInfo[2].DataType := eUAType_String;
		aOutputArgInfo[2].ValueRank := -1;
		aOutputArgInfo[2].nLenData := SIZEOF(stAddPathSegmentData.stOutput.sMessage);
		(* Set up output  *)
		MEMSET(ADR(stAddPathSegmentData.stOutput), 0, SIZEOF(stAddPathSegmentData.stOutput));
		stAddPathSegmentData.stOutput.nNumberOfOutputArguments := nNoOfOutputArgs;
		stAddPathSegmentData.stOutput.stOutputArgInfo[1] := aOutputArgInfo[1];
		stAddPathSegmentData.stOutput.stOutputArgInfo[2] := aOutputArgInfo[2];
	
		(* Execute FB *)
		fbCallMethod.nNumberOfInputArguments := nNoOfInputArgs;
		fbCallMethod.pInputArgInfo := ADR(aInputArgInfo);
		fbCallMethod.cbInputArgInfo := (SIZEOF(aInputArgInfo[1])*nNoOfInputArgs);
		fbCallMethod.pInputArgData := ADR(aInputData);
		fbCallMethod.cbInputArgData := nOffset;
		fbCallMethod.nNumberOfOutputArguments := nNoOfOutputArgs; 
		fbCallMethod.pOutputArgInfo := ADR(aOutputArgInfo); 
		fbCallMethod.cbOutputArgInfo := (SIZEOF(aOutputArgInfo[1]) * nNoOfOutputArgs); 
		fbCallMethod.pOutputArgInfoAndData := ADR(stAddPathSegmentData.stOutput);
		fbCallMethod.cbOutputArgInfoAndData := SIZEOF(stAddPathSegmentData.stOutput);
		
		stAddPathSegmentData.iStatus := 1;
		bCallMethod := TRUE;
		
	ELSIF (stAddPathSegmentData.iStatus = 1) THEN
		// Method call Completed...
		IF (eStateMethod = E_TrackClientState.Connected) THEN
			// Method call OK
			IF (stAddPathSegmentData.stOutput.eStatus = E_MMServerStatus.eMMServerStatus_Success) THEN
				// Method returned OK
				stAddPathSegmentData.iStatus := 2;
			ELSE
				// Method returned with error
				stAddPathSegmentData.iStatus := 3;
				stAddPathSegmentData.stOutput.sMessage;
			END_IF
		ELSIF (eStateMethod = E_TrackClientState.Error) THEN
			// Method call failed
			stAddPathSegmentData.iStatus := 3;
		END_IF
		
	END_IF
END_IF

M_CallAddPathSegment := stAddPathSegmentData.iStatus;	
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_CallAddReservation" Id="{8463457c-3357-4365-b2ca-16e3af92ba18}">
      <Declaration><![CDATA[METHOD PROTECTED M_CallAddReservation : INT
VAR_INPUT
	sStationID					: STRING(30);												(* The identifier for the station. *)
	sCarrierID					: STRING(30);												(* The ID of the carrier *)
	nTicket						: UINT;														(*  *)
	nTicketSize					: UINT;														(*  *)
	nPriority					: UINT;														(*  *)
END_VAR
VAR
	i					: UINT;	
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF (stAddReservationData.iStatus = 2) OR (stAddReservationData.iStatus = 3) THEN
	stAddReservationData.iStatus := 0;
END_IF

IF (bConnectedMethod AND NOT bBusyMethod) THEN
	IF (stAddReservationData.iStatus = 0) THEN
	(* Setup method calling parameters *)
		(* Method identifier *)
		sObjectIDentifier := stAddReservationData.sObjectID;
		sMethodIdentifier := stAddReservationData.sMethodID;
	
		(* Method Inputs *)
		stAddReservationData.stInput.sStationID := sStationID;
		stAddReservationData.stInput.sCarrierID := sCarrierID;
		stAddReservationData.stInput.nTicket := nTicket;
		stAddReservationData.stInput.nTicketSize := nTicketSize;
		stAddReservationData.stInput.nPriority := nPriority;
		(* Fill input data area with method arguments *)
		MEMSET(ADR(aInputData), 0 ,SIZEOF(aInputData));
		nOffset := 0;
		nOffset := nOffset + MEMCPY(ADR(aInputData)+nOffset, ADR(stAddReservationData.stInput),	MIN(SIZEOF(stAddReservationData.stInput), (SIZEOF(aInputData)-nOffset)) );
		(* Number of input arguments *)
		nNoOfInputArgs := stAddReservationData.iNoOfInputArgs;
		(* Set up input argument information *)
		MEMSET(ADR(aInputArgInfo), 0, SIZEOF(aInputArgInfo));
		aInputArgInfo[1].DataType := eUAType_String;
		aInputArgInfo[1].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[1].nLenData := SIZEOF(stAddReservationData.stInput.sStationID);
		aInputArgInfo[2].DataType := eUAType_String;
		aInputArgInfo[2].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[2].nLenData := SIZEOF(stAddReservationData.stInput.sCarrierID);
		aInputArgInfo[3].DataType := eUAType_UInt16;
		aInputArgInfo[3].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[3].nLenData := SIZEOF(stAddReservationData.stInput.nTicket);
		aInputArgInfo[4].DataType := eUAType_UInt16;
		aInputArgInfo[4].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[4].nLenData := SIZEOF(stAddReservationData.stInput.nTicketSize);
		aInputArgInfo[5].DataType := eUAType_UInt16;
		aInputArgInfo[5].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[5].nLenData := SIZEOF(stAddReservationData.stInput.nPriority);
		
		(* Method outputs *)
		(* Clear output data area *)
		(* Number of output arguments *)
		nNoOfOutputArgs := stAddReservationData.iNoOfOutputArgs;
		(* Set up output argument information *)
		MEMSET(ADR(aOutputArgInfo), 0, SIZEOF(aOutputArgInfo));
		aOutputArgInfo[1].DataType := eUAType_Uint16;
		aOutputArgInfo[1].ValueRank := -1;
		aOutputArgInfo[1].nLenData := SIZEOF(stAddReservationData.stOutput.eStatus);
		aOutputArgInfo[2].DataType := eUAType_String;
		aOutputArgInfo[2].ValueRank := -1;
		aOutputArgInfo[2].nLenData := SIZEOF(stAddReservationData.stOutput.sMessage);
		(* Set up output  *)
		MEMSET(ADR(stAddReservationData.stOutput), 0, SIZEOF(stAddReservationData.stOutput));
		stAddReservationData.stOutput.nNumberOfOutputArguments := nNoOfOutputArgs;
		stAddReservationData.stOutput.stOutputArgInfo[1] := aOutputArgInfo[1];
		stAddReservationData.stOutput.stOutputArgInfo[2] := aOutputArgInfo[2];
	
		(* Execute FB *)
		fbCallMethod.nNumberOfInputArguments := nNoOfInputArgs;
		fbCallMethod.pInputArgInfo := ADR(aInputArgInfo);
		fbCallMethod.cbInputArgInfo := (SIZEOF(aInputArgInfo[1])*nNoOfInputArgs);
		fbCallMethod.pInputArgData := ADR(aInputData);
		fbCallMethod.cbInputArgData := nOffset;
		fbCallMethod.nNumberOfOutputArguments := nNoOfOutputArgs; 
		fbCallMethod.pOutputArgInfo := ADR(aOutputArgInfo); 
		fbCallMethod.cbOutputArgInfo := (SIZEOF(aOutputArgInfo[1]) * nNoOfOutputArgs); 
		fbCallMethod.pOutputArgInfoAndData := ADR(stAddReservationData.stOutput);
		fbCallMethod.cbOutputArgInfoAndData := SIZEOF(stAddReservationData.stOutput);
		
		stAddReservationData.iStatus := 1;
		bCallMethod := TRUE;
		
	ELSIF (stAddReservationData.iStatus = 1) THEN
		// Method call Completed...
		IF (eStateMethod = E_TrackClientState.Connected) THEN
			// Method call OK
			IF (stAddReservationData.stOutput.eStatus = E_MMServerStatus.eMMServerStatus_Success) THEN
				// Method returned OK
				stAddReservationData.iStatus := 2;
			ELSE
				// Method returned with error
				stAddReservationData.iStatus := 3;
				stAddReservationData.stOutput.sMessage;
			END_IF
		ELSIF (eStateMethod = E_TrackClientState.Error) THEN
			// Method call failed
			stAddReservationData.iStatus := 3;
		END_IF
		
	END_IF
END_IF

M_CallAddReservation := stAddReservationData.iStatus;	
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_CallAddStationDouble" Id="{4ac951a4-17d3-4c18-8138-422b88041efa}">
      <Declaration><![CDATA[METHOD PROTECTED M_CallAddStationDouble : INT
VAR_INPUT
	nStationNo			: UINT(1..5);
END_VAR
VAR
	i					: UINT;	
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF (stAddStationDoubleData.iStatus = 2) OR (stAddStationDoubleData.iStatus = 3) THEN
	stAddStationDoubleData.iStatus := 0;
END_IF

IF (bConnectedMethod AND NOT bBusyMethod) THEN
	IF (stAddStationDoubleData.iStatus = 0) THEN
	(* Setup method calling parameters *)
		(* Method identifier *)
		sObjectIDentifier := stAddStationDoubleData.sObjectID;
		sMethodIdentifier := stAddStationDoubleData.sMethodID;
	
		(* Method Inputs *)
		stAddStationDoubleData.stInput.sCellID := sCellID;
		stAddStationDoubleData.stInput.sID := aStations[nStationNo].sStationID;
		stAddStationDoubleData.stInput.iInPath := aStations[nStationNo].stStationData1.stLocation.nPathID;
		stAddStationDoubleData.stInput.rInPosition := aStations[nStationNo].stStationData1.stLocation.fPosition;
		stAddStationDoubleData.stInput.iOutPath := aStations[nStationNo].stStationData2.stLocation.nPathID;
		stAddStationDoubleData.stInput.rOutPosition := aStations[nStationNo].stStationData2.stLocation.fPosition;
		stAddStationDoubleData.stInput.iDecisionPath := aStations[nStationNo].stDecisionLocation.nPathID;
		stAddStationDoubleData.stInput.rDecisionPosition := aStations[nStationNo].stDecisionLocation.fPosition;
		stAddStationDoubleData.stInput.nPreBufferSize := 0;
		stAddStationDoubleData.stInput.nPostBufferSize := 0;
		// Calc buffer size
		FOR i := 1 TO 20 BY 1 DO
			IF (aStations[nStationNo].astPreBuffer[i].bPresent) THEN
				stAddStationDoubleData.stInput.nPreBufferSize := stAddStationDoubleData.stInput.nPreBufferSize + 1;
			END_IF
			IF (aStations[nStationNo].astPostBuffer[i].bPresent) THEN
				stAddStationDoubleData.stInput.nPostBufferSize := stAddStationDoubleData.stInput.nPostBufferSize + 1;
			END_IF
		END_FOR
		(* Fill input data area with method arguments *)
		MEMSET(ADR(aInputData), 0 ,SIZEOF(aInputData));
		nOffset := 0;
		nOffset := nOffset + MEMCPY(ADR(aInputData)+nOffset, ADR(stAddStationDoubleData.stInput),	MIN(SIZEOF(stAddStationDoubleData.stInput), (SIZEOF(aInputData)-nOffset)) );
		(* Number of input arguments *)
		nNoOfInputArgs := stAddStationDoubleData.iNoOfInputArgs;
		(* Set up input argument information *)
		MEMSET(ADR(aInputArgInfo), 0, SIZEOF(aInputArgInfo));
		aInputArgInfo[1].DataType := eUAType_String;
		aInputArgInfo[1].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[1].nLenData := SIZEOF(stAddStationDoubleData.stInput.sCellID);
		aInputArgInfo[2].DataType := eUAType_String;
		aInputArgInfo[2].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[2].nLenData := SIZEOF(stAddStationDoubleData.stInput.sID);
		aInputArgInfo[3].DataType := eUAType_UInt16;
		aInputArgInfo[3].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[3].nLenData := SIZEOF(stAddStationDoubleData.stInput.iInPath);
		aInputArgInfo[4].DataType := eUAType_Float;
		aInputArgInfo[4].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[4].nLenData := SIZEOF(stAddStationDoubleData.stInput.rInPosition);
		aInputArgInfo[5].DataType := eUAType_UInt16;
		aInputArgInfo[5].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[5].nLenData := SIZEOF(stAddStationDoubleData.stInput.iOutPath);
		aInputArgInfo[6].DataType := eUAType_Float;
		aInputArgInfo[6].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[6].nLenData := SIZEOF(stAddStationDoubleData.stInput.rOutPosition);
		aInputArgInfo[7].DataType := eUAType_UInt16;
		aInputArgInfo[7].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[7].nLenData := SIZEOF(stAddStationDoubleData.stInput.iDecisionPath);
		aInputArgInfo[8].DataType := eUAType_Float;
		aInputArgInfo[8].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[8].nLenData := SIZEOF(stAddStationDoubleData.stInput.rDecisionPosition);
		aInputArgInfo[9].DataType := eUAType_UInt16;
		aInputArgInfo[9].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[9].nLenData := SIZEOF(stAddStationDoubleData.stInput.nPreBufferSize);
		aInputArgInfo[10].DataType := eUAType_UInt16;
		aInputArgInfo[10].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[10].nLenData := SIZEOF(stAddStationDoubleData.stInput.nPostBufferSize);
		
		(* Method outputs *)
		(* Clear output data area *)
		(* Number of output arguments *)
		nNoOfOutputArgs := stAddStationDoubleData.iNoOfOutputArgs;
		(* Set up output argument information *)
		MEMSET(ADR(aOutputArgInfo), 0, SIZEOF(aOutputArgInfo));
		aOutputArgInfo[1].DataType := eUAType_Uint16;
		aOutputArgInfo[1].ValueRank := -1;
		aOutputArgInfo[1].nLenData := SIZEOF(stAddStationDoubleData.stOutput.eStatus);
		aOutputArgInfo[2].DataType := eUAType_String;
		aOutputArgInfo[2].ValueRank := -1;
		aOutputArgInfo[2].nLenData := SIZEOF(stAddStationDoubleData.stOutput.sMessage);
		(* Set up output  *)
		MEMSET(ADR(stAddStationDoubleData.stOutput), 0, SIZEOF(stAddStationDoubleData.stOutput));
		stAddStationDoubleData.stOutput.nNumberOfOutputArguments := nNoOfOutputArgs;
		stAddStationDoubleData.stOutput.stOutputArgInfo[1] := aOutputArgInfo[1];
		stAddStationDoubleData.stOutput.stOutputArgInfo[2] := aOutputArgInfo[2];
	
		(* Execute FB *)
		fbCallMethod.nNumberOfInputArguments := nNoOfInputArgs;
		fbCallMethod.pInputArgInfo := ADR(aInputArgInfo);
		fbCallMethod.cbInputArgInfo := (SIZEOF(aInputArgInfo[1])*nNoOfInputArgs);
		fbCallMethod.pInputArgData := ADR(aInputData);
		fbCallMethod.cbInputArgData := nOffset;
		fbCallMethod.nNumberOfOutputArguments := nNoOfOutputArgs; 
		fbCallMethod.pOutputArgInfo := ADR(aOutputArgInfo); 
		fbCallMethod.cbOutputArgInfo := (SIZEOF(aOutputArgInfo[1]) * nNoOfOutputArgs); 
		fbCallMethod.pOutputArgInfoAndData := ADR(stAddStationDoubleData.stOutput);
		fbCallMethod.cbOutputArgInfoAndData := SIZEOF(stAddStationDoubleData.stOutput);
		
		stAddStationDoubleData.iStatus := 1;
		bCallMethod := TRUE;
		
	ELSIF (stAddStationDoubleData.iStatus = 1) THEN
		// Method call Completed...
		IF (eStateMethod = E_TrackClientState.Connected) THEN
			// Method call OK
			IF (stAddStationDoubleData.stOutput.eStatus = E_MMServerStatus.eMMServerStatus_Success) THEN
				// Method returned OK
				stAddStationDoubleData.iStatus := 2;
			ELSIF (stAddStationDoubleData.stOutput.eStatus = E_MMServerStatus.eMMServerStatus_Rejected_ConfigurationAlreadyDefined) THEN
				// Method returned rejected... Already defined, this is OK
				stAddStationDoubleData.iStatus := 2;
			ELSE
				// Method returned with error
				stAddStationDoubleData.iStatus := 3;
				stAddStationDoubleData.stOutput.sMessage;
			END_IF
		ELSIF (eStateMethod = E_TrackClientState.Error) THEN
			// Method call failed
			stAddStationDoubleData.iStatus := 3;
		END_IF
		
	END_IF
END_IF

M_CallAddStationDouble := stAddStationDoubleData.iStatus;	
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_CallAddStationSingle" Id="{c2075884-4710-46d6-b9e2-6200882a642f}">
      <Declaration><![CDATA[METHOD PROTECTED M_CallAddStationSingle : INT
VAR_INPUT
	nStationNo			: UINT(1..5);
END_VAR
VAR
	i					: UINT;	
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF (stAddStationSingleData.iStatus = 2) OR (stAddStationSingleData.iStatus = 3) THEN
	stAddStationSingleData.iStatus := 0;
END_IF

IF (bConnectedMethod AND NOT bBusyMethod) THEN
	IF (stAddStationSingleData.iStatus = 0) THEN
	(* Setup method calling parameters *)
		(* Method identifier *)
		sObjectIDentifier := stAddStationSingleData.sObjectID;
		sMethodIdentifier := stAddStationSingleData.sMethodID;
	
		(* Method Inputs *)
		stAddStationSingleData.stInput.sCellID := sCellID;
		stAddStationSingleData.stInput.sID := aStations[nStationNo].sStationID;
		stAddStationSingleData.stInput.iPath := aStations[nStationNo].stStationData1.stLocation.nPathID;
		stAddStationSingleData.stInput.rPosition := aStations[nStationNo].stStationData1.stLocation.fPosition;
		stAddStationSingleData.stInput.iDecisionPath := aStations[nStationNo].stDecisionLocation.nPathID;
		stAddStationSingleData.stInput.rDecisionPosition := aStations[nStationNo].stDecisionLocation.fPosition;
		stAddStationSingleData.stInput.nPreBufferSize := 0;
		stAddStationSingleData.stInput.nPostBufferSize := 0;
		// Calc buffer size
		FOR i := 1 TO 20 BY 1 DO
			IF (aStations[nStationNo].astPreBuffer[i].bPresent) THEN
				stAddStationSingleData.stInput.nPreBufferSize := stAddStationSingleData.stInput.nPreBufferSize + 1;
			END_IF
			IF (aStations[nStationNo].astPostBuffer[i].bPresent) THEN
				stAddStationSingleData.stInput.nPostBufferSize := stAddStationSingleData.stInput.nPostBufferSize + 1;
			END_IF
		END_FOR
		(* Fill input data area with method arguments *)
		MEMSET(ADR(aInputData), 0 ,SIZEOF(aInputData));
		nOffset := 0;
		nOffset := nOffset + MEMCPY(ADR(aInputData)+nOffset, ADR(stAddStationSingleData.stInput),	MIN(SIZEOF(stAddStationSingleData.stInput), (SIZEOF(aInputData)-nOffset)) );
		(* Number of input arguments *)
		nNoOfInputArgs := stAddStationSingleData.iNoOfInputArgs;
		(* Set up input argument information *)
		MEMSET(ADR(aInputArgInfo), 0, SIZEOF(aInputArgInfo));
		aInputArgInfo[1].DataType := eUAType_String;
		aInputArgInfo[1].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[1].nLenData := SIZEOF(stAddStationSingleData.stInput.sCellID);
		aInputArgInfo[2].DataType := eUAType_String;
		aInputArgInfo[2].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[2].nLenData := SIZEOF(stAddStationSingleData.stInput.sID);
		aInputArgInfo[3].DataType := eUAType_UInt16;
		aInputArgInfo[3].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[3].nLenData := SIZEOF(stAddStationSingleData.stInput.iPath);
		aInputArgInfo[4].DataType := eUAType_Float;
		aInputArgInfo[4].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[4].nLenData := SIZEOF(stAddStationSingleData.stInput.rPosition);
		aInputArgInfo[5].DataType := eUAType_UInt16;
		aInputArgInfo[5].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[5].nLenData := SIZEOF(stAddStationSingleData.stInput.iDecisionPath);
		aInputArgInfo[6].DataType := eUAType_Float;
		aInputArgInfo[6].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[6].nLenData := SIZEOF(stAddStationSingleData.stInput.rDecisionPosition);
		aInputArgInfo[7].DataType := eUAType_UInt16;
		aInputArgInfo[7].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[7].nLenData := SIZEOF(stAddStationSingleData.stInput.nPreBufferSize);
		aInputArgInfo[8].DataType := eUAType_UInt16;
		aInputArgInfo[8].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[8].nLenData := SIZEOF(stAddStationSingleData.stInput.nPostBufferSize);
		
		(* Method outputs *)
		(* Clear output data area *)
		(* Number of output arguments *)
		nNoOfOutputArgs := stAddStationSingleData.iNoOfOutputArgs;
		(* Set up output argument information *)
		MEMSET(ADR(aOutputArgInfo), 0, SIZEOF(aOutputArgInfo));
		aOutputArgInfo[1].DataType := eUAType_Uint16;
		aOutputArgInfo[1].ValueRank := -1;
		aOutputArgInfo[1].nLenData := SIZEOF(stAddStationSingleData.stOutput.eStatus);
		aOutputArgInfo[2].DataType := eUAType_String;
		aOutputArgInfo[2].ValueRank := -1;
		aOutputArgInfo[2].nLenData := SIZEOF(stAddStationSingleData.stOutput.sMessage);
		(* Set up output  *)
		MEMSET(ADR(stAddStationSingleData.stOutput), 0, SIZEOF(stAddStationSingleData.stOutput));
		stAddStationSingleData.stOutput.nNumberOfOutputArguments := nNoOfOutputArgs;
		stAddStationSingleData.stOutput.stOutputArgInfo[1] := aOutputArgInfo[1];
		stAddStationSingleData.stOutput.stOutputArgInfo[2] := aOutputArgInfo[2];
	
		(* Execute FB *)
		fbCallMethod.nNumberOfInputArguments := nNoOfInputArgs;
		fbCallMethod.pInputArgInfo := ADR(aInputArgInfo);
		fbCallMethod.cbInputArgInfo := (SIZEOF(aInputArgInfo[1])*nNoOfInputArgs);
		fbCallMethod.pInputArgData := ADR(aInputData);
		fbCallMethod.cbInputArgData := nOffset;
		fbCallMethod.nNumberOfOutputArguments := nNoOfOutputArgs; 
		fbCallMethod.pOutputArgInfo := ADR(aOutputArgInfo); 
		fbCallMethod.cbOutputArgInfo := (SIZEOF(aOutputArgInfo[1]) * nNoOfOutputArgs); 
		fbCallMethod.pOutputArgInfoAndData := ADR(stAddStationSingleData.stOutput);
		fbCallMethod.cbOutputArgInfoAndData := SIZEOF(stAddStationSingleData.stOutput);
		
		stAddStationSingleData.iStatus := 1;
		bCallMethod := TRUE;
		
	ELSIF (stAddStationSingleData.iStatus = 1) THEN
		// Method call Completed...
		IF (eStateMethod = E_TrackClientState.Connected) THEN
			// Method call OK
			IF (stAddStationSingleData.stOutput.eStatus = E_MMServerStatus.eMMServerStatus_Success) THEN
				// Method returned OK
				stAddStationSingleData.iStatus := 2;
			ELSIF (stAddStationSingleData.stOutput.eStatus = E_MMServerStatus.eMMServerStatus_Rejected_ConfigurationAlreadyDefined) THEN
				// Method returned rejected... Already defined, this is OK
				stAddStationSingleData.iStatus := 2;
			ELSE
				// Method returned with error
				stAddStationSingleData.iStatus := 3;
				stAddStationSingleData.stOutput.sMessage;
			END_IF
		ELSIF (eStateMethod = E_TrackClientState.Error) THEN
			// Method call failed
			stAddStationSingleData.iStatus := 3;
		END_IF
		
	END_IF
END_IF

M_CallAddStationSingle := stAddStationSingleData.iStatus;	
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_CallAddTrafficLight" Id="{54cb9d7a-29b8-49d8-b018-b9c14e7e7a57}">
      <Declaration><![CDATA[METHOD PROTECTED M_CallAddTrafficLight : INT
VAR_INPUT
	nTrafficLightID	: UINT;
	nPathID			: UINT;
	fPosition		: REAL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF (stAddTrafficLightData.iStatus = 2) OR (stAddTrafficLightData.iStatus = 3) THEN
	stAddTrafficLightData.iStatus := 0;
END_IF

IF (bConnectedMethod AND NOT bBusyMethod) THEN
	IF (stAddTrafficLightData.iStatus = 0) THEN
	(* Setup method calling parameters *)
		(* Method identifier *)
		sObjectIDentifier := stAddTrafficLightData.sObjectID;
		sMethodIdentifier := stAddTrafficLightData.sMethodID;
	
		(* Method Inputs *)
		stAddTrafficLightData.stInput.sCellID := sCellID;
		stAddTrafficLightData.stInput.sID := CONCAT(sCellID, '_TL');
		stAddTrafficLightData.stInput.sID := CONCAT(stAddTrafficLightData.stInput.sID, UINT_TO_STRING(nTrafficLightID));
		stAddTrafficLightData.stInput.iPath := nPathID;
		stAddTrafficLightData.stInput.rPosition := fPosition;
		(* Fill input data area with method arguments *)
		MEMSET(ADR(aInputData), 0 ,SIZEOF(aInputData));
		nOffset := 0;
		nOffset := nOffset + MEMCPY(ADR(aInputData)+nOffset, ADR(stAddTrafficLightData.stInput),	MIN(SIZEOF(stAddTrafficLightData.stInput),	(SIZEOF(aInputData)-nOffset)) );
		(* Number of input arguments *)
		nNoOfInputArgs := stAddTrafficLightData.iNoOfInputArgs;
		(* Set up input argument information *)
		MEMSET(ADR(aInputArgInfo), 0, SIZEOF(aInputArgInfo));
		aInputArgInfo[1].DataType := eUAType_String;
		aInputArgInfo[1].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[1].nLenData := SIZEOF(stAddTrafficLightData.stInput.sCellID);
		aInputArgInfo[2].DataType := eUAType_String;
		aInputArgInfo[2].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[2].nLenData := SIZEOF(stAddTrafficLightData.stInput.sID);
		aInputArgInfo[3].DataType := eUAType_UInt16;
		aInputArgInfo[3].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[3].nLenData := SIZEOF(stAddTrafficLightData.stInput.iPath);
		aInputArgInfo[4].DataType := eUAType_Float;
		aInputArgInfo[4].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[4].nLenData := SIZEOF(stAddTrafficLightData.stInput.rPosition);
		
		(* Method outputs *)
		(* Clear output data area *)
		(* Number of output arguments *)
		nNoOfOutputArgs := stAddTrafficLightData.iNoOfOutputArgs;
		(* Set up output argument information *)
		MEMSET(ADR(aOutputArgInfo), 0, SIZEOF(aOutputArgInfo));
		aOutputArgInfo[1].DataType := eUAType_Uint16;
		aOutputArgInfo[1].ValueRank := -1;
		aOutputArgInfo[1].nLenData := SIZEOF(stAddTrafficLightData.stOutput.eStatus);
		aOutputArgInfo[2].DataType := eUAType_String;
		aOutputArgInfo[2].ValueRank := -1;
		aOutputArgInfo[2].nLenData := SIZEOF(stAddTrafficLightData.stOutput.sMessage);
		(* Set up output  *)
		MEMSET(ADR(stAddTrafficLightData.stOutput), 0, SIZEOF(stAddTrafficLightData.stOutput));
		stAddTrafficLightData.stOutput.nNumberOfOutputArguments := nNoOfOutputArgs;
		stAddTrafficLightData.stOutput.stOutputArgInfo[1] := aOutputArgInfo[1];
		stAddTrafficLightData.stOutput.stOutputArgInfo[2] := aOutputArgInfo[2];
	
		(* Execute FB *)
		fbCallMethod.nNumberOfInputArguments := nNoOfInputArgs;
		fbCallMethod.pInputArgInfo := ADR(aInputArgInfo);
		fbCallMethod.cbInputArgInfo := (SIZEOF(aInputArgInfo[1])*nNoOfInputArgs);
		fbCallMethod.pInputArgData := ADR(aInputData);
		fbCallMethod.cbInputArgData := nOffset;
		fbCallMethod.nNumberOfOutputArguments := nNoOfOutputArgs; 
		fbCallMethod.pOutputArgInfo := ADR(aOutputArgInfo); 
		fbCallMethod.cbOutputArgInfo := (SIZEOF(aOutputArgInfo[1]) * nNoOfOutputArgs); 
		fbCallMethod.pOutputArgInfoAndData := ADR(stAddTrafficLightData.stOutput);
		fbCallMethod.cbOutputArgInfoAndData := SIZEOF(stAddTrafficLightData.stOutput);
		
		stAddTrafficLightData.iStatus := 1;
		bCallMethod := TRUE;
		
	ELSIF (stAddTrafficLightData.iStatus = 1) THEN
		// Method call Completed...
		IF (eStateMethod = E_TrackClientState.Connected) THEN
			// Method call OK
			IF (stAddTrafficLightData.stOutput.eStatus = E_MMServerStatus.eMMServerStatus_Success) THEN
				// Method returned OK
				stAddTrafficLightData.iStatus := 2;
			ELSE
				// Method returned with error
				stAddTrafficLightData.iStatus := 3;
				stAddTrafficLightData.stOutput.sMessage;
			END_IF
		ELSIF (eStateMethod = E_TrackClientState.Error) THEN
			// Method call failed
			stAddTrafficLightData.iStatus := 3;
		END_IF
		
	END_IF
END_IF

M_CallAddTrafficLight := stAddTrafficLightData.iStatus;	
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_CallAdjustBufferPosition" Id="{d74a7a82-68ca-4e44-870e-9ccc8dfe228c}">
      <Declaration><![CDATA[METHOD PROTECTED M_CallAdjustBufferPosition : INT
VAR_INPUT
	nStationNo			: UINT(1..5);
	eBufferType			: E_MMStationBuffer;	// Pre- or Post-buffer
	rDistance			: REAL;					// [M9 Distance in metres (negative value to move backwards)
END_VAR
VAR
	i					: UINT;	
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF (stAdjustBufferPosData.iStatus = 2) OR (stAdjustBufferPosData.iStatus = 3) THEN
	stAdjustBufferPosData.iStatus := 0;
END_IF

IF (bConnectedMethod AND NOT bBusyMethod) THEN
	IF (stAdjustBufferPosData.iStatus = 0) THEN
	(* Setup method calling parameters *)
		(* Method identifier *)
		sObjectIDentifier := stAdjustBufferPosData.sObjectID;
		sMethodIdentifier := stAdjustBufferPosData.sMethodID;
	
		(* Method Inputs *)
		stAdjustBufferPosData.stInput.sStationID := aStations[nStationNo].sStationID;
		stAdjustBufferPosData.stInput.eBufferType := eBufferType;
		stAdjustBufferPosData.stInput.rDistance := rDistance;
		(* Fill input data area with method arguments *)
		MEMSET(ADR(aInputData), 0 ,SIZEOF(aInputData));
		nOffset := 0;
		nOffset := nOffset + MEMCPY(ADR(aInputData)+nOffset, ADR(stAdjustBufferPosData.stInput),	MIN(SIZEOF(stAdjustBufferPosData.stInput), (SIZEOF(aInputData)-nOffset)) );
		(* Number of input arguments *)
		nNoOfInputArgs := stAdjustBufferPosData.iNoOfInputArgs;
		(* Set up input argument information *)
		MEMSET(ADR(aInputArgInfo), 0, SIZEOF(aInputArgInfo));
		aInputArgInfo[1].DataType := eUAType_String;
		aInputArgInfo[1].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[1].nLenData := SIZEOF(stAdjustBufferPosData.stInput.sStationID);
		aInputArgInfo[2].DataType := eUAType_UInt16;
		aInputArgInfo[2].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[2].nLenData := SIZEOF(stAdjustBufferPosData.stInput.eBufferType);
		aInputArgInfo[3].DataType := eUAType_Float;
		aInputArgInfo[3].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[3].nLenData := SIZEOF(stAdjustBufferPosData.stInput.rDistance);
		
		(* Method outputs *)
		(* Clear output data area *)
		(* Number of output arguments *)
		nNoOfOutputArgs := stAdjustBufferPosData.iNoOfOutputArgs;
		(* Set up output argument information *)
		MEMSET(ADR(aOutputArgInfo), 0, SIZEOF(aOutputArgInfo));
		aOutputArgInfo[1].DataType := eUAType_Uint16;
		aOutputArgInfo[1].ValueRank := -1;
		aOutputArgInfo[1].nLenData := SIZEOF(stAdjustBufferPosData.stOutput.eStatus);
		aOutputArgInfo[2].DataType := eUAType_String;
		aOutputArgInfo[2].ValueRank := -1;
		aOutputArgInfo[2].nLenData := SIZEOF(stAdjustBufferPosData.stOutput.sMessage);
		(* Set up output  *)
		MEMSET(ADR(stAdjustBufferPosData.stOutput), 0, SIZEOF(stAdjustBufferPosData.stOutput));
		stAdjustBufferPosData.stOutput.nNumberOfOutputArguments := nNoOfOutputArgs;
		stAdjustBufferPosData.stOutput.stOutputArgInfo[1] := aOutputArgInfo[1];
		stAdjustBufferPosData.stOutput.stOutputArgInfo[2] := aOutputArgInfo[2];
	
		(* Execute FB *)
		fbCallMethod.nNumberOfInputArguments := nNoOfInputArgs;
		fbCallMethod.pInputArgInfo := ADR(aInputArgInfo);
		fbCallMethod.cbInputArgInfo := (SIZEOF(aInputArgInfo[1])*nNoOfInputArgs);
		fbCallMethod.pInputArgData := ADR(aInputData);
		fbCallMethod.cbInputArgData := nOffset;
		fbCallMethod.nNumberOfOutputArguments := nNoOfOutputArgs; 
		fbCallMethod.pOutputArgInfo := ADR(aOutputArgInfo); 
		fbCallMethod.cbOutputArgInfo := (SIZEOF(aOutputArgInfo[1]) * nNoOfOutputArgs); 
		fbCallMethod.pOutputArgInfoAndData := ADR(stAdjustBufferPosData.stOutput);
		fbCallMethod.cbOutputArgInfoAndData := SIZEOF(stAdjustBufferPosData.stOutput);
		
		stAdjustBufferPosData.iStatus := 1;
		bCallMethod := TRUE;
		
	ELSIF (stAdjustBufferPosData.iStatus = 1) THEN
		// Method call Completed...
		IF (eStateMethod = E_TrackClientState.Connected) THEN
			// Method call OK
			IF (stAdjustBufferPosData.stOutput.eStatus = E_MMServerStatus.eMMServerStatus_Success) THEN
				// Method returned OK
				stAdjustBufferPosData.iStatus := 2;
			ELSE
				// Method returned with error
				stAdjustBufferPosData.iStatus := 3;
				stAdjustBufferPosData.stOutput.sMessage;
			END_IF
		ELSIF (eStateMethod = E_TrackClientState.Error) THEN
			// Method call failed
			stAdjustBufferPosData.iStatus := 3;
		END_IF
		
	END_IF
END_IF

M_CallAdjustBufferPosition := stAdjustBufferPosData.iStatus;	
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_CallEnableStation" Id="{2df14879-a9d2-4c81-a5b8-7b562f03d8cc}">
      <Declaration><![CDATA[METHOD PROTECTED M_CallEnableStation : INT
VAR_INPUT
	nStationNo			: UINT(1..5);
END_VAR
VAR
	i					: UINT;	
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF (stEnableStationData.iStatus = 2) OR (stEnableStationData.iStatus = 3) THEN
	stEnableStationData.iStatus := 0;
END_IF

IF (bConnectedMethod AND NOT bBusyMethod) THEN
	IF (stEnableStationData.iStatus = 0) THEN
	(* Setup method calling parameters *)
		(* Method identifier *)
		sObjectIDentifier := stEnableStationData.sObjectID;
		sMethodIdentifier := stEnableStationData.sMethodID;
	
		(* Method Inputs *)
		stEnableStationData.stInput.sCellID := sCellID;
		stEnableStationData.stInput.sID := CONCAT(sCellID, CONCAT('_ST', UINT_TO_STRING(nStationNo)));
		stEnableStationData.stInput.bPresent := aStations[nStationNo].bPresent;
		(* Fill input data area with method arguments *)
		MEMSET(ADR(aInputData), 0 ,SIZEOF(aInputData));
		nOffset := 0;
		nOffset := nOffset + MEMCPY(ADR(aInputData)+nOffset, ADR(stEnableStationData.stInput),	MIN(SIZEOF(stEnableStationData.stInput), (SIZEOF(aInputData)-nOffset)) );
		(* Number of input arguments *)
		nNoOfInputArgs := stEnableStationData.iNoOfInputArgs;
		(* Set up input argument information *)
		MEMSET(ADR(aInputArgInfo), 0, SIZEOF(aInputArgInfo));
		aInputArgInfo[1].DataType := eUAType_String;
		aInputArgInfo[1].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[1].nLenData := SIZEOF(stEnableStationData.stInput.sCellID);
		aInputArgInfo[2].DataType := eUAType_String;
		aInputArgInfo[2].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[2].nLenData := SIZEOF(stEnableStationData.stInput.sID);
		aInputArgInfo[3].DataType := eUAType_Boolean;
		aInputArgInfo[3].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[3].nLenData := SIZEOF(stEnableStationData.stInput.bPresent);
		
		(* Method outputs *)
		(* Clear output data area *)
		(* Number of output arguments *)
		nNoOfOutputArgs := stEnableStationData.iNoOfOutputArgs;
		(* Set up output argument information *)
		MEMSET(ADR(aOutputArgInfo), 0, SIZEOF(aOutputArgInfo));
		aOutputArgInfo[1].DataType := eUAType_Uint16;
		aOutputArgInfo[1].ValueRank := -1;
		aOutputArgInfo[1].nLenData := SIZEOF(stEnableStationData.stOutput.eStatus);
		aOutputArgInfo[2].DataType := eUAType_String;
		aOutputArgInfo[2].ValueRank := -1;
		aOutputArgInfo[2].nLenData := SIZEOF(stEnableStationData.stOutput.sMessage);
		(* Set up output  *)
		MEMSET(ADR(stEnableStationData.stOutput), 0, SIZEOF(stEnableStationData.stOutput));
		stEnableStationData.stOutput.nNumberOfOutputArguments := nNoOfOutputArgs;
		stEnableStationData.stOutput.stOutputArgInfo[1] := aOutputArgInfo[1];
		stEnableStationData.stOutput.stOutputArgInfo[2] := aOutputArgInfo[2];
	
		(* Execute FB *)
		fbCallMethod.nNumberOfInputArguments := nNoOfInputArgs;
		fbCallMethod.pInputArgInfo := ADR(aInputArgInfo);
		fbCallMethod.cbInputArgInfo := (SIZEOF(aInputArgInfo[1])*nNoOfInputArgs);
		fbCallMethod.pInputArgData := ADR(aInputData);
		fbCallMethod.cbInputArgData := nOffset;
		fbCallMethod.nNumberOfOutputArguments := nNoOfOutputArgs; 
		fbCallMethod.pOutputArgInfo := ADR(aOutputArgInfo); 
		fbCallMethod.cbOutputArgInfo := (SIZEOF(aOutputArgInfo[1]) * nNoOfOutputArgs); 
		fbCallMethod.pOutputArgInfoAndData := ADR(stEnableStationData.stOutput);
		fbCallMethod.cbOutputArgInfoAndData := SIZEOF(stEnableStationData.stOutput);
		
		stEnableStationData.iStatus := 1;
		bCallMethod := TRUE;
		
	ELSIF (stEnableStationData.iStatus = 1) THEN
		// Method call Completed...
		IF (eStateMethod = E_TrackClientState.Connected) THEN
			// Method call OK
			IF (stEnableStationData.stOutput.eStatus = E_MMServerStatus.eMMServerStatus_Success) THEN
				// Method returned OK
				stEnableStationData.iStatus := 2;
			ELSE
				// Method returned with error
				stEnableStationData.iStatus := 3;
				stEnableStationData.stOutput.sMessage;
			END_IF
		ELSIF (eStateMethod = E_TrackClientState.Error) THEN
			// Method call failed
			stEnableStationData.iStatus := 3;
		END_IF
		
	END_IF
END_IF

M_CallEnableStation := stEnableStationData.iStatus;	
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_CallGetCellIndex" Id="{a6243e62-ba37-4885-95a6-6c7f3c673478}">
      <Declaration><![CDATA[METHOD PROTECTED M_CallGetCellIndex : INT
VAR_INPUT
	sCellID				: STRING(30);
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF (stGetCellIndexData.iStatus = 2) OR (stGetCellIndexData.iStatus = 3) THEN
	stGetCellIndexData.iStatus := 0;
END_IF

IF (bConnectedMethod AND NOT bBusyMethod) THEN
	IF (stGetCellIndexData.iStatus = 0) THEN
	(* Setup method calling parameters *)
		(* Method identifier *)
		sObjectIDentifier := stGetCellIndexData.sObjectID;
		sMethodIdentifier := stGetCellIndexData.sMethodID;
	
		(* Method Inputs *)
		stGetCellIndexData.stInput.sCellID := sCellID;
		(* Fill input data area with method arguments *)
		MEMSET(ADR(aInputData), 0 ,SIZEOF(aInputData));
		nOffset := 0;
		nOffset := nOffset + MEMCPY(ADR(aInputData)+nOffset, ADR(stGetCellIndexData.stInput),	MIN(SIZEOF(stGetCellIndexData.stInput), (SIZEOF(aInputData)-nOffset)) );
		(* Number of input arguments *)
		nNoOfInputArgs := stGetCellIndexData.iNoOfInputArgs;
		(* Set up input argument information *)
		MEMSET(ADR(aInputArgInfo), 0, SIZEOF(aInputArgInfo));
		aInputArgInfo[1].DataType := eUAType_String;
		aInputArgInfo[1].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[1].nLenData := SIZEOF(stGetCellIndexData.stInput.sCellID);
		
		(* Method outputs *)
		(* Clear output data area *)
		(* Number of output arguments *)
		nNoOfOutputArgs := stGetCellIndexData.iNoOfOutputArgs;
		(* Set up output argument information *)
		MEMSET(ADR(aOutputArgInfo), 0, SIZEOF(aOutputArgInfo));
		aOutputArgInfo[1].DataType := eUAType_Uint16;
		aOutputArgInfo[1].ValueRank := -1;
		aOutputArgInfo[1].nLenData := SIZEOF(stGetCellIndexData.stOutput.nCellIndex);
		aOutputArgInfo[2].DataType := eUAType_Uint16;
		aOutputArgInfo[2].ValueRank := -1;
		aOutputArgInfo[2].nLenData := SIZEOF(stGetCellIndexData.stOutput.eStatus);
		aOutputArgInfo[3].DataType := eUAType_String;
		aOutputArgInfo[3].ValueRank := -1;
		aOutputArgInfo[3].nLenData := SIZEOF(stGetCellIndexData.stOutput.sMessage);
		(* Set up output  *)
		MEMSET(ADR(stGetCellIndexData.stOutput), 0, SIZEOF(stGetCellIndexData.stOutput));
		stGetCellIndexData.stOutput.nNumberOfOutputArguments := nNoOfOutputArgs;
		stGetCellIndexData.stOutput.stOutputArgInfo[1] := aOutputArgInfo[1];
		stGetCellIndexData.stOutput.stOutputArgInfo[2] := aOutputArgInfo[2];
		stGetCellIndexData.stOutput.stOutputArgInfo[3] := aOutputArgInfo[3];
	
		(* Execute FB *)
		fbCallMethod.nNumberOfInputArguments := nNoOfInputArgs;
		fbCallMethod.pInputArgInfo := ADR(aInputArgInfo);
		fbCallMethod.cbInputArgInfo := (SIZEOF(aInputArgInfo[1])*nNoOfInputArgs);
		fbCallMethod.pInputArgData := ADR(aInputData);
		fbCallMethod.cbInputArgData := nOffset;
		fbCallMethod.nNumberOfOutputArguments := nNoOfOutputArgs; 
		fbCallMethod.pOutputArgInfo := ADR(aOutputArgInfo); 
		fbCallMethod.cbOutputArgInfo := (SIZEOF(aOutputArgInfo[1]) * nNoOfOutputArgs); 
		fbCallMethod.pOutputArgInfoAndData := ADR(stGetCellIndexData.stOutput);
		fbCallMethod.cbOutputArgInfoAndData := SIZEOF(stGetCellIndexData.stOutput);
		
		stGetCellIndexData.iStatus := 1;
		bCallMethod := TRUE;
		
	ELSIF (stGetCellIndexData.iStatus = 1) THEN
		// Method call Completed...
		IF (eStateMethod = E_TrackClientState.Connected) THEN
			// Method call OK
			IF (stGetCellIndexData.stOutput.eStatus = E_MMServerStatus.eMMServerStatus_Success) THEN
				// Method returned OK
				stGetCellIndexData.iStatus := 2;
			ELSE
				// Method returned with error
				stGetCellIndexData.iStatus := 3;
				stGetCellIndexData.stOutput.sMessage;
			END_IF
		ELSIF (eStateMethod = E_TrackClientState.Error) THEN
			// Method call failed
			stGetCellIndexData.iStatus := 3;
		END_IF
		
	END_IF
END_IF

M_CallGetCellIndex := stGetCellIndexData.iStatus;	
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_CallGetPathSegmentVehicleCount" Id="{d2d1be27-cbbe-4456-ac72-3b33b1e14a78}">
      <Declaration><![CDATA[METHOD PROTECTED M_CallGetPathSegmentVehicleCount : INT
VAR_INPUT
	iSegmentNo		: UINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF (stGetPathSegmentVehicleCountData.iStatus = 2) OR (stGetPathSegmentVehicleCountData.iStatus = 3) THEN
	stGetPathSegmentVehicleCountData.iStatus := 0;
END_IF

IF (bConnectedMethod AND NOT bBusyMethod) THEN
	IF (stGetPathSegmentVehicleCountData.iStatus = 0) THEN
	(* Setup method calling parameters *)
		(* Method identifier *)
		sObjectIDentifier := stGetPathSegmentVehicleCountData.sObjectID;
		sMethodIdentifier := stGetPathSegmentVehicleCountData.sMethodID;
	
		(* Method Inputs *)
		stGetPathSegmentVehicleCountData.stInput.sCellID := sCellID;
		stGetPathSegmentVehicleCountData.stInput.sSegmentID := CONCAT(sCellID, '_PS');
		stGetPathSegmentVehicleCountData.stInput.sSegmentID := CONCAT(stGetPathSegmentVehicleCountData.stInput.sSegmentID, UINT_TO_STRING(iSegmentNo));			
		(* Fill input data area with method arguments *)
		MEMSET(ADR(aInputData), 0 ,SIZEOF(aInputData));
		nOffset := 0;
		nOffset := nOffset + MEMCPY(ADR(aInputData)+nOffset, ADR(stGetPathSegmentVehicleCountData.stInput),	MIN(SIZEOF(stGetPathSegmentVehicleCountData.stInput), (SIZEOF(aInputData)-nOffset)) );
		(* Number of input arguments *)
		nNoOfInputArgs := stGetPathSegmentVehicleCountData.iNoOfInputArgs;
		(* Set up input argument information *)
		MEMSET(ADR(aInputArgInfo), 0, SIZEOF(aInputArgInfo));
		aInputArgInfo[1].DataType := eUAType_String;
		aInputArgInfo[1].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[1].nLenData := SIZEOF(stGetPathSegmentVehicleCountData.stInput.sCellID);
		aInputArgInfo[2].DataType := eUAType_String;
		aInputArgInfo[2].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[2].nLenData := SIZEOF(stGetPathSegmentVehicleCountData.stInput.sSegmentID);
		
		(* Method outputs *)
		(* Clear output data area *)
		(* Number of output arguments *)
		nNoOfOutputArgs := stGetPathSegmentVehicleCountData.iNoOfOutputArgs;
		(* Set up output argument information *)
		MEMSET(ADR(aOutputArgInfo), 0, SIZEOF(aOutputArgInfo));
		aOutputArgInfo[1].DataType := eUAType_Uint16;
		aOutputArgInfo[1].ValueRank := -1;
		aOutputArgInfo[1].nLenData := SIZEOF(stGetPathSegmentVehicleCountData.stOutput.iVehicleCount);
		aOutputArgInfo[2].DataType := eUAType_Uint16;
		aOutputArgInfo[2].ValueRank := -1;
		aOutputArgInfo[2].nLenData := SIZEOF(stGetPathSegmentVehicleCountData.stOutput.eStatus);
		aOutputArgInfo[3].DataType := eUAType_String;
		aOutputArgInfo[3].ValueRank := -1;
		aOutputArgInfo[3].nLenData := SIZEOF(stGetPathSegmentVehicleCountData.stOutput.sMessage);
		(* Set up output  *)
		MEMSET(ADR(stGetPathSegmentVehicleCountData.stOutput), 0, SIZEOF(stGetPathSegmentVehicleCountData.stOutput));
		stGetPathSegmentVehicleCountData.stOutput.nNumberOfOutputArguments := nNoOfOutputArgs;
		stGetPathSegmentVehicleCountData.stOutput.stOutputArgInfo[1] := aOutputArgInfo[1];
		stGetPathSegmentVehicleCountData.stOutput.stOutputArgInfo[2] := aOutputArgInfo[2];
		stGetPathSegmentVehicleCountData.stOutput.stOutputArgInfo[3] := aOutputArgInfo[3];
	
		(* Execute FB *)
		fbCallMethod.nNumberOfInputArguments := nNoOfInputArgs;
		fbCallMethod.pInputArgInfo := ADR(aInputArgInfo);
		fbCallMethod.cbInputArgInfo := (SIZEOF(aInputArgInfo[1])*nNoOfInputArgs);
		fbCallMethod.pInputArgData := ADR(aInputData);
		fbCallMethod.cbInputArgData := nOffset;
		fbCallMethod.nNumberOfOutputArguments := nNoOfOutputArgs; 
		fbCallMethod.pOutputArgInfo := ADR(aOutputArgInfo); 
		fbCallMethod.cbOutputArgInfo := (SIZEOF(aOutputArgInfo[1]) * nNoOfOutputArgs);
		fbCallMethod.pOutputArgInfoAndData := ADR(stGetPathSegmentVehicleCountData.stOutput);
		fbCallMethod.cbOutputArgInfoAndData := SIZEOF(stGetPathSegmentVehicleCountData.stOutput);
		
		stGetPathSegmentVehicleCountData.iStatus := 1;
		bCallMethod := TRUE;
		
	ELSIF (stGetPathSegmentVehicleCountData.iStatus = 1) THEN
		// Method call Completed...
		IF (eStateMethod = E_TrackClientState.Connected) THEN
			// Method call OK
			IF (stGetPathSegmentVehicleCountData.stOutput.eStatus = E_MMServerStatus.eMMServerStatus_Success) THEN
				// Method returned OK
				stGetPathSegmentVehicleCountData.iStatus := 2;
			ELSE
				// Method returned with error
				stGetPathSegmentVehicleCountData.iStatus := 3;
				stGetPathSegmentVehicleCountData.stOutput.sMessage;
			END_IF
		ELSIF (eStateMethod = E_TrackClientState.Error) THEN
			// Method call failed
			stGetPathSegmentVehicleCountData.iStatus := 3;
		END_IF
		
	END_IF
END_IF

M_CallGetPathSegmentVehicleCount := stGetPathSegmentVehicleCountData.iStatus;	
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_CallMoveVehicleStatus" Id="{14afa176-ece5-4d45-9676-2b8f4c0291b6}">
      <Declaration><![CDATA[METHOD PROTECTED M_CallMoveVehicleStatus : INT
VAR_INPUT
	iCommandID		: UINT;
END_VAR
VAR_OUTPUT
	eMoveStatus		: E_VehicleMoveState := E_VehicleMoveState.Unknown;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF (stMoveVehicleStatusData.iStatus = 2) OR (stMoveVehicleStatusData.iStatus = 3) THEN
	stMoveVehicleStatusData.iStatus := 0;
END_IF

IF (bConnectedMethod AND NOT bBusyMethod) THEN
	IF (stMoveVehicleStatusData.iStatus = 0) THEN
	(* Setup method calling parameters *)
		(* Method identifier *)
		sObjectIDentifier := stMoveVehicleStatusData.sObjectID;
		sMethodIdentifier := stMoveVehicleStatusData.sMethodID;
	
		(* Method Inputs *)
		stMoveVehicleStatusData.stInput.iCommandID := iCommandID;
		(* Fill input data area with method arguments *)
		MEMSET(ADR(aInputData), 0 ,SIZEOF(aInputData));
		nOffset := 0;
		nOffset := nOffset + MEMCPY(ADR(aInputData)+nOffset, ADR(stMoveVehicleStatusData.stInput),	MIN(SIZEOF(stMoveVehicleStatusData.stInput), (SIZEOF(aInputData)-nOffset)) );
		(* Number of input arguments *)
		nNoOfInputArgs := stMoveVehicleStatusData.iNoOfInputArgs;
		(* Set up input argument information *)
		MEMSET(ADR(aInputArgInfo), 0, SIZEOF(aInputArgInfo));
		aInputArgInfo[1].DataType := eUAType_UInt16;
		aInputArgInfo[1].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[1].nLenData := SIZEOF(stMoveVehicleStatusData.stInput.iCommandID);
		
		(* Method outputs *)
		(* Clear output data area *)
		(* Number of output arguments *)
		nNoOfOutputArgs := stMoveVehicleStatusData.iNoOfOutputArgs;
		(* Set up output argument information *)
		MEMSET(ADR(aOutputArgInfo), 0, SIZEOF(aOutputArgInfo));
		aOutputArgInfo[1].DataType := eUAType_Uint16;
		aOutputArgInfo[1].ValueRank := -1;
		aOutputArgInfo[1].nLenData := SIZEOF(stMoveVehicleStatusData.stOutput.eStatus);
		aOutputArgInfo[2].DataType := eUAType_String;
		aOutputArgInfo[2].ValueRank := -1;
		aOutputArgInfo[2].nLenData := SIZEOF(stMoveVehicleStatusData.stOutput.sMessage);
		aOutputArgInfo[3].DataType := eUAType_UInt16;
		aOutputArgInfo[3].ValueRank := -1;
		aOutputArgInfo[3].nLenData := SIZEOF(stMoveVehicleStatusData.stOutput.eMoveStatus);
		(* Set up output  *)
		MEMSET(ADR(stMoveVehicleStatusData.stOutput), 0, SIZEOF(stMoveVehicleStatusData.stOutput));
		stMoveVehicleStatusData.stOutput.nNumberOfOutputArguments := nNoOfOutputArgs;
		stMoveVehicleStatusData.stOutput.stOutputArgInfo[1] := aOutputArgInfo[1];
		stMoveVehicleStatusData.stOutput.stOutputArgInfo[2] := aOutputArgInfo[2];
		stMoveVehicleStatusData.stOutput.stOutputArgInfo[3] := aOutputArgInfo[3];
	
		(* Execute FB *)
		fbCallMethod.nNumberOfInputArguments := nNoOfInputArgs;
		fbCallMethod.pInputArgInfo := ADR(aInputArgInfo);
		fbCallMethod.cbInputArgInfo := (SIZEOF(aInputArgInfo[1])*nNoOfInputArgs);
		fbCallMethod.pInputArgData := ADR(aInputData);
		fbCallMethod.cbInputArgData := nOffset;
		fbCallMethod.nNumberOfOutputArguments := nNoOfOutputArgs; 
		fbCallMethod.pOutputArgInfo := ADR(aOutputArgInfo); 
		fbCallMethod.cbOutputArgInfo := (SIZEOF(aOutputArgInfo[1]) * nNoOfOutputArgs); 
		fbCallMethod.pOutputArgInfoAndData := ADR(stMoveVehicleStatusData.stOutput);
		fbCallMethod.cbOutputArgInfoAndData := SIZEOF(stMoveVehicleStatusData.stOutput);
		
		stMoveVehicleStatusData.iStatus := 1;
		bCallMethod := TRUE;
		
	ELSIF (stMoveVehicleStatusData.iStatus = 1) THEN
		// Method call Completed...
		IF (iCommandID = stMoveVehicleStatusData.stInput.iCommandID) THEN
			// Correct Command ID!
			IF (eStateMethod = E_TrackClientState.Connected) THEN
				// Method call OK
				IF (stMoveVehicleStatusData.stOutput.eStatus = E_MMServerStatus.eMMServerStatus_Success) THEN
					// Method returned OK
					stMoveVehicleStatusData.iStatus := 2;
					eMoveStatus := stMoveVehicleStatusData.stOutput.eMoveStatus;
					
				ELSE
					// Method returned with error
					stMoveVehicleStatusData.iStatus := 3;
					stMoveVehicleStatusData.stOutput.sMessage;
					stMoveVehicleStatusData.stOutput.eStatus;
	
				END_IF
	
			ELSIF (eStateMethod = E_TrackClientState.Error) THEN
				// Method call failed
				stMoveVehicleStatusData.iStatus := 3;
			END_IF

		ELSE
			// Do not allow to return 2 (or 3) if the CommandID is not the same as the movment was started with!
			F_LogLine('TC_VS: Wrong Command ID (%d)', iCommandID);
			
		END_IF
		
	END_IF

END_IF

M_CallMoveVehicleStatus := stMoveVehicleStatusData.iStatus;	
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_CallMoveVehicleToBuffer" Id="{d022b077-1f98-41a3-8d09-690839470c28}">
      <Declaration><![CDATA[METHOD PROTECTED M_CallMoveVehicleToBuffer : INT
VAR_INPUT
	eInputType			: E_MMVehicleInputType;
	sInput				: STRING;
	sStationID			: STRING;
	eBufferType			: E_MMStationBuffer;
	nBufferIndex		: USINT;
	eDirection			: E_MMDirection := E_MMDirection.eMMDirection_Forward;	// Default forward direction
	fVelocity			: REAL;
	fAcceleration		: REAL;
END_VAR
VAR
	i					: UINT;	
	nPostBufferSize: INT;
END_VAR
VAR_OUTPUT
	iCmdID				: UINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF (stMoveToBufferData.iStatus = 2) OR (stMoveToBufferData.iStatus = 3) THEN
	stMoveToBufferData.iStatus := 0;
END_IF

IF (bConnectedMethod AND NOT bBusyMethod) THEN
	IF (stMoveToBufferData.iStatus = 0) THEN
	(* Setup method calling parameters *)
		(* Method identifier *)
		sObjectIDentifier := stMoveToBufferData.sObjectID;
		sMethodIdentifier := stMoveToBufferData.sMethodID;
	
		(* Method Inputs *)
		stMoveToBufferData.stInput.eInputType := eInputType;
		stMoveToBufferData.stInput.sInput := sInput;
		stMoveToBufferData.stInput.sStationID := sStationID;
		stMoveToBufferData.stInput.eStationBufferType := eBufferType;
		stMoveToBufferData.stInput.nIndex := nBufferIndex;
		stMoveToBufferData.stInput.eDirection := eDirection;
		stMoveToBufferData.stInput.nFollowID := 0;
		stMoveToBufferData.stInput.fVelocity := fVelocity;
		stMoveToBufferData.stInput.fAcceleration := fAcceleration;
		
		(* Fill input data area with method arguments *)
		MEMSET(ADR(aInputData), 0 ,SIZEOF(aInputData));
		nOffset := 0;
		nOffset := nOffset + MEMCPY(ADR(aInputData)+nOffset, ADR(stMoveToBufferData.stInput),	MIN(SIZEOF(stMoveToBufferData.stInput), (SIZEOF(aInputData)-nOffset)) );
		(* Number of input arguments *)
		nNoOfInputArgs := stMoveToBufferData.iNoOfInputArgs;
		(* Set up input argument information *)
		MEMSET(ADR(aInputArgInfo), 0, SIZEOF(aInputArgInfo));
		aInputArgInfo[1].DataType := eUAType_UInt16;
		aInputArgInfo[1].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[1].nLenData := SIZEOF(stMoveToBufferData.stInput.eInputType);
		aInputArgInfo[2].DataType := eUAType_String;
		aInputArgInfo[2].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[2].nLenData := SIZEOF(stMoveToBufferData.stInput.sInput);
		aInputArgInfo[3].DataType := eUAType_String;
		aInputArgInfo[3].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[3].nLenData := SIZEOF(stMoveToBufferData.stInput.sStationID);
		aInputArgInfo[4].DataType := eUAType_UInt16;
		aInputArgInfo[4].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[4].nLenData := SIZEOF(stMoveToBufferData.stInput.eStationBufferType);
		aInputArgInfo[5].DataType := eUAType_Byte;
		aInputArgInfo[5].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[5].nLenData := SIZEOF(stMoveToBufferData.stInput.nIndex);
		aInputArgInfo[6].DataType := eUAType_Byte;
		aInputArgInfo[6].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[6].nLenData := SIZEOF(stMoveToBufferData.stInput.eDirection);
		aInputArgInfo[7].DataType := eUAType_UInt16;
		aInputArgInfo[7].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[7].nLenData := SIZEOF(stMoveToBufferData.stInput.nFollowID);
		aInputArgInfo[8].DataType := eUAType_Float;
		aInputArgInfo[8].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[8].nLenData := SIZEOF(stMoveToBufferData.stInput.fVelocity);
		aInputArgInfo[9].DataType := eUAType_Float;
		aInputArgInfo[9].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[9].nLenData := SIZEOF(stMoveToBufferData.stInput.fAcceleration);
		
		(* Method outputs *)
		(* Clear output data area *)
		(* Number of output arguments *)
		nNoOfOutputArgs := stMoveToBufferData.iNoOfOutputArgs;
		(* Set up output argument information *)
		MEMSET(ADR(aOutputArgInfo), 0, SIZEOF(aOutputArgInfo));
		aOutputArgInfo[1].DataType := eUAType_Uint16;
		aOutputArgInfo[1].ValueRank := -1;
		aOutputArgInfo[1].nLenData := SIZEOF(stMoveToBufferData.stOutput.eStatus);
		aOutputArgInfo[2].DataType := eUAType_String;
		aOutputArgInfo[2].ValueRank := -1;
		aOutputArgInfo[2].nLenData := SIZEOF(stMoveToBufferData.stOutput.sMessage);
		aOutputArgInfo[3].DataType := eUAType_UInt16;
		aOutputArgInfo[3].ValueRank := -1;
		aOutputArgInfo[3].nLenData := SIZEOF(stMoveToBufferData.stOutput.iCommandID);		
		(* Set up output  *)
		MEMSET(ADR(stMoveToBufferData.stOutput), 0, SIZEOF(stMoveToBufferData.stOutput));
		stMoveToBufferData.stOutput.nNumberOfOutputArguments := nNoOfOutputArgs;
		stMoveToBufferData.stOutput.stOutputArgInfo[1] := aOutputArgInfo[1];
		stMoveToBufferData.stOutput.stOutputArgInfo[2] := aOutputArgInfo[2];
		stMoveToBufferData.stOutput.stOutputArgInfo[3] := aOutputArgInfo[3];
	
		(* Execute FB *)
		fbCallMethod.nNumberOfInputArguments := nNoOfInputArgs;
		fbCallMethod.pInputArgInfo := ADR(aInputArgInfo);
		fbCallMethod.cbInputArgInfo := (SIZEOF(aInputArgInfo[1])*nNoOfInputArgs);
		fbCallMethod.pInputArgData := ADR(aInputData);
		fbCallMethod.cbInputArgData := nOffset;
		fbCallMethod.nNumberOfOutputArguments := nNoOfOutputArgs; 
		fbCallMethod.pOutputArgInfo := ADR(aOutputArgInfo); 
		fbCallMethod.cbOutputArgInfo := (SIZEOF(aOutputArgInfo[1]) * nNoOfOutputArgs); 
		fbCallMethod.pOutputArgInfoAndData := ADR(stMoveToBufferData.stOutput);
		fbCallMethod.cbOutputArgInfoAndData := SIZEOF(stMoveToBufferData.stOutput);
		
		stMoveToBufferData.iStatus := 1;
		bCallMethod := TRUE;
		
	ELSIF ( (stMoveToBufferData.iStatus = 1) AND (stMoveToBufferData.stInput.sInput = sInput) ) THEN
		// Method call Completed...
		IF (eStateMethod = E_TrackClientState.Connected) THEN
			// Method call OK
			IF (stMoveToBufferData.stOutput.eStatus = E_MMServerStatus.eMMServerStatus_Success) THEN
				// Method returned OK
				stMoveToBufferData.iStatus := 2;
				iCmdID := stMoveToBufferData.stOutput.iCommandID;
			ELSE
				// Method returned with error
				stMoveToBufferData.iStatus := 3;
				stMoveToBufferData.stOutput.sMessage;
				iCmdID := 0;
			END_IF
		ELSIF (eStateMethod = E_TrackClientState.Error) THEN
			// Method call failed
			stMoveToBufferData.iStatus := 3;
		END_IF
		
	END_IF
ELSE
	M_CallMoveVehicleToBuffer := -1;
	RETURN;
END_IF

M_CallMoveVehicleToBuffer := stMoveToBufferData.iStatus;	
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_CallMoveVehicleToDecisionPoint" Id="{229ffaa2-54ab-46e5-8cee-d6eabeed20d3}">
      <Declaration><![CDATA[METHOD M_CallMoveVehicleToDecisionPoint : INT
VAR_INPUT
	eInputType			: E_MMVehicleInputType;
	sInput				: STRING;
	sStationID			: STRING;
	eDirection			: E_MMDirection := E_MMDirection.eMMDirection_Forward;	// Default forward direction
	fVelocity			: REAL;
	fAcceleration		: REAL;
END_VAR
VAR
	i					: UINT;	
END_VAR
VAR_OUTPUT
	iCmdID				: UINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF (stMoveToDecisionPointData.iStatus = 2) OR (stMoveToDecisionPointData.iStatus = 3) THEN
	stMoveToDecisionPointData.iStatus := 0;
END_IF

IF (bConnectedMethod AND NOT bBusyMethod) THEN
	IF (stMoveToDecisionPointData.iStatus = 0) THEN
	(* Setup method calling parameters *)
		(* Method identifier *)
		sObjectIDentifier := stMoveToDecisionPointData.sObjectID;
		sMethodIdentifier := stMoveToDecisionPointData.sMethodID;
	
		(* Method Inputs *)
		stMoveToDecisionPointData.stInput.eInputType := eInputType;
		stMoveToDecisionPointData.stInput.sInput := sInput;
		stMoveToDecisionPointData.stInput.sStationID := sStationID;
		stMoveToDecisionPointData.stInput.eDirection := eDirection;
		stMoveToDecisionPointData.stInput.nFollowID := 0;
		stMoveToDecisionPointData.stInput.fVelocity := fVelocity;
		stMoveToDecisionPointData.stInput.fAcceleration := fAcceleration;
		
		(* Fill input data area with method arguments *)
		MEMSET(ADR(aInputData), 0 ,SIZEOF(aInputData));
		nOffset := 0;
		nOffset := nOffset + MEMCPY(ADR(aInputData)+nOffset, ADR(stMoveToDecisionPointData.stInput),	MIN(SIZEOF(stMoveToDecisionPointData.stInput), (SIZEOF(aInputData)-nOffset)) );
		(* Number of input arguments *)
		nNoOfInputArgs := stMoveToDecisionPointData.iNoOfInputArgs;
		(* Set up input argument information *)
		MEMSET(ADR(aInputArgInfo), 0, SIZEOF(aInputArgInfo));
		aInputArgInfo[1].DataType := eUAType_UInt16;
		aInputArgInfo[1].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[1].nLenData := SIZEOF(stMoveToDecisionPointData.stInput.eInputType);
		aInputArgInfo[2].DataType := eUAType_String;
		aInputArgInfo[2].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[2].nLenData := SIZEOF(stMoveToDecisionPointData.stInput.sInput);
		aInputArgInfo[3].DataType := eUAType_String;
		aInputArgInfo[3].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[3].nLenData := SIZEOF(stMoveToDecisionPointData.stInput.sStationID);
		aInputArgInfo[4].DataType := eUAType_Byte;
		aInputArgInfo[4].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[4].nLenData := SIZEOF(stMoveToDecisionPointData.stInput.eDirection);
		aInputArgInfo[5].DataType := eUAType_UInt16;
		aInputArgInfo[5].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[5].nLenData := SIZEOF(stMoveToDecisionPointData.stInput.nFollowID);
		aInputArgInfo[6].DataType := eUAType_Float;
		aInputArgInfo[6].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[6].nLenData := SIZEOF(stMoveToDecisionPointData.stInput.fVelocity);
		aInputArgInfo[7].DataType := eUAType_Float;
		aInputArgInfo[7].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[7].nLenData := SIZEOF(stMoveToDecisionPointData.stInput.fAcceleration);
		
		(* Method outputs *)
		(* Clear output data area *)
		(* Number of output arguments *)
		nNoOfOutputArgs := stMoveToDecisionPointData.iNoOfOutputArgs;
		(* Set up output argument information *)
		MEMSET(ADR(aOutputArgInfo), 0, SIZEOF(aOutputArgInfo));
		aOutputArgInfo[1].DataType := eUAType_Uint16;
		aOutputArgInfo[1].ValueRank := -1;
		aOutputArgInfo[1].nLenData := SIZEOF(stMoveToDecisionPointData.stOutput.eStatus);
		aOutputArgInfo[2].DataType := eUAType_String;
		aOutputArgInfo[2].ValueRank := -1;
		aOutputArgInfo[2].nLenData := SIZEOF(stMoveToDecisionPointData.stOutput.sMessage);
		aOutputArgInfo[3].DataType := eUAType_UInt16;
		aOutputArgInfo[3].ValueRank := -1;
		aOutputArgInfo[3].nLenData := SIZEOF(stMoveToDecisionPointData.stOutput.iCommandID);
		(* Set up output  *)
		MEMSET(ADR(stMoveToDecisionPointData.stOutput), 0, SIZEOF(stMoveToDecisionPointData.stOutput));
		stMoveToDecisionPointData.stOutput.nNumberOfOutputArguments := nNoOfOutputArgs;
		stMoveToDecisionPointData.stOutput.stOutputArgInfo[1] := aOutputArgInfo[1];
		stMoveToDecisionPointData.stOutput.stOutputArgInfo[2] := aOutputArgInfo[2];
		stMoveToDecisionPointData.stOutput.stOutputArgInfo[3] := aOutputArgInfo[3];
	
		(* Execute FB *)
		fbCallMethod.nNumberOfInputArguments := nNoOfInputArgs;
		fbCallMethod.pInputArgInfo := ADR(aInputArgInfo);
		fbCallMethod.cbInputArgInfo := (SIZEOF(aInputArgInfo[1])*nNoOfInputArgs);
		fbCallMethod.pInputArgData := ADR(aInputData);
		fbCallMethod.cbInputArgData := nOffset;
		fbCallMethod.nNumberOfOutputArguments := nNoOfOutputArgs; 
		fbCallMethod.pOutputArgInfo := ADR(aOutputArgInfo); 
		fbCallMethod.cbOutputArgInfo := (SIZEOF(aOutputArgInfo[1]) * nNoOfOutputArgs); 
		fbCallMethod.pOutputArgInfoAndData := ADR(stMoveToDecisionPointData.stOutput);
		fbCallMethod.cbOutputArgInfoAndData := SIZEOF(stMoveToDecisionPointData.stOutput);
		
		stMoveToDecisionPointData.iStatus := 1;
		bCallMethod := TRUE;
		
	ELSIF ( (stMoveToDecisionPointData.iStatus = 1) AND (stMoveToDecisionPointData.stInput.sInput = sInput) ) THEN // Make sure it is called from the correct place!
		// Method call Completed...
		IF (eStateMethod = E_TrackClientState.Connected) THEN
			// Method call OK
			IF (stMoveToDecisionPointData.stOutput.eStatus = E_MMServerStatus.eMMServerStatus_Success) THEN
				// Method returned OK
				stMoveToDecisionPointData.iStatus := 2;
				iCmdID := stMoveToDecisionPointData.stOutput.iCommandID;
			ELSE
				// Method returned with error
				stMoveToDecisionPointData.iStatus := 3;
				stMoveToDecisionPointData.stOutput.sMessage;
				iCmdID := 0;
			END_IF
		ELSIF (eStateMethod = E_TrackClientState.Error) THEN
			// Method call failed
			stMoveToDecisionPointData.iStatus := 3;
		END_IF

	END_IF
ELSE
	M_CallMoveVehicleToDecisionPoint := -1;
	RETURN;
END_IF

M_CallMoveVehicleToDecisionPoint := stMoveToDecisionPointData.iStatus;	
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_CallMoveVehicleToPosition" Id="{25ee421d-a63f-44f1-b077-113ad1b8812b}">
      <Declaration><![CDATA[METHOD PROTECTED M_CallMoveVehicleToPosition : INT
VAR_INPUT
	eInputType			: E_MMVehicleInputType;
	sInput				: STRING;
	nPathID				: UINT;
	fPosition			: REAL;
	eDirection			: E_MMDirection := E_MMDirection.eMMDirection_Forward;	// Default forward direction
	fVelocity			: REAL;
	fAcceleration		: REAL;
END_VAR
VAR
	i					: UINT;	
END_VAR
VAR_OUTPUT
	iCmdID				: UINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF (stMoveToPositionData.iStatus = 2) OR (stMoveToPositionData.iStatus = 3) THEN
	stMoveToPositionData.iStatus := 0;
END_IF

IF (bConnectedMethod AND NOT bBusyMethod) THEN
	IF (stMoveToPositionData.iStatus = 0) THEN
	(* Setup method calling parameters *)
		(* Method identifier *)
		sObjectIDentifier := stMoveToPositionData.sObjectID;
		sMethodIdentifier := stMoveToPositionData.sMethodID;
	
		(* Method Inputs *)
		stMoveToPositionData.stInput.eInputType := eInputType;
		stMoveToPositionData.stInput.sInput := sInput;
		stMoveToPositionData.stInput.nPathID := nPathID;
		stMoveToPositionData.stInput.fPosition := fPosition;
		stMoveToPositionData.stInput.eDirection := eDirection;
		stMoveToPositionData.stInput.nFollowID := 0;
		stMoveToPositionData.stInput.fVelocity := fVelocity;
		stMoveToPositionData.stInput.fAcceleration := fAcceleration;
		
		(* Fill input data area with method arguments *)
		MEMSET(ADR(aInputData), 0 ,SIZEOF(aInputData));
		nOffset := 0;
		nOffset := nOffset + MEMCPY(ADR(aInputData)+nOffset, ADR(stMoveToPositionData.stInput),	MIN(SIZEOF(stMoveToPositionData.stInput), (SIZEOF(aInputData)-nOffset)) );
		(* Number of input arguments *)
		nNoOfInputArgs := stMoveToPositionData.iNoOfInputArgs;
		(* Set up input argument information *)
		MEMSET(ADR(aInputArgInfo), 0, SIZEOF(aInputArgInfo));
		aInputArgInfo[1].DataType := eUAType_UInt16;
		aInputArgInfo[1].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[1].nLenData := SIZEOF(stMoveToPositionData.stInput.eInputType);
		aInputArgInfo[2].DataType := eUAType_String;
		aInputArgInfo[2].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[2].nLenData := SIZEOF(stMoveToPositionData.stInput.sInput);
		aInputArgInfo[3].DataType := eUAType_UInt16;
		aInputArgInfo[3].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[3].nLenData := SIZEOF(stMoveToPositionData.stInput.nPathID);
		aInputArgInfo[4].DataType := eUAType_Float;
		aInputArgInfo[4].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[4].nLenData := SIZEOF(stMoveToPositionData.stInput.fPosition);
		aInputArgInfo[5].DataType := eUAType_Byte;
		aInputArgInfo[5].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[5].nLenData := SIZEOF(stMoveToPositionData.stInput.eDirection);
		aInputArgInfo[6].DataType := eUAType_UInt16;
		aInputArgInfo[6].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[6].nLenData := SIZEOF(stMoveToPositionData.stInput.nFollowID);
		aInputArgInfo[7].DataType := eUAType_Float;
		aInputArgInfo[7].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[7].nLenData := SIZEOF(stMoveToPositionData.stInput.fVelocity);
		aInputArgInfo[8].DataType := eUAType_Float;
		aInputArgInfo[8].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[8].nLenData := SIZEOF(stMoveToPositionData.stInput.fAcceleration);
		
		(* Method outputs *)
		(* Clear output data area *)
		(* Number of output arguments *)
		nNoOfOutputArgs := stMoveToPositionData.iNoOfOutputArgs;
		(* Set up output argument information *)
		MEMSET(ADR(aOutputArgInfo), 0, SIZEOF(aOutputArgInfo));
		aOutputArgInfo[1].DataType := eUAType_Uint16;
		aOutputArgInfo[1].ValueRank := -1;
		aOutputArgInfo[1].nLenData := SIZEOF(stMoveToPositionData.stOutput.eStatus);
		aOutputArgInfo[2].DataType := eUAType_String;
		aOutputArgInfo[2].ValueRank := -1;
		aOutputArgInfo[2].nLenData := SIZEOF(stMoveToPositionData.stOutput.sMessage);
		aOutputArgInfo[3].DataType := eUAType_UInt16;
		aOutputArgInfo[3].ValueRank := -1;
		aOutputArgInfo[3].nLenData := SIZEOF(stMoveToPositionData.stOutput.iCommandID);
		(* Set up output  *)
		MEMSET(ADR(stMoveToPositionData.stOutput), 0, SIZEOF(stMoveToPositionData.stOutput));
		stMoveToPositionData.stOutput.nNumberOfOutputArguments := nNoOfOutputArgs;
		stMoveToPositionData.stOutput.stOutputArgInfo[1] := aOutputArgInfo[1];
		stMoveToPositionData.stOutput.stOutputArgInfo[2] := aOutputArgInfo[2];
		stMoveToPositionData.stOutput.stOutputArgInfo[3] := aOutputArgInfo[3];
	
		(* Execute FB *)
		fbCallMethod.nNumberOfInputArguments := nNoOfInputArgs;
		fbCallMethod.pInputArgInfo := ADR(aInputArgInfo);
		fbCallMethod.cbInputArgInfo := (SIZEOF(aInputArgInfo[1])*nNoOfInputArgs);
		fbCallMethod.pInputArgData := ADR(aInputData);
		fbCallMethod.cbInputArgData := nOffset;
		fbCallMethod.nNumberOfOutputArguments := nNoOfOutputArgs; 
		fbCallMethod.pOutputArgInfo := ADR(aOutputArgInfo); 
		fbCallMethod.cbOutputArgInfo := (SIZEOF(aOutputArgInfo[1]) * nNoOfOutputArgs); 
		fbCallMethod.pOutputArgInfoAndData := ADR(stMoveToPositionData.stOutput);
		fbCallMethod.cbOutputArgInfoAndData := SIZEOF(stMoveToPositionData.stOutput);
		
		stMoveToPositionData.iStatus := 1;
		bCallMethod := TRUE;
		
	ELSIF (stMoveToPositionData.iStatus = 1) THEN
		// Method call Completed...
		IF (sInput = stMoveToPositionData.stInput.sInput) THEN
			// Correct Vehicle identifier ID!
			IF (eStateMethod = E_TrackClientState.Connected) THEN
				// Method call OK
				IF (stMoveToPositionData.stOutput.eStatus = E_MMServerStatus.eMMServerStatus_Success) THEN
					// Method returned OK
					stMoveToPositionData.iStatus := 2;
					iCmdID := stMoveToPositionData.stOutput.iCommandID;
				ELSE
					// Method returned with error
					stMoveToPositionData.iStatus := 3;
					stMoveToPositionData.stOutput.sMessage;
					iCmdId := 0;
				END_IF
			ELSIF (eStateMethod = E_TrackClientState.Error) THEN
				// Method call failed
				stMoveToPositionData.iStatus := 3;
				F_LogLine('TC_MovePos: Method call failed ' , 0);
			END_IF
		
		ELSE
			// Do not allow to return 2 (or 3) if the sInput is not the same as the movment was started with!
			F_LogLine(CONCAT('TC_MovePos: Wrong input: ', sInput) , 0);
			
		END_IF
		
	END_IF
ELSE
	M_CallMoveVehicleToPosition := -1;
	RETURN;
END_IF

M_CallMoveVehicleToPosition := stMoveToPositionData.iStatus;	
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_CallMoveVehicleToScanner" Id="{200c491c-0472-4a16-a7f2-753209075ebf}">
      <Declaration><![CDATA[METHOD PROTECTED M_CallMoveVehicleToScanner : INT
VAR_INPUT
	eInputType			: E_MMVehicleInputType;
	sInput				: STRING;
	eDirection			: E_MMDirection := E_MMDirection.eMMDirection_Forward;	// Default forward direction
	fVelocity			: REAL;
	fAcceleration		: REAL;
END_VAR
VAR
	i					: UINT;	
	nPostBufferSize: INT;
END_VAR
VAR_OUTPUT
	iCmdID				: UINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF (stMoveToScannerData.iStatus = 2) OR (stMoveToScannerData.iStatus = 3) THEN
	stMoveToScannerData.iStatus := 0;
END_IF

IF (bConnectedMethod AND NOT bBusyMethod) THEN
	IF (stMoveToScannerData.iStatus = 0) THEN
	(* Setup method calling parameters *)
		(* Method identifier *)
		sObjectIDentifier := stMoveToScannerData.sObjectID;
		sMethodIdentifier := stMoveToScannerData.sMethodID;
	
		(* Method Inputs *)
		stMoveToScannerData.stInput.eInputType := eInputType;
		stMoveToScannerData.stInput.sInput := sInput;
		stMoveToScannerData.stInput.eDirection := eDirection;
		stMoveToScannerData.stInput.nFollowID := 0;
		stMoveToScannerData.stInput.fVelocity := fVelocity;
		stMoveToScannerData.stInput.fAcceleration := fAcceleration;
		
		(* Fill input data area with method arguments *)
		MEMSET(ADR(aInputData), 0 ,SIZEOF(aInputData));
		nOffset := 0;
		nOffset := nOffset + MEMCPY(ADR(aInputData)+nOffset, ADR(stMoveToScannerData.stInput),	MIN(SIZEOF(stMoveToScannerData.stInput), (SIZEOF(aInputData)-nOffset)) );
		(* Number of input arguments *)
		nNoOfInputArgs := stMoveToScannerData.iNoOfInputArgs;
		(* Set up input argument information *)
		MEMSET(ADR(aInputArgInfo), 0, SIZEOF(aInputArgInfo));
		aInputArgInfo[1].DataType := eUAType_UInt16;
		aInputArgInfo[1].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[1].nLenData := SIZEOF(stMoveToScannerData.stInput.eInputType);
		aInputArgInfo[2].DataType := eUAType_String;
		aInputArgInfo[2].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[2].nLenData := SIZEOF(stMoveToScannerData.stInput.sInput);
		aInputArgInfo[3].DataType := eUAType_Byte;
		aInputArgInfo[3].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[3].nLenData := SIZEOF(stMoveToScannerData.stInput.eDirection);
		aInputArgInfo[4].DataType := eUAType_UInt16;
		aInputArgInfo[4].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[4].nLenData := SIZEOF(stMoveToScannerData.stInput.nFollowID);
		aInputArgInfo[5].DataType := eUAType_Float;
		aInputArgInfo[5].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[5].nLenData := SIZEOF(stMoveToScannerData.stInput.fVelocity);
		aInputArgInfo[6].DataType := eUAType_Float;
		aInputArgInfo[6].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[6].nLenData := SIZEOF(stMoveToScannerData.stInput.fAcceleration);
		
		(* Method outputs *)
		(* Clear output data area *)
		(* Number of output arguments *)
		nNoOfOutputArgs := stMoveToScannerData.iNoOfOutputArgs;
		(* Set up output argument information *)
		MEMSET(ADR(aOutputArgInfo), 0, SIZEOF(aOutputArgInfo));
		aOutputArgInfo[1].DataType := eUAType_Uint16;
		aOutputArgInfo[1].ValueRank := -1;
		aOutputArgInfo[1].nLenData := SIZEOF(stMoveToScannerData.stOutput.eStatus);
		aOutputArgInfo[2].DataType := eUAType_String;
		aOutputArgInfo[2].ValueRank := -1;
		aOutputArgInfo[2].nLenData := SIZEOF(stMoveToScannerData.stOutput.sMessage);
		aOutputArgInfo[3].DataType := eUAType_UInt16;
		aOutputArgInfo[3].ValueRank := -1;
		aOutputArgInfo[3].nLenData := SIZEOF(stMoveToScannerData.stOutput.iCommandID);
		(* Set up output  *)
		MEMSET(ADR(stMoveToScannerData.stOutput), 0, SIZEOF(stMoveToScannerData.stOutput));
		stMoveToScannerData.stOutput.nNumberOfOutputArguments := nNoOfOutputArgs;
		stMoveToScannerData.stOutput.stOutputArgInfo[1] := aOutputArgInfo[1];
		stMoveToScannerData.stOutput.stOutputArgInfo[2] := aOutputArgInfo[2];
		stMoveToScannerData.stOutput.stOutputArgInfo[3] := aOutputArgInfo[3];
	
		(* Execute FB *)
		fbCallMethod.nNumberOfInputArguments := nNoOfInputArgs;
		fbCallMethod.pInputArgInfo := ADR(aInputArgInfo);
		fbCallMethod.cbInputArgInfo := (SIZEOF(aInputArgInfo[1])*nNoOfInputArgs);
		fbCallMethod.pInputArgData := ADR(aInputData);
		fbCallMethod.cbInputArgData := nOffset;
		fbCallMethod.nNumberOfOutputArguments := nNoOfOutputArgs; 
		fbCallMethod.pOutputArgInfo := ADR(aOutputArgInfo); 
		fbCallMethod.cbOutputArgInfo := (SIZEOF(aOutputArgInfo[1]) * nNoOfOutputArgs); 
		fbCallMethod.pOutputArgInfoAndData := ADR(stMoveToScannerData.stOutput);
		fbCallMethod.cbOutputArgInfoAndData := SIZEOF(stMoveToScannerData.stOutput);
		
		stMoveToScannerData.iStatus := 1;
		bCallMethod := TRUE;
		
	ELSIF (stMoveToScannerData.iStatus = 1) THEN
		// Method call Completed...
		IF (eStateMethod = E_TrackClientState.Connected) THEN
			// Method call OK
			IF (stMoveToScannerData.stOutput.eStatus = E_MMServerStatus.eMMServerStatus_Success) THEN
				// Method returned OK
				stMoveToScannerData.iStatus := 2;
				iCmdID := stMoveToScannerData.stOutput.iCommandID;
			ELSE
				// Method returned with error
				stMoveToScannerData.iStatus := 3;
				stMoveToScannerData.stOutput.sMessage;
				iCmdID := 0;
			END_IF
		ELSIF (eStateMethod = E_TrackClientState.Error) THEN
			// Method call failed
			stMoveToScannerData.iStatus := 3;
		END_IF
		
	END_IF
ELSE
	M_CallMoveVehicleToScanner := -1;
	RETURN;
END_IF

M_CallMoveVehicleToScanner := stMoveToScannerData.iStatus;	
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_CallMoveVehicleToStationIn" Id="{99b48e28-5891-493a-afd0-9ec1883273c5}">
      <Declaration><![CDATA[METHOD M_CallMoveVehicleToStationIn : INT
VAR_INPUT
	eInputType			: E_MMVehicleInputType;
	sInput				: STRING;
	sStationID			: STRING;
	eDirection			: E_MMDirection := E_MMDirection.eMMDirection_Forward;	// Default forward direction
	fVelocity			: REAL;
	fAcceleration		: REAL;
END_VAR
VAR
	i					: UINT;	
END_VAR
VAR_OUTPUT
	iCmdID				: UINT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF (stMoveToStationInData.iStatus = 2) OR (stMoveToStationInData.iStatus = 3) THEN
	stMoveToStationInData.iStatus := 0;
END_IF

IF (bConnectedMethod AND NOT bBusyMethod) THEN
	IF (stMoveToStationInData.iStatus = 0) THEN
	(* Setup method calling parameters *)
		(* Method identifier *)
		sObjectIDentifier := stMoveToStationInData.sObjectID;
		sMethodIdentifier := stMoveToStationInData.sMethodID;
	
		(* Method Inputs *)
		stMoveToStationInData.stInput.eInputType := eInputType;
		stMoveToStationInData.stInput.sInput := sInput;
		stMoveToStationInData.stInput.sStationID := sStationID;
		stMoveToStationInData.stInput.eDirection := eDirection;
		stMoveToStationInData.stInput.nFollowID := 0;
		stMoveToStationInData.stInput.fVelocity := fVelocity;
		stMoveToStationInData.stInput.fAcceleration := fAcceleration;
		
		(* Fill input data area with method arguments *)
		MEMSET(ADR(aInputData), 0 ,SIZEOF(aInputData));
		nOffset := 0;
		nOffset := nOffset + MEMCPY(ADR(aInputData)+nOffset, ADR(stMoveToStationInData.stInput),	MIN(SIZEOF(stMoveToStationInData.stInput), (SIZEOF(aInputData)-nOffset)) );
		(* Number of input arguments *)
		nNoOfInputArgs := stMoveToStationInData.iNoOfInputArgs;
		(* Set up input argument information *)
		MEMSET(ADR(aInputArgInfo), 0, SIZEOF(aInputArgInfo));
		aInputArgInfo[1].DataType := eUAType_UInt16;
		aInputArgInfo[1].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[1].nLenData := SIZEOF(stMoveToStationInData.stInput.eInputType);
		aInputArgInfo[2].DataType := eUAType_String;
		aInputArgInfo[2].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[2].nLenData := SIZEOF(stMoveToStationInData.stInput.sInput);
		aInputArgInfo[3].DataType := eUAType_String;
		aInputArgInfo[3].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[3].nLenData := SIZEOF(stMoveToStationInData.stInput.sStationID);
		aInputArgInfo[4].DataType := eUAType_Byte;
		aInputArgInfo[4].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[4].nLenData := SIZEOF(stMoveToStationInData.stInput.eDirection);
		aInputArgInfo[5].DataType := eUAType_UInt16;
		aInputArgInfo[5].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[5].nLenData := SIZEOF(stMoveToStationInData.stInput.nFollowID);
		aInputArgInfo[6].DataType := eUAType_Float;
		aInputArgInfo[6].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[6].nLenData := SIZEOF(stMoveToStationInData.stInput.fVelocity);
		aInputArgInfo[7].DataType := eUAType_Float;
		aInputArgInfo[7].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[7].nLenData := SIZEOF(stMoveToStationInData.stInput.fAcceleration);
		
		(* Method outputs *)
		(* Clear output data area *)
		(* Number of output arguments *)
		nNoOfOutputArgs := stMoveToStationInData.iNoOfOutputArgs;
		(* Set up output argument information *)
		MEMSET(ADR(aOutputArgInfo), 0, SIZEOF(aOutputArgInfo));
		aOutputArgInfo[1].DataType := eUAType_Uint16;
		aOutputArgInfo[1].ValueRank := -1;
		aOutputArgInfo[1].nLenData := SIZEOF(stMoveToStationInData.stOutput.eStatus);
		aOutputArgInfo[2].DataType := eUAType_String;
		aOutputArgInfo[2].ValueRank := -1;
		aOutputArgInfo[2].nLenData := SIZEOF(stMoveToStationInData.stOutput.sMessage);
		aOutputArgInfo[3].DataType := eUAType_UInt16;
		aOutputArgInfo[3].ValueRank := -1;
		aOutputArgInfo[3].nLenData := SIZEOF(stMoveToStationInData.stOutput.iCommandID);
		(* Set up output  *)
		MEMSET(ADR(stMoveToStationInData.stOutput), 0, SIZEOF(stMoveToStationInData.stOutput));
		stMoveToStationInData.stOutput.nNumberOfOutputArguments := nNoOfOutputArgs;
		stMoveToStationInData.stOutput.stOutputArgInfo[1] := aOutputArgInfo[1];
		stMoveToStationInData.stOutput.stOutputArgInfo[2] := aOutputArgInfo[2];
		stMoveToStationInData.stOutput.stOutputArgInfo[3] := aOutputArgInfo[3];
	
		(* Execute FB *)
		fbCallMethod.nNumberOfInputArguments := nNoOfInputArgs;
		fbCallMethod.pInputArgInfo := ADR(aInputArgInfo);
		fbCallMethod.cbInputArgInfo := (SIZEOF(aInputArgInfo[1])*nNoOfInputArgs);
		fbCallMethod.pInputArgData := ADR(aInputData);
		fbCallMethod.cbInputArgData := nOffset;
		fbCallMethod.nNumberOfOutputArguments := nNoOfOutputArgs; 
		fbCallMethod.pOutputArgInfo := ADR(aOutputArgInfo); 
		fbCallMethod.cbOutputArgInfo := (SIZEOF(aOutputArgInfo[1]) * nNoOfOutputArgs); 
		fbCallMethod.pOutputArgInfoAndData := ADR(stMoveToStationInData.stOutput);
		fbCallMethod.cbOutputArgInfoAndData := SIZEOF(stMoveToStationInData.stOutput);
		
		stMoveToStationInData.iStatus := 1;
		bCallMethod := TRUE;
		
	ELSIF ( (stMoveToStationInData.iStatus = 1) AND (stMoveToStationInData.stInput.sInput = sInput) ) THEN
		// Method call Completed...
		IF (eStateMethod = E_TrackClientState.Connected) THEN
			// Method call OK
			IF (stMoveToStationInData.stOutput.eStatus = E_MMServerStatus.eMMServerStatus_Success) THEN
				// Method returned OK
				stMoveToStationInData.iStatus := 2;
				iCmdID := stMoveToStationInData.stOutput.iCommandID;
			ELSE
				// Method returned with error
				stMoveToStationInData.iStatus := 3;
				stMoveToStationInData.stOutput.sMessage;
				iCmdID := 0;
			END_IF
		ELSIF (eStateMethod = E_TrackClientState.Error) THEN
			// Method call failed
			stMoveToStationInData.iStatus := 3;
		END_IF
		
	END_IF
ELSE
	M_CallMoveVehicleToStationIn := -1;
	RETURN;
END_IF

M_CallMoveVehicleToStationIn := stMoveToStationInData.iStatus;	
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_CallMoveVehicleToStationOut" Id="{4f44d3ad-713f-4108-8557-f96306db0c2d}">
      <Declaration><![CDATA[METHOD PROTECTED M_CallMoveVehicleToStationOut : INT
VAR_INPUT
	eInputType			: E_MMVehicleInputType;
	sInput				: STRING;
	sStationID			: STRING;
	eDirection			: E_MMDirection := E_MMDirection.eMMDirection_Forward;	// Default forward direction
	fVelocity			: REAL;
	fAcceleration		: REAL;
END_VAR
VAR
	i					: UINT;	
	nPostBufferSize: INT;
END_VAR
VAR_OUTPUT
	iCmdID				: UINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF (stMoveToStationOutData.iStatus = 2) OR (stMoveToStationOutData.iStatus = 3) THEN
	stMoveToStationOutData.iStatus := 0;
END_IF

IF (bConnectedMethod AND NOT bBusyMethod) THEN
	IF (stMoveToStationOutData.iStatus = 0) THEN
	(* Setup method calling parameters *)
		(* Method identifier *)
		sObjectIDentifier := stMoveToStationOutData.sObjectID;
		sMethodIdentifier := stMoveToStationOutData.sMethodID;
	
		(* Method Inputs *)
		stMoveToStationOutData.stInput.eInputType := eInputType;
		stMoveToStationOutData.stInput.sInput := sInput;
		stMoveToStationOutData.stInput.sStationID := sStationID;
		stMoveToStationOutData.stInput.eDirection := eDirection;
		stMoveToStationOutData.stInput.nFollowID := 0;
		stMoveToStationOutData.stInput.fVelocity := fVelocity;
		stMoveToStationOutData.stInput.fAcceleration := fAcceleration;
		
		(* Fill input data area with method arguments *)
		MEMSET(ADR(aInputData), 0 ,SIZEOF(aInputData));
		nOffset := 0;
		nOffset := nOffset + MEMCPY(ADR(aInputData)+nOffset, ADR(stMoveToStationOutData.stInput),	MIN(SIZEOF(stMoveToStationOutData.stInput), (SIZEOF(aInputData)-nOffset)) );
		(* Number of input arguments *)
		nNoOfInputArgs := stMoveToStationOutData.iNoOfInputArgs;
		(* Set up input argument information *)
		MEMSET(ADR(aInputArgInfo), 0, SIZEOF(aInputArgInfo));
		aInputArgInfo[1].DataType := eUAType_UInt16;
		aInputArgInfo[1].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[1].nLenData := SIZEOF(stMoveToStationOutData.stInput.eInputType);
		aInputArgInfo[2].DataType := eUAType_String;
		aInputArgInfo[2].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[2].nLenData := SIZEOF(stMoveToStationOutData.stInput.sInput);
		aInputArgInfo[3].DataType := eUAType_String;
		aInputArgInfo[3].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[3].nLenData := SIZEOF(stMoveToStationOutData.stInput.sStationID);
		aInputArgInfo[4].DataType := eUAType_Byte;
		aInputArgInfo[4].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[4].nLenData := SIZEOF(stMoveToStationOutData.stInput.eDirection);
		aInputArgInfo[5].DataType := eUAType_UInt16;
		aInputArgInfo[5].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[5].nLenData := SIZEOF(stMoveToStationOutData.stInput.nFollowID);
		aInputArgInfo[6].DataType := eUAType_Float;
		aInputArgInfo[6].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[6].nLenData := SIZEOF(stMoveToStationOutData.stInput.fVelocity);
		aInputArgInfo[7].DataType := eUAType_Float;
		aInputArgInfo[7].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[7].nLenData := SIZEOF(stMoveToStationOutData.stInput.fAcceleration);
		
		(* Method outputs *)
		(* Clear output data area *)
		(* Number of output arguments *)
		nNoOfOutputArgs := stMoveToStationOutData.iNoOfOutputArgs;
		(* Set up output argument information *)
		MEMSET(ADR(aOutputArgInfo), 0, SIZEOF(aOutputArgInfo));
		aOutputArgInfo[1].DataType := eUAType_Uint16;
		aOutputArgInfo[1].ValueRank := -1;
		aOutputArgInfo[1].nLenData := SIZEOF(stMoveToStationOutData.stOutput.eStatus);
		aOutputArgInfo[2].DataType := eUAType_String;
		aOutputArgInfo[2].ValueRank := -1;
		aOutputArgInfo[2].nLenData := SIZEOF(stMoveToStationOutData.stOutput.sMessage);
		aOutputArgInfo[3].DataType := eUAType_UInt16;
		aOutputArgInfo[3].ValueRank := -1;
		aOutputArgInfo[3].nLenData := SIZEOF(stMoveToStationOutData.stOutput.iCommandID);
		(* Set up output  *)
		MEMSET(ADR(stMoveToStationOutData.stOutput), 0, SIZEOF(stMoveToStationOutData.stOutput));
		stMoveToStationOutData.stOutput.nNumberOfOutputArguments := nNoOfOutputArgs;
		stMoveToStationOutData.stOutput.stOutputArgInfo[1] := aOutputArgInfo[1];
		stMoveToStationOutData.stOutput.stOutputArgInfo[2] := aOutputArgInfo[2];
		stMoveToStationOutData.stOutput.stOutputArgInfo[3] := aOutputArgInfo[3];
	
		(* Execute FB *)
		fbCallMethod.nNumberOfInputArguments := nNoOfInputArgs;
		fbCallMethod.pInputArgInfo := ADR(aInputArgInfo);
		fbCallMethod.cbInputArgInfo := (SIZEOF(aInputArgInfo[1])*nNoOfInputArgs);
		fbCallMethod.pInputArgData := ADR(aInputData);
		fbCallMethod.cbInputArgData := nOffset;
		fbCallMethod.nNumberOfOutputArguments := nNoOfOutputArgs; 
		fbCallMethod.pOutputArgInfo := ADR(aOutputArgInfo); 
		fbCallMethod.cbOutputArgInfo := (SIZEOF(aOutputArgInfo[1]) * nNoOfOutputArgs); 
		fbCallMethod.pOutputArgInfoAndData := ADR(stMoveToStationOutData.stOutput);
		fbCallMethod.cbOutputArgInfoAndData := SIZEOF(stMoveToStationOutData.stOutput);
		
		stMoveToStationOutData.iStatus := 1;
		bCallMethod := TRUE;
		
	ELSIF ( (stMoveToStationOutData.iStatus = 1) AND (stMoveToStationOutData.stInput.sInput = sInput) ) THEN
		// Method call Completed...
		IF (eStateMethod = E_TrackClientState.Connected) THEN
			// Method call OK
			IF (stMoveToStationOutData.stOutput.eStatus = E_MMServerStatus.eMMServerStatus_Success) THEN
				// Method returned OK
				stMoveToStationOutData.iStatus := 2;
				iCmdID := stMoveToStationOutData.stOutput.iCommandID;
			ELSE
				// Method returned with error
				stMoveToStationOutData.iStatus := 3;
				stMoveToStationOutData.stOutput.sMessage;
				iCmdID := 0;
			END_IF
		ELSIF (eStateMethod = E_TrackClientState.Error) THEN
			// Method call failed
			stMoveToStationOutData.iStatus := 3;
		END_IF
		
	END_IF
ELSE
	M_CallMoveVehicleToStationOut := -1;
	RETURN;
END_IF

M_CallMoveVehicleToStationOut := stMoveToStationOutData.iStatus;	
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_CallRemovePath" Id="{92a6b858-3c08-4dea-ae3b-f5ef1c1f7bcb}">
      <Declaration><![CDATA[METHOD PROTECTED M_CallRemovePath : INT
VAR_INPUT
	nPathNo			: UINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF (stRemovePathData.iStatus = 2) OR (stRemovePathData.iStatus = 3) THEN
	stRemovePathData.iStatus := 0;
END_IF

IF (bConnectedMethod AND NOT bBusyMethod) THEN
	IF (stRemovePathData.iStatus = 0) THEN
	(* Setup method calling parameters *)
		(* Method identifier *)
		sObjectIDentifier := stRemovePathData.sObjectID;
		sMethodIdentifier := stRemovePathData.sMethodID;
	
		(* Method Inputs *)
		stRemovePathData.stInput.sCellID := sCellID;
		stRemovePathData.stInput.iPath := nPathNo;
		(* Fill input data area with method arguments *)
		MEMSET(ADR(aInputData), 0 ,SIZEOF(aInputData));
		nOffset := 0;
		nOffset := nOffset + MEMCPY(ADR(aInputData)+nOffset, ADR(stRemovePathData.stInput),	MIN(SIZEOF(stRemovePathData.stInput), (SIZEOF(aInputData)-nOffset)) );
		(* Number of input arguments *)
		nNoOfInputArgs := stRemovePathData.iNoOfInputArgs;
		(* Set up input argument information *)
		MEMSET(ADR(aInputArgInfo), 0, SIZEOF(aInputArgInfo));
		aInputArgInfo[1].DataType := eUAType_String;
		aInputArgInfo[1].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[1].nLenData := SIZEOF(stRemovePathData.stInput.sCellID);
		aInputArgInfo[2].DataType := eUAType_UInt16;
		aInputArgInfo[2].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[2].nLenData := SIZEOF(stRemovePathData.stInput.iPath);
		
		(* Method outputs *)
		(* Clear output data area *)
		(* Number of output arguments *)
		nNoOfOutputArgs := stRemovePathData.iNoOfOutputArgs;
		(* Set up output argument information *)
		MEMSET(ADR(aOutputArgInfo), 0, SIZEOF(aOutputArgInfo));
		aOutputArgInfo[1].DataType := eUAType_Uint16;
		aOutputArgInfo[1].ValueRank := -1;
		aOutputArgInfo[1].nLenData := SIZEOF(stRemovePathData.stOutput.eStatus);
		aOutputArgInfo[2].DataType := eUAType_String;
		aOutputArgInfo[2].ValueRank := -1;
		aOutputArgInfo[2].nLenData := SIZEOF(stRemovePathData.stOutput.sMessage);
		(* Set up output  *)
		MEMSET(ADR(stRemovePathData.stOutput), 0, SIZEOF(stRemovePathData.stOutput));
		stRemovePathData.stOutput.nNumberOfOutputArguments := nNoOfOutputArgs;
		stRemovePathData.stOutput.stOutputArgInfo[1] := aOutputArgInfo[1];
		stRemovePathData.stOutput.stOutputArgInfo[2] := aOutputArgInfo[2];
	
		(* Execute FB *)
		fbCallMethod.nNumberOfInputArguments := nNoOfInputArgs;
		fbCallMethod.pInputArgInfo := ADR(aInputArgInfo);
		fbCallMethod.cbInputArgInfo := (SIZEOF(aInputArgInfo[1])*nNoOfInputArgs);
		fbCallMethod.pInputArgData := ADR(aInputData);
		fbCallMethod.cbInputArgData := nOffset;
		fbCallMethod.nNumberOfOutputArguments := nNoOfOutputArgs; 
		fbCallMethod.pOutputArgInfo := ADR(aOutputArgInfo); 
		fbCallMethod.cbOutputArgInfo := (SIZEOF(aOutputArgInfo[1]) * nNoOfOutputArgs); 
		fbCallMethod.pOutputArgInfoAndData := ADR(stRemovePathData.stOutput);
		fbCallMethod.cbOutputArgInfoAndData := SIZEOF(stRemovePathData.stOutput);
		
		stRemovePathData.iStatus := 1;
		bCallMethod := TRUE;
		
	ELSIF (stRemovePathData.iStatus = 1) THEN
		// Method call Completed...
		IF (eStateMethod = E_TrackClientState.Connected) THEN
			// Method call OK
			IF (stRemovePathData.stOutput.eStatus = E_MMServerStatus.eMMServerStatus_Success) THEN
				// Method returned OK
				stRemovePathData.iStatus := 2;
			ELSE
				// Method returned with error
				stRemovePathData.iStatus := 3;
				stRemovePathData.stOutput.sMessage;
			END_IF
		ELSIF (eStateMethod = E_TrackClientState.Error) THEN
			// Method call failed
			stRemovePathData.iStatus := 3;
		END_IF
		
	END_IF
END_IF

M_CallRemovePath := stRemovePathData.iStatus;	
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_CallRemovePathSegment" Id="{89ef444e-206c-4289-83a8-303e94a443c2}">
      <Declaration><![CDATA[METHOD PROTECTED M_CallRemovePathSegment : INT
VAR_INPUT
	iSegmentNo		: UINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF (stRemovePathSegmentData.iStatus = 2) OR (stRemovePathSegmentData.iStatus = 3) THEN
	stRemovePathSegmentData.iStatus := 0;
END_IF

IF (bConnectedMethod AND NOT bBusyMethod) THEN
	IF (stRemovePathSegmentData.iStatus = 0) THEN
	(* Setup method calling parameters *)
		(* Method identifier *)
		sObjectIDentifier := stRemovePathSegmentData.sObjectID;
		sMethodIdentifier := stRemovePathSegmentData.sMethodID;
	
		(* Method Inputs *)
		stRemovePathSegmentData.stInput.sCellID := sCellID;
		stRemovePathSegmentData.stInput.sSegmentID := CONCAT(sCellID, '_PS');
		stRemovePathSegmentData.stInput.sSegmentID := CONCAT(stRemovePathSegmentData.stInput.sSegmentID, UINT_TO_STRING(iSegmentNo));			
		(* Fill input data area with method arguments *)
		MEMSET(ADR(aInputData), 0 ,SIZEOF(aInputData));
		nOffset := 0;
		nOffset := nOffset + MEMCPY(ADR(aInputData)+nOffset, ADR(stRemovePathSegmentData.stInput),	MIN(SIZEOF(stRemovePathSegmentData.stInput), (SIZEOF(aInputData)-nOffset)) );
		(* Number of input arguments *)
		nNoOfInputArgs := stRemovePathSegmentData.iNoOfInputArgs;
		(* Set up input argument information *)
		MEMSET(ADR(aInputArgInfo), 0, SIZEOF(aInputArgInfo));
		aInputArgInfo[1].DataType := eUAType_String;
		aInputArgInfo[1].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[1].nLenData := SIZEOF(stRemovePathSegmentData.stInput.sCellID);
		aInputArgInfo[2].DataType := eUAType_String;
		aInputArgInfo[2].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[2].nLenData := SIZEOF(stRemovePathSegmentData.stInput.sSegmentID);
		
		(* Method outputs *)
		(* Clear output data area *)
		(* Number of output arguments *)
		nNoOfOutputArgs := stRemovePathSegmentData.iNoOfOutputArgs;
		(* Set up output argument information *)
		MEMSET(ADR(aOutputArgInfo), 0, SIZEOF(aOutputArgInfo));
		aOutputArgInfo[1].DataType := eUAType_Uint16;
		aOutputArgInfo[1].ValueRank := -1;
		aOutputArgInfo[1].nLenData := SIZEOF(stRemovePathSegmentData.stOutput.eStatus);
		aOutputArgInfo[2].DataType := eUAType_String;
		aOutputArgInfo[2].ValueRank := -1;
		aOutputArgInfo[2].nLenData := SIZEOF(stRemovePathSegmentData.stOutput.sMessage);
		(* Set up output  *)
		MEMSET(ADR(stRemovePathSegmentData.stOutput), 0, SIZEOF(stRemovePathSegmentData.stOutput));
		stRemovePathSegmentData.stOutput.nNumberOfOutputArguments := nNoOfOutputArgs;
		stRemovePathSegmentData.stOutput.stOutputArgInfo[1] := aOutputArgInfo[1];
		stRemovePathSegmentData.stOutput.stOutputArgInfo[2] := aOutputArgInfo[2];
	
		(* Execute FB *)
		fbCallMethod.nNumberOfInputArguments := nNoOfInputArgs;
		fbCallMethod.pInputArgInfo := ADR(aInputArgInfo);
		fbCallMethod.cbInputArgInfo := (SIZEOF(aInputArgInfo[1])*nNoOfInputArgs);
		fbCallMethod.pInputArgData := ADR(aInputData);
		fbCallMethod.cbInputArgData := nOffset;
		fbCallMethod.nNumberOfOutputArguments := nNoOfOutputArgs; 
		fbCallMethod.pOutputArgInfo := ADR(aOutputArgInfo); 
		fbCallMethod.cbOutputArgInfo := (SIZEOF(aOutputArgInfo[1]) * nNoOfOutputArgs); 
		fbCallMethod.pOutputArgInfoAndData := ADR(stRemovePathSegmentData.stOutput);
		fbCallMethod.cbOutputArgInfoAndData := SIZEOF(stRemovePathSegmentData.stOutput);
		
		stRemovePathSegmentData.iStatus := 1;
		bCallMethod := TRUE;
		
	ELSIF (stRemovePathSegmentData.iStatus = 1) THEN
		// Method call Completed...
		IF (eStateMethod = E_TrackClientState.Connected) THEN
			// Method call OK
			IF (stRemovePathSegmentData.stOutput.eStatus = E_MMServerStatus.eMMServerStatus_Success) THEN
				// Method returned OK
				stRemovePathSegmentData.iStatus := 2;
			ELSE
				// Method returned with error
				stRemovePathSegmentData.iStatus := 3;
				stRemovePathSegmentData.stOutput.sMessage;
			END_IF
		ELSIF (eStateMethod = E_TrackClientState.Error) THEN
			// Method call failed
			stRemovePathSegmentData.iStatus := 3;
		END_IF
		
	END_IF
END_IF

M_CallRemovePathSegment := stRemovePathSegmentData.iStatus;	
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_CallRemoveReservation" Id="{445ba283-972e-489b-9fd4-6609fe655ab5}">
      <Declaration><![CDATA[METHOD PROTECTED M_CallRemoveReservation : INT
VAR_INPUT
	sStationID					: STRING(30);												(* The identifier for the station. *)
	nTicket						: UINT;														(*  *)
END_VAR
VAR
	i					: UINT;	
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF (stRemoveReservationData.iStatus = 2) OR (stRemoveReservationData.iStatus = 3) THEN
	stRemoveReservationData.iStatus := 0;
END_IF

IF (bConnectedMethod AND NOT bBusyMethod) THEN
	IF (stRemoveReservationData.iStatus = 0) THEN
	(* Setup method calling parameters *)
		(* Method identifier *)
		sObjectIDentifier := stRemoveReservationData.sObjectID;
		sMethodIdentifier := stRemoveReservationData.sMethodID;
	
		(* Method Inputs *)
		stRemoveReservationData.stInput.sStationID := sStationID;
		stRemoveReservationData.stInput.nTicket := nTicket;
		(* Fill input data area with method arguments *)
		MEMSET(ADR(aInputData), 0 ,SIZEOF(aInputData));
		nOffset := 0;
		nOffset := nOffset + MEMCPY(ADR(aInputData)+nOffset, ADR(stRemoveReservationData.stInput),	MIN(SIZEOF(stRemoveReservationData.stInput), (SIZEOF(aInputData)-nOffset)) );
		(* Number of input arguments *)
		nNoOfInputArgs := stRemoveReservationData.iNoOfInputArgs;
		(* Set up input argument information *)
		MEMSET(ADR(aInputArgInfo), 0, SIZEOF(aInputArgInfo));
		aInputArgInfo[1].DataType := eUAType_String;
		aInputArgInfo[1].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[1].nLenData := SIZEOF(stRemoveReservationData.stInput.sStationID);
		aInputArgInfo[2].DataType := eUAType_UInt16;
		aInputArgInfo[2].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[2].nLenData := SIZEOF(stRemoveReservationData.stInput.nTicket);
		
		(* Method outputs *)
		(* Clear output data area *)
		(* Number of output arguments *)
		nNoOfOutputArgs := stRemoveReservationData.iNoOfOutputArgs;
		(* Set up output argument information *)
		MEMSET(ADR(aOutputArgInfo), 0, SIZEOF(aOutputArgInfo));
		aOutputArgInfo[1].DataType := eUAType_Uint16;
		aOutputArgInfo[1].ValueRank := -1;
		aOutputArgInfo[1].nLenData := SIZEOF(stRemoveReservationData.stOutput.eStatus);
		aOutputArgInfo[2].DataType := eUAType_String;
		aOutputArgInfo[2].ValueRank := -1;
		aOutputArgInfo[2].nLenData := SIZEOF(stRemoveReservationData.stOutput.sMessage);
		(* Set up output  *)
		MEMSET(ADR(stRemoveReservationData.stOutput), 0, SIZEOF(stRemoveReservationData.stOutput));
		stRemoveReservationData.stOutput.nNumberOfOutputArguments := nNoOfOutputArgs;
		stRemoveReservationData.stOutput.stOutputArgInfo[1] := aOutputArgInfo[1];
		stRemoveReservationData.stOutput.stOutputArgInfo[2] := aOutputArgInfo[2];
	
		(* Execute FB *)
		fbCallMethod.nNumberOfInputArguments := nNoOfInputArgs;
		fbCallMethod.pInputArgInfo := ADR(aInputArgInfo);
		fbCallMethod.cbInputArgInfo := (SIZEOF(aInputArgInfo[1])*nNoOfInputArgs);
		fbCallMethod.pInputArgData := ADR(aInputData);
		fbCallMethod.cbInputArgData := nOffset;
		fbCallMethod.nNumberOfOutputArguments := nNoOfOutputArgs; 
		fbCallMethod.pOutputArgInfo := ADR(aOutputArgInfo); 
		fbCallMethod.cbOutputArgInfo := (SIZEOF(aOutputArgInfo[1]) * nNoOfOutputArgs); 
		fbCallMethod.pOutputArgInfoAndData := ADR(stRemoveReservationData.stOutput);
		fbCallMethod.cbOutputArgInfoAndData := SIZEOF(stRemoveReservationData.stOutput);
		
		stRemoveReservationData.iStatus := 1;
		bCallMethod := TRUE;
		
	ELSIF (stRemoveReservationData.iStatus = 1) THEN
		// Method call Completed...
		IF (eStateMethod = E_TrackClientState.Connected) THEN
			// Method call OK
			IF (stRemoveReservationData.stOutput.eStatus = E_MMServerStatus.eMMServerStatus_Success) THEN
				// Method returned OK
				stRemoveReservationData.iStatus := 2;
			ELSE
				// Method returned with error
				stRemoveReservationData.iStatus := 3;
				stRemoveReservationData.stOutput.sMessage;
			END_IF
		ELSIF (eStateMethod = E_TrackClientState.Error) THEN
			// Method call failed
			stRemoveReservationData.iStatus := 3;
		END_IF
		
	END_IF
END_IF

M_CallRemoveReservation := stRemoveReservationData.iStatus;	
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_CallRemoveStation" Id="{e256acd0-5eb0-46bc-9fb2-66a0bbff7d33}">
      <Declaration><![CDATA[METHOD PROTECTED M_CallRemoveStation : INT
VAR_INPUT
	nStationNo			: UINT(1..5);
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF (stRemoveStationData.iStatus = 2) OR (stRemoveStationData.iStatus = 3) THEN
	stRemoveStationData.iStatus := 0;
END_IF

IF (bConnectedMethod AND NOT bBusyMethod) THEN
	IF (stRemoveStationData.iStatus = 0) THEN
	(* Setup method calling parameters *)
		(* Method identifier *)
		sObjectIDentifier := stRemoveStationData.sObjectID;
		sMethodIdentifier := stRemoveStationData.sMethodID;
	
		(* Method Inputs *)
		stRemoveStationData.stInput.sCellID := sCellID;
		stRemoveStationData.stInput.sStationID := aStations[nStationNo].sStationID;
		(* Fill input data area with method arguments *)
		MEMSET(ADR(aInputData), 0 ,SIZEOF(aInputData));
		nOffset := 0;
		nOffset := nOffset + MEMCPY(ADR(aInputData)+nOffset, ADR(stRemoveStationData.stInput),	MIN(SIZEOF(stRemoveStationData.stInput), (SIZEOF(aInputData)-nOffset)) );
		(* Number of input arguments *)
		nNoOfInputArgs := stRemoveStationData.iNoOfInputArgs;
		(* Set up input argument information *)
		MEMSET(ADR(aInputArgInfo), 0, SIZEOF(aInputArgInfo));
		aInputArgInfo[1].DataType := eUAType_String;
		aInputArgInfo[1].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[1].nLenData := SIZEOF(stRemoveStationData.stInput.sCellID);
		aInputArgInfo[2].DataType := eUAType_String;
		aInputArgInfo[2].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[2].nLenData := SIZEOF(stRemoveStationData.stInput.sStationID);
		
		(* Method outputs *)
		(* Clear output data area *)
		(* Number of output arguments *)
		nNoOfOutputArgs := stRemoveStationData.iNoOfOutputArgs;
		(* Set up output argument information *)
		MEMSET(ADR(aOutputArgInfo), 0, SIZEOF(aOutputArgInfo));
		aOutputArgInfo[1].DataType := eUAType_Uint16;
		aOutputArgInfo[1].ValueRank := -1;
		aOutputArgInfo[1].nLenData := SIZEOF(stRemoveStationData.stOutput.eStatus);
		aOutputArgInfo[2].DataType := eUAType_String;
		aOutputArgInfo[2].ValueRank := -1;
		aOutputArgInfo[2].nLenData := SIZEOF(stRemoveStationData.stOutput.sMessage);
		(* Set up output  *)
		MEMSET(ADR(stRemoveStationData.stOutput), 0, SIZEOF(stRemoveStationData.stOutput));
		stRemoveStationData.stOutput.nNumberOfOutputArguments := nNoOfOutputArgs;
		stRemoveStationData.stOutput.stOutputArgInfo[1] := aOutputArgInfo[1];
		stRemoveStationData.stOutput.stOutputArgInfo[2] := aOutputArgInfo[2];
	
		(* Execute FB *)
		fbCallMethod.nNumberOfInputArguments := nNoOfInputArgs;
		fbCallMethod.pInputArgInfo := ADR(aInputArgInfo);
		fbCallMethod.cbInputArgInfo := (SIZEOF(aInputArgInfo[1])*nNoOfInputArgs);
		fbCallMethod.pInputArgData := ADR(aInputData);
		fbCallMethod.cbInputArgData := nOffset;
		fbCallMethod.nNumberOfOutputArguments := nNoOfOutputArgs; 
		fbCallMethod.pOutputArgInfo := ADR(aOutputArgInfo); 
		fbCallMethod.cbOutputArgInfo := (SIZEOF(aOutputArgInfo[1]) * nNoOfOutputArgs); 
		fbCallMethod.pOutputArgInfoAndData := ADR(stRemoveStationData.stOutput);
		fbCallMethod.cbOutputArgInfoAndData := SIZEOF(stRemoveStationData.stOutput);
		
		stRemoveStationData.iStatus := 1;
		bCallMethod := TRUE;
		
	ELSIF (stRemoveStationData.iStatus = 1) THEN
		// Method call Completed...
		IF (eStateMethod = E_TrackClientState.Connected) THEN
			// Method call OK
			IF (stRemoveStationData.stOutput.eStatus = E_MMServerStatus.eMMServerStatus_Success) THEN
				// Method returned OK
				stRemoveStationData.iStatus := 2;
			ELSE
				// Method returned with error
				stRemoveStationData.iStatus := 3;
				stRemoveStationData.stOutput.sMessage;
			END_IF
		ELSIF (eStateMethod = E_TrackClientState.Error) THEN
			// Method call failed
			stRemoveStationData.iStatus := 3;
		END_IF
		
	END_IF
END_IF

M_CallRemoveStation := stRemoveStationData.iStatus;	
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_CallRemoveTrafficLight" Id="{5c7df096-ff73-4ea2-bbd4-0977b8085d14}">
      <Declaration><![CDATA[METHOD PROTECTED M_CallRemoveTrafficLight : INT
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF (stRemoveTrafficLightData.iStatus = 2) OR (stRemoveTrafficLightData.iStatus = 3) THEN
	stRemoveTrafficLightData.iStatus := 0;
END_IF

IF (bConnectedMethod AND NOT bBusyMethod) THEN
	IF (stRemoveTrafficLightData.iStatus = 0) THEN
	(* Setup method calling parameters *)
		(* Method identifier *)
		sObjectIDentifier := stRemoveTrafficLightData.sObjectID;
		sMethodIdentifier := stRemoveTrafficLightData.sMethodID;
	
		(* Method Inputs *)
		stRemoveTrafficLightData.stInput.sCellID := sCellID;
		stRemoveTrafficLightData.stInput.sID := CONCAT(sCellID, '_TL');
		(* Fill input data area with method arguments *)
		MEMSET(ADR(aInputData), 0 ,SIZEOF(aInputData));
		nOffset := 0;
		nOffset := nOffset + MEMCPY(ADR(aInputData)+nOffset, ADR(stRemoveTrafficLightData.stInput),	MIN(SIZEOF(stRemoveTrafficLightData.stInput),	(SIZEOF(aInputData)-nOffset)) );
		(* Number of input arguments *)
		nNoOfInputArgs := stRemoveTrafficLightData.iNoOfInputArgs;
		(* Set up input argument information *)
		MEMSET(ADR(aInputArgInfo), 0, SIZEOF(aInputArgInfo));
		aInputArgInfo[1].DataType := eUAType_String;
		aInputArgInfo[1].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[1].nLenData := SIZEOF(stRemoveTrafficLightData.stInput.sCellID);
		aInputArgInfo[2].DataType := eUAType_String;
		aInputArgInfo[2].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[2].nLenData := SIZEOF(stRemoveTrafficLightData.stInput.sID);
		
		(* Method outputs *)
		(* Clear output data area *)
		(* Number of output arguments *)
		nNoOfOutputArgs := stRemoveTrafficLightData.iNoOfOutputArgs;
		(* Set up output argument information *)
		MEMSET(ADR(aOutputArgInfo), 0, SIZEOF(aOutputArgInfo));
		aOutputArgInfo[1].DataType := eUAType_Uint16;
		aOutputArgInfo[1].ValueRank := -1;
		aOutputArgInfo[1].nLenData := SIZEOF(stRemoveTrafficLightData.stOutput.eStatus);
		aOutputArgInfo[2].DataType := eUAType_String;
		aOutputArgInfo[2].ValueRank := -1;
		aOutputArgInfo[2].nLenData := SIZEOF(stRemoveTrafficLightData.stOutput.sMessage);
		(* Set up output  *)
		MEMSET(ADR(stRemoveTrafficLightData.stOutput), 0, SIZEOF(stRemoveTrafficLightData.stOutput));
		stRemoveTrafficLightData.stOutput.nNumberOfOutputArguments := nNoOfOutputArgs;
		stRemoveTrafficLightData.stOutput.stOutputArgInfo[1] := aOutputArgInfo[1];
		stRemoveTrafficLightData.stOutput.stOutputArgInfo[2] := aOutputArgInfo[2];
	
		(* Execute FB *)
		fbCallMethod.nNumberOfInputArguments := nNoOfInputArgs;
		fbCallMethod.pInputArgInfo := ADR(aInputArgInfo);
		fbCallMethod.cbInputArgInfo := (SIZEOF(aInputArgInfo[1])*nNoOfInputArgs);
		fbCallMethod.pInputArgData := ADR(aInputData);
		fbCallMethod.cbInputArgData := nOffset;
		fbCallMethod.nNumberOfOutputArguments := nNoOfOutputArgs; 
		fbCallMethod.pOutputArgInfo := ADR(aOutputArgInfo); 
		fbCallMethod.cbOutputArgInfo := (SIZEOF(aOutputArgInfo[1]) * nNoOfOutputArgs); 
		fbCallMethod.pOutputArgInfoAndData := ADR(stRemoveTrafficLightData.stOutput);
		fbCallMethod.cbOutputArgInfoAndData := SIZEOF(stRemoveTrafficLightData.stOutput);
		
		stRemoveTrafficLightData.iStatus := 1;
		bCallMethod := TRUE;
		
	ELSIF (stRemoveTrafficLightData.iStatus = 1) THEN
		// Method call Completed...
		IF (eStateMethod = E_TrackClientState.Connected) THEN
			// Method call OK
			IF (stRemoveTrafficLightData.stOutput.eStatus = E_MMServerStatus.eMMServerStatus_Success) THEN
				// Method returned OK
				stRemoveTrafficLightData.iStatus := 2;
			ELSE
				// Method returned with error
				stRemoveTrafficLightData.iStatus := 3;
				stRemoveTrafficLightData.stOutput.sMessage;
			END_IF
		ELSIF (eStateMethod = E_TrackClientState.Error) THEN
			// Method call failed
			stRemoveTrafficLightData.iStatus := 3;
		END_IF
		
	END_IF
END_IF

M_CallRemoveTrafficLight := stRemoveTrafficLightData.iStatus;	
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_CallResetPath" Id="{d14bbf22-85cb-4a04-854c-25a775e0ea3e}">
      <Declaration><![CDATA[METHOD PROTECTED M_CallResetPath : INT
VAR_INPUT
	nPathNo			: UINT(1..5);
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF (stResetPathData.iStatus = 2) OR (stResetPathData.iStatus = 3) THEN
	stResetPathData.iStatus := 0;
END_IF

IF (bConnectedMethod AND NOT bBusyMethod) THEN
	IF (stResetPathData.iStatus = 0) THEN
	(* Setup method calling parameters *)
		(* Method identifier *)
		sObjectIDentifier := stResetPathData.sObjectID;
		sMethodIdentifier := stResetPathData.sMethodID;
	
		(* Method Inputs *)
		stResetPathData.stInput.iPath := nPathNo;
		(* Fill input data area with method arguments *)
		MEMSET(ADR(aInputData), 0 ,SIZEOF(aInputData));
		nOffset := 0;
		nOffset := nOffset + MEMCPY(ADR(aInputData)+nOffset, ADR(stResetPathData.stInput),	MIN(SIZEOF(stResetPathData.stInput), (SIZEOF(aInputData)-nOffset)) );
		(* Number of input arguments *)
		nNoOfInputArgs := stResetPathData.iNoOfInputArgs;
		(* Set up input argument information *)
		MEMSET(ADR(aInputArgInfo), 0, SIZEOF(aInputArgInfo));
		aInputArgInfo[1].DataType := eUAType_UInt16;
		aInputArgInfo[1].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[1].nLenData := SIZEOF(stResetPathData.stInput.iPath);
		
		(* Method outputs *)
		(* Clear output data area *)
		(* Number of output arguments *)
		nNoOfOutputArgs := stResetPathData.iNoOfOutputArgs;
		(* Set up output argument information *)
		MEMSET(ADR(aOutputArgInfo), 0, SIZEOF(aOutputArgInfo));
		aOutputArgInfo[1].DataType := eUAType_Uint16;
		aOutputArgInfo[1].ValueRank := -1;
		aOutputArgInfo[1].nLenData := SIZEOF(stResetPathData.stOutput.eStatus);
		aOutputArgInfo[2].DataType := eUAType_String;
		aOutputArgInfo[2].ValueRank := -1;
		aOutputArgInfo[2].nLenData := SIZEOF(stResetPathData.stOutput.sMessage);
		(* Set up output  *)
		MEMSET(ADR(stResetPathData.stOutput), 0, SIZEOF(stResetPathData.stOutput));
		stResetPathData.stOutput.nNumberOfOutputArguments := nNoOfOutputArgs;
		stResetPathData.stOutput.stOutputArgInfo[1] := aOutputArgInfo[1];
		stResetPathData.stOutput.stOutputArgInfo[2] := aOutputArgInfo[2];
	
		(* Execute FB *)
		fbCallMethod.nNumberOfInputArguments := nNoOfInputArgs;
		fbCallMethod.pInputArgInfo := ADR(aInputArgInfo);
		fbCallMethod.cbInputArgInfo := (SIZEOF(aInputArgInfo[1])*nNoOfInputArgs);
		fbCallMethod.pInputArgData := ADR(aInputData);
		fbCallMethod.cbInputArgData := nOffset;
		fbCallMethod.nNumberOfOutputArguments := nNoOfOutputArgs; 
		fbCallMethod.pOutputArgInfo := ADR(aOutputArgInfo); 
		fbCallMethod.cbOutputArgInfo := (SIZEOF(aOutputArgInfo[1]) * nNoOfOutputArgs); 
		fbCallMethod.pOutputArgInfoAndData := ADR(stResetPathData.stOutput);
		fbCallMethod.cbOutputArgInfoAndData := SIZEOF(stResetPathData.stOutput);
		
		stResetPathData.iStatus := 1;
		bCallMethod := TRUE;
		
	ELSIF (stResetPathData.iStatus = 1) THEN
		// Method call Completed...
		IF (eStateMethod = E_TrackClientState.Connected) THEN
			// eStateMethod call OK
			IF (stResetPathData.stOutput.eStatus = E_MMServerStatus.eMMServerStatus_Success) THEN
				// Method returned OK
				stResetPathData.iStatus := 2;
			ELSE
				// Method returned with error
				stResetPathData.iStatus := 3;
				stResetPathData.stOutput.sMessage;
			END_IF
		ELSIF (eStateMethod = E_TrackClientState.Error) THEN
			// Method call failed
			stResetPathData.iStatus := 3;
		END_IF
		
	END_IF
END_IF

M_CallResetPath := stResetPathData.iStatus;	
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_CallResumePath" Id="{dd3456c4-41fd-46f5-9378-e1fd4dd8cab0}">
      <Declaration><![CDATA[METHOD PROTECTED M_CallResumePath : INT
VAR_INPUT
	nPathNo			: UINT(1..5);
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF (stResumePathData.iStatus = 2) OR (stResumePathData.iStatus = 3) THEN
	stResumePathData.iStatus := 0;
END_IF

IF (bConnectedMethod AND NOT bBusyMethod) THEN
	IF (stResumePathData.iStatus = 0) THEN
	(* Setup method calling parameters *)
		(* Method identifier *)
		sObjectIDentifier := stResumePathData.sObjectID;
		sMethodIdentifier := stResumePathData.sMethodID;
	
		(* Method Inputs *)
		stResumePathData.stInput.iPath := nPathNo;
		(* Fill input data area with method arguments *)
		MEMSET(ADR(aInputData), 0 ,SIZEOF(aInputData));
		nOffset := 0;
		nOffset := nOffset + MEMCPY(ADR(aInputData)+nOffset, ADR(stResumePathData.stInput),	MIN(SIZEOF(stResumePathData.stInput), (SIZEOF(aInputData)-nOffset)) );
		(* Number of input arguments *)
		nNoOfInputArgs := stResumePathData.iNoOfInputArgs;
		(* Set up input argument information *)
		MEMSET(ADR(aInputArgInfo), 0, SIZEOF(aInputArgInfo));
		aInputArgInfo[1].DataType := eUAType_UInt16;
		aInputArgInfo[1].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[1].nLenData := SIZEOF(stResumePathData.stInput.iPath);
		
		(* Method outputs *)
		(* Clear output data area *)
		(* Number of output arguments *)
		nNoOfOutputArgs := stResumePathData.iNoOfOutputArgs;
		(* Set up output argument information *)
		MEMSET(ADR(aOutputArgInfo), 0, SIZEOF(aOutputArgInfo));
		aOutputArgInfo[1].DataType := eUAType_Uint16;
		aOutputArgInfo[1].ValueRank := -1;
		aOutputArgInfo[1].nLenData := SIZEOF(stResumePathData.stOutput.eStatus);
		aOutputArgInfo[2].DataType := eUAType_String;
		aOutputArgInfo[2].ValueRank := -1;
		aOutputArgInfo[2].nLenData := SIZEOF(stResumePathData.stOutput.sMessage);
		(* Set up output  *)
		MEMSET(ADR(stResumePathData.stOutput), 0, SIZEOF(stResumePathData.stOutput));
		stResumePathData.stOutput.nNumberOfOutputArguments := nNoOfOutputArgs;
		stResumePathData.stOutput.stOutputArgInfo[1] := aOutputArgInfo[1];
		stResumePathData.stOutput.stOutputArgInfo[2] := aOutputArgInfo[2];
	
		(* Execute FB *)
		fbCallMethod.nNumberOfInputArguments := nNoOfInputArgs;
		fbCallMethod.pInputArgInfo := ADR(aInputArgInfo);
		fbCallMethod.cbInputArgInfo := (SIZEOF(aInputArgInfo[1])*nNoOfInputArgs);
		fbCallMethod.pInputArgData := ADR(aInputData);
		fbCallMethod.cbInputArgData := nOffset;
		fbCallMethod.nNumberOfOutputArguments := nNoOfOutputArgs; 
		fbCallMethod.pOutputArgInfo := ADR(aOutputArgInfo); 
		fbCallMethod.cbOutputArgInfo := (SIZEOF(aOutputArgInfo[1]) * nNoOfOutputArgs); 
		fbCallMethod.pOutputArgInfoAndData := ADR(stResumePathData.stOutput);
		fbCallMethod.cbOutputArgInfoAndData := SIZEOF(stResumePathData.stOutput);
		
		stResumePathData.iStatus := 1;
		bCallMethod := TRUE;
		
	ELSIF (stResumePathData.iStatus = 1) THEN
		// Method call Completed...
		IF (eStateMethod = E_TrackClientState.Connected) THEN
			// Method call OK
			IF (stResumePathData.stOutput.eStatus = E_MMServerStatus.eMMServerStatus_Success) THEN
				// Method returned OK
				stResumePathData.iStatus := 2;
			ELSE
				// Method returned with error
				stResumePathData.iStatus := 3;
				stResumePathData.stOutput.sMessage;
			END_IF
		ELSIF (eStateMethod = E_TrackClientState.Error) THEN
			// Method call failed
			stResumePathData.iStatus := 3;
		END_IF
		
	END_IF
END_IF

M_CallResumePath := stResumePathData.iStatus;	
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_CallSetTrafficLightColor" Id="{39a7e5e7-dcf3-4537-b684-fca830d15aa8}">
      <Declaration><![CDATA[METHOD PROTECTED M_CallSetTrafficLightColor : INT
VAR_INPUT
	nTrafficLightNo	: UINT;
	nColor			: INT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF (stSetTrafficLightColorData.iStatus = 2) OR (stSetTrafficLightColorData.iStatus = 3) THEN
	stSetTrafficLightColorData.iStatus := 0;
END_IF

IF (bConnectedMethod AND NOT bBusyMethod) THEN
	IF (stSetTrafficLightColorData.iStatus = 0) THEN
	(* Setup method calling parameters *)
		(* Method identifier *)
		sObjectIDentifier := stSetTrafficLightColorData.sObjectID;
		sMethodIdentifier := stSetTrafficLightColorData.sMethodID;
			
		(* Method Inputs *)
		stSetTrafficLightColorData.stInput.sCellID := sCellID;
		stSetTrafficLightColorData.stInput.sID := CONCAT(sCellID, '_TL');
		stSetTrafficLightColorData.stInput.sID := CONCAT(stSetTrafficLightColorData.stInput.sID, UINT_TO_STRING(nTrafficLightNo));
		stSetTrafficLightColorData.stInput.nColor := nColor;
		(* Fill input data area with method arguments *)
		MEMSET(ADR(aInputData), 0 ,SIZEOF(aInputData));
		nOffset := 0;
		nOffset := nOffset + MEMCPY(ADR(aInputData)+nOffset, ADR(stSetTrafficLightColorData.stInput),	MIN(SIZEOF(stSetTrafficLightColorData.stInput),	(SIZEOF(aInputData)-nOffset)) );
		(* Number of input arguments *)
		nNoOfInputArgs := stSetTrafficLightColorData.iNoOfInputArgs;
		(* Set up input argument information *)
		MEMSET(ADR(aInputArgInfo), 0, SIZEOF(aInputArgInfo));
		aInputArgInfo[1].DataType := eUAType_String;
		aInputArgInfo[1].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[1].nLenData := SIZEOF(stSetTrafficLightColorData.stInput.sCellID);
		aInputArgInfo[2].DataType := eUAType_String;
		aInputArgInfo[2].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[2].nLenData := SIZEOF(stSetTrafficLightColorData.stInput.sID);
		aInputArgInfo[3].DataType := eUAType_Int16;
		aInputArgInfo[3].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[3].nLenData := SIZEOF(nColor);
		
		(* Method outputs *)
		(* Clear output data area *)
		(* Number of output arguments *)
		nNoOfOutputArgs := stSetTrafficLightColorData.iNoOfOutputArgs;
		(* Set up output argument information *)
		MEMSET(ADR(aOutputArgInfo), 0, SIZEOF(aOutputArgInfo));
		aOutputArgInfo[1].DataType := eUAType_Uint16;
		aOutputArgInfo[1].ValueRank := -1;
		aOutputArgInfo[1].nLenData := SIZEOF(stSetTrafficLightColorData.stOutput.eStatus);
		aOutputArgInfo[2].DataType := eUAType_String;
		aOutputArgInfo[2].ValueRank := -1;
		aOutputArgInfo[2].nLenData := SIZEOF(stSetTrafficLightColorData.stOutput.sMessage);
		(* Set up output  *)
		MEMSET(ADR(stSetTrafficLightColorData.stOutput), 0, SIZEOF(stSetTrafficLightColorData.stOutput));
		stSetTrafficLightColorData.stOutput.nNumberOfOutputArguments := nNoOfOutputArgs;
		stSetTrafficLightColorData.stOutput.stOutputArgInfo[1] := aOutputArgInfo[1];
		stSetTrafficLightColorData.stOutput.stOutputArgInfo[2] := aOutputArgInfo[2];
	
		(* Execute FB *)
		fbCallMethod.nNumberOfInputArguments := nNoOfInputArgs;
		fbCallMethod.pInputArgInfo := ADR(aInputArgInfo);
		fbCallMethod.cbInputArgInfo := (SIZEOF(aInputArgInfo[1])*nNoOfInputArgs);
		fbCallMethod.pInputArgData := ADR(aInputData);
		fbCallMethod.cbInputArgData := nOffset;
		fbCallMethod.nNumberOfOutputArguments := nNoOfOutputArgs; 
		fbCallMethod.pOutputArgInfo := ADR(aOutputArgInfo); 
		fbCallMethod.cbOutputArgInfo := (SIZEOF(aOutputArgInfo[1]) * nNoOfOutputArgs); 
		fbCallMethod.pOutputArgInfoAndData := ADR(stSetTrafficLightColorData.stOutput);
		fbCallMethod.cbOutputArgInfoAndData := SIZEOF(stSetTrafficLightColorData.stOutput);
		
		stSetTrafficLightColorData.iStatus := 1;
		bCallMethod := TRUE;
		
	ELSIF (stSetTrafficLightColorData.iStatus = 1) THEN
		// Method call Completed...
		IF (eStateMethod = E_TrackClientState.Connected) THEN
			// Method call OK
			IF (stSetTrafficLightColorData.stOutput.eStatus = E_MMServerStatus.eMMServerStatus_Success) THEN
				// Method returned OK
				stSetTrafficLightColorData.iStatus := 2;
			ELSE
				// Method returned with error
				stSetTrafficLightColorData.iStatus := 3;
				stSetTrafficLightColorData.stOutput.sMessage;
			END_IF
		ELSIF (eStateMethod = E_TrackClientState.Error) THEN
			// Method call failed
			stSetTrafficLightColorData.iStatus := 3;
		END_IF
		
	END_IF
END_IF

M_CallSetTrafficLightColor := stSetTrafficLightColorData.iStatus;	
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_CallStartPath" Id="{8a8a0f75-2db0-41da-b49f-94dd573e7154}">
      <Declaration><![CDATA[METHOD PROTECTED M_CallStartPath : INT
VAR_INPUT
	nPathNo			: UINT(1..5);
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF (stStartPathData.iStatus = 2) OR (stStartPathData.iStatus = 3) THEN
	stStartPathData.iStatus := 0;
END_IF

IF (bConnectedMethod AND NOT bBusyMethod) THEN
	IF (stStartPathData.iStatus = 0) THEN
	(* Setup method calling parameters *)
		(* Method identifier *)
		sObjectIDentifier := stStartPathData.sObjectID;
		sMethodIdentifier := stStartPathData.sMethodID;
	
		(* Method Inputs *)
		stStartPathData.stInput.iPath := nPathNo;
		(* Fill input data area with method arguments *)
		MEMSET(ADR(aInputData), 0 ,SIZEOF(aInputData));
		nOffset := 0;
		nOffset := nOffset + MEMCPY(ADR(aInputData)+nOffset, ADR(stStartPathData.stInput),	MIN(SIZEOF(stStartPathData.stInput), (SIZEOF(aInputData)-nOffset)) );
		(* Number of input arguments *)
		nNoOfInputArgs := stStartPathData.iNoOfInputArgs;
		(* Set up input argument information *)
		MEMSET(ADR(aInputArgInfo), 0, SIZEOF(aInputArgInfo));
		aInputArgInfo[1].DataType := eUAType_UInt16;
		aInputArgInfo[1].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[1].nLenData := SIZEOF(stStartPathData.stInput.iPath);
		
		(* Method outputs *)
		(* Clear output data area *)
		(* Number of output arguments *)
		nNoOfOutputArgs := stStartPathData.iNoOfOutputArgs;
		(* Set up output argument information *)
		MEMSET(ADR(aOutputArgInfo), 0, SIZEOF(aOutputArgInfo));
		aOutputArgInfo[1].DataType := eUAType_Uint16;
		aOutputArgInfo[1].ValueRank := -1;
		aOutputArgInfo[1].nLenData := SIZEOF(stStartPathData.stOutput.eStatus);
		aOutputArgInfo[2].DataType := eUAType_String;
		aOutputArgInfo[2].ValueRank := -1;
		aOutputArgInfo[2].nLenData := SIZEOF(stStartPathData.stOutput.sMessage);
		(* Set up output  *)
		MEMSET(ADR(stStartPathData.stOutput), 0, SIZEOF(stStartPathData.stOutput));
		stStartPathData.stOutput.nNumberOfOutputArguments := nNoOfOutputArgs;
		stStartPathData.stOutput.stOutputArgInfo[1] := aOutputArgInfo[1];
		stStartPathData.stOutput.stOutputArgInfo[2] := aOutputArgInfo[2];
	
		(* Execute FB *)
		fbCallMethod.nNumberOfInputArguments := nNoOfInputArgs;
		fbCallMethod.pInputArgInfo := ADR(aInputArgInfo);
		fbCallMethod.cbInputArgInfo := (SIZEOF(aInputArgInfo[1])*nNoOfInputArgs);
		fbCallMethod.pInputArgData := ADR(aInputData);
		fbCallMethod.cbInputArgData := nOffset;
		fbCallMethod.nNumberOfOutputArguments := nNoOfOutputArgs; 
		fbCallMethod.pOutputArgInfo := ADR(aOutputArgInfo); 
		fbCallMethod.cbOutputArgInfo := (SIZEOF(aOutputArgInfo[1]) * nNoOfOutputArgs); 
		fbCallMethod.pOutputArgInfoAndData := ADR(stStartPathData.stOutput);
		fbCallMethod.cbOutputArgInfoAndData := SIZEOF(stStartPathData.stOutput);
		
		stStartPathData.iStatus := 1;
		bCallMethod := TRUE;
		
	ELSIF (stStartPathData.iStatus = 1) THEN
		// Method call Completed...
		IF (eStateMethod = E_TrackClientState.Connected) THEN
			// Method call OK
			IF (stStartPathData.stOutput.eStatus = E_MMServerStatus.eMMServerStatus_Success) THEN
				// Method returned OK
				stStartPathData.iStatus := 2;
			ELSE
				// Method returned with error
				stStartPathData.iStatus := 3;
				stStartPathData.stOutput.sMessage;
			END_IF
		ELSIF (eStateMethod = E_TrackClientState.Error) THEN
			// Method call failed
			stStartPathData.iStatus := 3;
		END_IF
		
	END_IF
END_IF

M_CallStartPath := stStartPathData.iStatus;	
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_CallSuspendPath" Id="{557446d8-92e3-41af-abfa-2649e650b0cc}">
      <Declaration><![CDATA[METHOD PROTECTED M_CallSuspendPath : INT
VAR_INPUT
	nPathNo			: UINT(1..5);
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF (stSuspendPathData.iStatus = 2) OR (stSuspendPathData.iStatus = 3) THEN
	stSuspendPathData.iStatus := 0;
END_IF

IF (bConnectedMethod AND NOT bBusyMethod) THEN
	IF (stSuspendPathData.iStatus = 0) THEN
	(* Setup method calling parameters *)
		(* Method identifier *)
		sObjectIDentifier := stSuspendPathData.sObjectID;
		sMethodIdentifier := stSuspendPathData.sMethodID;
	
		(* Method Inputs *)
		stSuspendPathData.stInput.iPath := nPathNo;
		(* Fill input data area with method arguments *)
		MEMSET(ADR(aInputData), 0 ,SIZEOF(aInputData));
		nOffset := 0;
		nOffset := nOffset + MEMCPY(ADR(aInputData)+nOffset, ADR(stSuspendPathData.stInput),	MIN(SIZEOF(stSuspendPathData.stInput), (SIZEOF(aInputData)-nOffset)) );
		(* Number of input arguments *)
		nNoOfInputArgs := stSuspendPathData.iNoOfInputArgs;
		(* Set up input argument information *)
		MEMSET(ADR(aInputArgInfo), 0, SIZEOF(aInputArgInfo));
		aInputArgInfo[1].DataType := eUAType_UInt16;
		aInputArgInfo[1].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[1].nLenData := SIZEOF(stSuspendPathData.stInput.iPath);
		
		(* Method outputs *)
		(* Clear output data area *)
		(* Number of output arguments *)
		nNoOfOutputArgs := stSuspendPathData.iNoOfOutputArgs;
		(* Set up output argument information *)
		MEMSET(ADR(aOutputArgInfo), 0, SIZEOF(aOutputArgInfo));
		aOutputArgInfo[1].DataType := eUAType_Uint16;
		aOutputArgInfo[1].ValueRank := -1;
		aOutputArgInfo[1].nLenData := SIZEOF(stSuspendPathData.stOutput.eStatus);
		aOutputArgInfo[2].DataType := eUAType_String;
		aOutputArgInfo[2].ValueRank := -1;
		aOutputArgInfo[2].nLenData := SIZEOF(stSuspendPathData.stOutput.sMessage);
		(* Set up output  *)
		MEMSET(ADR(stSuspendPathData.stOutput), 0, SIZEOF(stSuspendPathData.stOutput));
		stSuspendPathData.stOutput.nNumberOfOutputArguments := nNoOfOutputArgs;
		stSuspendPathData.stOutput.stOutputArgInfo[1] := aOutputArgInfo[1];
		stSuspendPathData.stOutput.stOutputArgInfo[2] := aOutputArgInfo[2];
	
		(* Execute FB *)
		fbCallMethod.nNumberOfInputArguments := nNoOfInputArgs;
		fbCallMethod.pInputArgInfo := ADR(aInputArgInfo);
		fbCallMethod.cbInputArgInfo := (SIZEOF(aInputArgInfo[1])*nNoOfInputArgs);
		fbCallMethod.pInputArgData := ADR(aInputData);
		fbCallMethod.cbInputArgData := nOffset;
		fbCallMethod.nNumberOfOutputArguments := nNoOfOutputArgs; 
		fbCallMethod.pOutputArgInfo := ADR(aOutputArgInfo); 
		fbCallMethod.cbOutputArgInfo := (SIZEOF(aOutputArgInfo[1]) * nNoOfOutputArgs); 
		fbCallMethod.pOutputArgInfoAndData := ADR(stSuspendPathData.stOutput);
		fbCallMethod.cbOutputArgInfoAndData := SIZEOF(stSuspendPathData.stOutput);
		
		stSuspendPathData.iStatus := 1;
		bCallMethod := TRUE;
		
	ELSIF (stSuspendPathData.iStatus = 1) THEN
		// Method call Completed...
		IF (eStateMethod = E_TrackClientState.Connected) THEN
			// Method call OK
			IF (stSuspendPathData.stOutput.eStatus = E_MMServerStatus.eMMServerStatus_Success) THEN
				// Method returned OK
				stSuspendPathData.iStatus := 2;
			ELSE
				// Method returned with error
				stSuspendPathData.iStatus := 3;
				stSuspendPathData.stOutput.sMessage;
			END_IF
		ELSIF (eStateMethod = E_TrackClientState.Error) THEN
			// Method call failed
			stSuspendPathData.iStatus := 3;
		END_IF
		
	END_IF
END_IF

M_CallSuspendPath := stSuspendPathData.iStatus;	
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_CallTrafficLightColor" Id="{f77855b9-801c-43b0-aba4-3a7c320e868e}">
      <Declaration><![CDATA[METHOD PROTECTED M_CallTrafficLightColor : INT
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF (stTrafficLightColorData.iStatus = 2) OR (stTrafficLightColorData.iStatus = 3) THEN
	stTrafficLightColorData.iStatus := 0;
END_IF

IF (bConnectedMethod AND NOT bBusyMethod) THEN
	IF (stTrafficLightColorData.iStatus = 0) THEN
	(* Setup method calling parameters *)
		(* Method identifier *)
		sObjectIDentifier := stTrafficLightColorData.sObjectID;
		sMethodIdentifier := stTrafficLightColorData.sMethodID;
	
		(* Method Inputs *)
		stTrafficLightColorData.stInput.sCellID := sCellID;
		stTrafficLightColorData.stInput.sID := CONCAT(sCellID, '_TL');
		(* Fill input data area with method arguments *)
		MEMSET(ADR(aInputData), 0 ,SIZEOF(aInputData));
		nOffset := 0;
		nOffset := nOffset + MEMCPY(ADR(aInputData)+nOffset, ADR(stTrafficLightColorData.stInput),	MIN(SIZEOF(stTrafficLightColorData.stInput), (SIZEOF(aInputData)-nOffset)) );
		(* Number of input arguments *)
		nNoOfInputArgs := stTrafficLightColorData.iNoOfInputArgs;
		(* Set up input argument information *)
		MEMSET(ADR(aInputArgInfo), 0, SIZEOF(aInputArgInfo));
		aInputArgInfo[1].DataType := eUAType_String;
		aInputArgInfo[1].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[1].nLenData := SIZEOF(stTrafficLightColorData.stInput.sCellID);
		aInputArgInfo[2].DataType := eUAType_String;
		aInputArgInfo[2].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[2].nLenData := SIZEOF(stTrafficLightColorData.stInput.sID);
		
		(* Method outputs *)
		(* Clear output data area *)
		(* Number of output arguments *)
		nNoOfOutputArgs := stTrafficLightColorData.iNoOfOutputArgs;
		(* Set up output argument information *)
		MEMSET(ADR(aOutputArgInfo), 0, SIZEOF(aOutputArgInfo));
		aOutputArgInfo[1].DataType := eUAType_Uint16;
		aOutputArgInfo[1].ValueRank := -1;
		aOutputArgInfo[1].nLenData := SIZEOF(stTrafficLightColorData.stOutput.eStatus);
		aOutputArgInfo[2].DataType := eUAType_String;
		aOutputArgInfo[2].ValueRank := -1;
		aOutputArgInfo[2].nLenData := SIZEOF(stTrafficLightColorData.stOutput.sMessage);
		aOutputArgInfo[3].DataType := eUAType_Int16;
		aOutputArgInfo[3].ValueRank := -1;
		aOutputArgInfo[3].nLenData := SIZEOF(stTrafficLightColorData.stOutput.nTrafficLightColor);
		(* Set up output  *)
		MEMSET(ADR(stTrafficLightColorData.stOutput), 0, SIZEOF(stTrafficLightColorData.stOutput));
		stTrafficLightColorData.stOutput.nNumberOfOutputArguments := nNoOfOutputArgs;
		stTrafficLightColorData.stOutput.stOutputArgInfo[1] := aOutputArgInfo[1];
		stTrafficLightColorData.stOutput.stOutputArgInfo[2] := aOutputArgInfo[2];
		stTrafficLightColorData.stOutput.stOutputArgInfo[3] := aOutputArgInfo[3];
	
		(* Execute FB *)
		fbCallMethod.nNumberOfInputArguments := nNoOfInputArgs;
		fbCallMethod.pInputArgInfo := ADR(aInputArgInfo);
		fbCallMethod.cbInputArgInfo := (SIZEOF(aInputArgInfo[1])*nNoOfInputArgs);
		fbCallMethod.pInputArgData := ADR(aInputData);
		fbCallMethod.cbInputArgData := nOffset;
		fbCallMethod.nNumberOfOutputArguments := nNoOfOutputArgs; 
		fbCallMethod.pOutputArgInfo := ADR(aOutputArgInfo); 
		fbCallMethod.cbOutputArgInfo := (SIZEOF(aOutputArgInfo[1]) * nNoOfOutputArgs); 
		fbCallMethod.pOutputArgInfoAndData := ADR(stTrafficLightColorData.stOutput);
		fbCallMethod.cbOutputArgInfoAndData := SIZEOF(stTrafficLightColorData.stOutput);
		
		stTrafficLightColorData.iStatus := 1;
		bCallMethod := TRUE;
		
	ELSIF (stTrafficLightColorData.iStatus = 1) THEN
		// Method call Completed...
		IF (eStateMethod = E_TrackClientState.Connected) THEN
			// Method call OK
			IF (stTrafficLightColorData.stOutput.eStatus = E_MMServerStatus.eMMServerStatus_Success) THEN
				// Method returned OK
				stTrafficLightColorData.iStatus := 2;
			ELSE
				// Method returned with error
				stTrafficLightColorData.iStatus := 3;
				stTrafficLightColorData.stOutput.sMessage;
				stTrafficLightColorData.stOutput.nTrafficLightColor;
			END_IF
		ELSIF (eStateMethod = E_TrackClientState.Error) THEN
			// Method call failed
			stTrafficLightColorData.iStatus := 3;
		END_IF
		
	END_IF
END_IF

M_CallTrafficLightColor := stTrafficLightColorData.iStatus;	
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_CallUpdateStationBuffer" Id="{c5e96520-9256-4b65-9f9c-03d2b61e42bb}">
      <Declaration><![CDATA[METHOD PROTECTED M_CallUpdateStationBuffer : INT
VAR_INPUT
	sStationID			: STRING(30);
	eBufferType			: E_MMStationBuffer;
	nBufferIndex		: USINT;	
	nVehicleID			: UINT;
	sCarrierID			: STRING(30);
	nTicket				: UINT;
	nPriority			: UINT;
END_VAR
VAR
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF (stUpdateStationBufferData.iStatus = 2) OR (stUpdateStationBufferData.iStatus = 3) THEN
	stUpdateStationBufferData.iStatus := 0;
END_IF

IF (bConnectedMethod AND NOT bBusyMethod) THEN
	IF (stUpdateStationBufferData.iStatus = 0) THEN
	(* Setup method calling parameters *)
		(* Method identifier *)
		sObjectIDentifier := stUpdateStationBufferData.sObjectID;
		sMethodIdentifier := stUpdateStationBufferData.sMethodID;
	
		(* Method Inputs *)
		stUpdateStationBufferData.stInput.sStationID := sStationID;
		stUpdateStationBufferData.stInput.eStationBufferType := eBufferType;
		stUpdateStationBufferData.stInput.nIndex := nBufferIndex;
		stUpdateStationBufferData.stInput.nVehicleID := nVehicleID;
		stUpdateStationBufferData.stInput.sCarrierID := sCarrierID;
		stUpdateStationBufferData.stInput.nTicket := nTicket;
		stUpdateStationBufferData.stInput.nPriority := nPriority;
		
		(* Fill input data area with method arguments *)
		MEMSET(ADR(aInputData), 0 ,SIZEOF(aInputData));
		nOffset := 0;
		nOffset := nOffset + MEMCPY(ADR(aInputData)+nOffset, ADR(stUpdateStationBufferData.stInput),	MIN(SIZEOF(stUpdateStationBufferData.stInput), (SIZEOF(aInputData)-nOffset)) );
		(* Number of input arguments *)
		nNoOfInputArgs := stUpdateStationBufferData.iNoOfInputArgs;
		(* Set up input argument information *)
		MEMSET(ADR(aInputArgInfo), 0, SIZEOF(aInputArgInfo));
		aInputArgInfo[1].DataType := eUAType_String;
		aInputArgInfo[1].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[1].nLenData := SIZEOF(stUpdateStationBufferData.stInput.sStationID);
		aInputArgInfo[2].DataType := eUAType_UInt16;
		aInputArgInfo[2].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[2].nLenData := SIZEOF(stUpdateStationBufferData.stInput.eStationBufferType);
		aInputArgInfo[3].DataType := eUAType_Byte;
		aInputArgInfo[3].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[3].nLenData := SIZEOF(stUpdateStationBufferData.stInput.nIndex);
		aInputArgInfo[4].DataType := eUAType_UInt16;
		aInputArgInfo[4].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[4].nLenData := SIZEOF(stUpdateStationBufferData.stInput.nVehicleID);
		aInputArgInfo[5].DataType := eUAType_String;
		aInputArgInfo[5].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[5].nLenData := SIZEOF(stUpdateStationBufferData.stInput.sCarrierID);
		aInputArgInfo[6].DataType := eUAType_UInt16;
		aInputArgInfo[6].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[6].nLenData := SIZEOF(stUpdateStationBufferData.stInput.nTicket);
		aInputArgInfo[7].DataType := eUAType_UInt16;
		aInputArgInfo[7].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[7].nLenData := SIZEOF(stUpdateStationBufferData.stInput.nPriority);
		
		(* Method outputs *)
		(* Clear output data area *)
		(* Number of output arguments *)
		nNoOfOutputArgs := stUpdateStationBufferData.iNoOfOutputArgs;
		(* Set up output argument information *)
		MEMSET(ADR(aOutputArgInfo), 0, SIZEOF(aOutputArgInfo));
		aOutputArgInfo[1].DataType := eUAType_Uint16;
		aOutputArgInfo[1].ValueRank := -1;
		aOutputArgInfo[1].nLenData := SIZEOF(stUpdateStationBufferData.stOutput.eStatus);
		aOutputArgInfo[2].DataType := eUAType_String;
		aOutputArgInfo[2].ValueRank := -1;
		aOutputArgInfo[2].nLenData := SIZEOF(stUpdateStationBufferData.stOutput.sMessage);
		(* Set up output  *)
		MEMSET(ADR(stUpdateStationBufferData.stOutput), 0, SIZEOF(stUpdateStationBufferData.stOutput));
		stUpdateStationBufferData.stOutput.nNumberOfOutputArguments := nNoOfOutputArgs;
		stUpdateStationBufferData.stOutput.stOutputArgInfo[1] := aOutputArgInfo[1];
		stUpdateStationBufferData.stOutput.stOutputArgInfo[2] := aOutputArgInfo[2];
	
		(* Execute FB *)
		fbCallMethod.nNumberOfInputArguments := nNoOfInputArgs;
		fbCallMethod.pInputArgInfo := ADR(aInputArgInfo);
		fbCallMethod.cbInputArgInfo := (SIZEOF(aInputArgInfo[1])*nNoOfInputArgs);
		fbCallMethod.pInputArgData := ADR(aInputData);
		fbCallMethod.cbInputArgData := nOffset;
		fbCallMethod.nNumberOfOutputArguments := nNoOfOutputArgs; 
		fbCallMethod.pOutputArgInfo := ADR(aOutputArgInfo); 
		fbCallMethod.cbOutputArgInfo := (SIZEOF(aOutputArgInfo[1]) * nNoOfOutputArgs); 
		fbCallMethod.pOutputArgInfoAndData := ADR(stUpdateStationBufferData.stOutput);
		fbCallMethod.cbOutputArgInfoAndData := SIZEOF(stUpdateStationBufferData.stOutput);
		
		stUpdateStationBufferData.iStatus := 1;
		bCallMethod := TRUE;
		
	ELSIF (stUpdateStationBufferData.iStatus = 1) THEN
		// Method call Completed...
		IF (eStateMethod = E_TrackClientState.Connected) THEN
			// Method call OK
			IF (stUpdateStationBufferData.stOutput.eStatus = E_MMServerStatus.eMMServerStatus_Success) THEN
				// Method returned OK
				stUpdateStationBufferData.iStatus := 2;
			ELSE
				// Method returned with error
				stUpdateStationBufferData.iStatus := 3;
				stUpdateStationBufferData.stOutput.sMessage;
			END_IF
		ELSIF (eStateMethod = E_TrackClientState.Error) THEN
			// Method call failed
			stUpdateStationBufferData.iStatus := 3;
		END_IF
		
	END_IF
ELSE
	M_CallUpdateStationBuffer := -1;
	RETURN;
END_IF

M_CallUpdateStationBuffer := stUpdateStationBufferData.iStatus;	
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_CallUpdateVehicleMappingData" Id="{58eb1d4d-9766-4816-bba9-5e7797d1d67f}">
      <Declaration><![CDATA[METHOD M_CallUpdateVehicleMappingData : INT
VAR_INPUT
	nVehicleID			: UINT;										(* Magnemotion Vehicle ID *)
	sCarrierID			: STRING(30);								(* Carrier ID *)
	bTool				: BOOL;										(*  *)
	sToolID				: STRING(30);								(* Tool ID *)
	bMaterial			: BOOL;										(*  *)
	sMaterialID			: STRING(30);								(* Material ID string *)
END_VAR
VAR
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF (stUpdateVehicleMappingDataData.iStatus = 2) OR (stUpdateVehicleMappingDataData.iStatus = 3) THEN
	stUpdateVehicleMappingDataData.iStatus := 0;
END_IF

IF (bConnectedMethod AND NOT bBusyMethod) THEN
	IF (stUpdateVehicleMappingDataData.iStatus = 0) THEN
	(* Setup method calling parameters *)
		(* Method identifier *)
		sObjectIDentifier := stUpdateVehicleMappingDataData.sObjectID;
		sMethodIdentifier := stUpdateVehicleMappingDataData.sMethodID;
	
		(* Method Inputs *)
		stUpdateVehicleMappingDataData.stInput.nVehicleID := nVehicleID;
		stUpdateVehicleMappingDataData.stInput.sCarrierID := sCarrierID;
		stUpdateVehicleMappingDataData.stInput.bTool := bTool;
		stUpdateVehicleMappingDataData.stInput.sToolID := sToolID;
		stUpdateVehicleMappingDataData.stInput.bMaterial := bMaterial;
		stUpdateVehicleMappingDataData.stInput.sMaterialID := sMaterialID;
		
		(* Fill input data area with method arguments *)
		MEMSET(ADR(aInputData), 0 ,SIZEOF(aInputData));
		nOffset := 0;
		nOffset := nOffset + MEMCPY(ADR(aInputData)+nOffset, ADR(stUpdateVehicleMappingDataData.stInput),	MIN(SIZEOF(stUpdateVehicleMappingDataData.stInput), (SIZEOF(aInputData)-nOffset)) );
		(* Number of input arguments *)
		nNoOfInputArgs := stUpdateVehicleMappingDataData.iNoOfInputArgs;
		(* Set up input argument information *)
		MEMSET(ADR(aInputArgInfo), 0, SIZEOF(aInputArgInfo));
		aInputArgInfo[1].DataType := eUAType_UInt16;
		aInputArgInfo[1].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[1].nLenData := SIZEOF(stUpdateVehicleMappingDataData.stInput.nVehicleID);
		aInputArgInfo[2].DataType := eUAType_String;
		aInputArgInfo[2].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[2].nLenData := SIZEOF(stUpdateVehicleMappingDataData.stInput.sCarrierID);
		aInputArgInfo[3].DataType := eUAType_Boolean;
		aInputArgInfo[3].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[3].nLenData := SIZEOF(stUpdateVehicleMappingDataData.stInput.bTool);
		aInputArgInfo[4].DataType := eUAType_String;
		aInputArgInfo[4].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[4].nLenData := SIZEOF(stUpdateVehicleMappingDataData.stInput.sToolID);
		aInputArgInfo[5].DataType := eUAType_Boolean;
		aInputArgInfo[5].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[5].nLenData := SIZEOF(stUpdateVehicleMappingDataData.stInput.bMaterial);
		aInputArgInfo[6].DataType := eUAType_String;
		aInputArgInfo[6].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[6].nLenData := SIZEOF(stUpdateVehicleMappingDataData.stInput.sMaterialID);
		
		(* Method outputs *)
		(* Clear output data area *)
		(* Number of output arguments *)
		nNoOfOutputArgs := stUpdateVehicleMappingDataData.iNoOfOutputArgs;
		(* Set up output argument information *)
		MEMSET(ADR(aOutputArgInfo), 0, SIZEOF(aOutputArgInfo));
		aOutputArgInfo[1].DataType := eUAType_Uint16;
		aOutputArgInfo[1].ValueRank := -1;
		aOutputArgInfo[1].nLenData := SIZEOF(stUpdateVehicleMappingDataData.stOutput.eStatus);
		aOutputArgInfo[2].DataType := eUAType_String;
		aOutputArgInfo[2].ValueRank := -1;
		aOutputArgInfo[2].nLenData := SIZEOF(stUpdateVehicleMappingDataData.stOutput.sMessage);
		(* Set up output  *)
		MEMSET(ADR(stUpdateVehicleMappingDataData.stOutput), 0, SIZEOF(stUpdateVehicleMappingDataData.stOutput));
		stUpdateVehicleMappingDataData.stOutput.nNumberOfOutputArguments := nNoOfOutputArgs;
		stUpdateVehicleMappingDataData.stOutput.stOutputArgInfo[1] := aOutputArgInfo[1];
		stUpdateVehicleMappingDataData.stOutput.stOutputArgInfo[2] := aOutputArgInfo[2];
	
		(* Execute FB *)
		fbCallMethod.nNumberOfInputArguments := nNoOfInputArgs;
		fbCallMethod.pInputArgInfo := ADR(aInputArgInfo);
		fbCallMethod.cbInputArgInfo := (SIZEOF(aInputArgInfo[1])*nNoOfInputArgs);
		fbCallMethod.pInputArgData := ADR(aInputData);
		fbCallMethod.cbInputArgData := nOffset;
		fbCallMethod.nNumberOfOutputArguments := nNoOfOutputArgs; 
		fbCallMethod.pOutputArgInfo := ADR(aOutputArgInfo); 
		fbCallMethod.cbOutputArgInfo := (SIZEOF(aOutputArgInfo[1]) * nNoOfOutputArgs); 
		fbCallMethod.pOutputArgInfoAndData := ADR(stUpdateVehicleMappingDataData.stOutput);
		fbCallMethod.cbOutputArgInfoAndData := SIZEOF(stUpdateVehicleMappingDataData.stOutput);
		
		stUpdateVehicleMappingDataData.iStatus := 1;
		bCallMethod := TRUE;
		
	ELSIF (stUpdateVehicleMappingDataData.iStatus = 1) THEN
		// Method call Completed...
		IF (eStateMethod = E_TrackClientState.Connected) THEN
			// Method call OK
			IF (stUpdateVehicleMappingDataData.stOutput.eStatus = E_MMServerStatus.eMMServerStatus_Success) THEN
				// Method returned OK
				stUpdateVehicleMappingDataData.iStatus := 2;
				// Trig vehicle data reading because data has changed
				M_VehicleToReadAdd(stUpdateVehicleMappingDataData.stInput.nVehicleID);
				
			ELSE
				// Method returned with error
				stUpdateVehicleMappingDataData.iStatus := 3;
				stUpdateVehicleMappingDataData.stOutput.sMessage;
				
			END_IF
			
		ELSIF (eStateMethod = E_TrackClientState.Error) THEN
			// Method call failed
			stUpdateVehicleMappingDataData.iStatus := 3;
			
		END_IF
		
	END_IF
ELSE
	M_CallUpdateVehicleMappingData := -1;
	RETURN;
	
END_IF

M_CallUpdateVehicleMappingData := stUpdateVehicleMappingDataData.iStatus;	
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_CallUpdateVehicleMontage" Id="{b034f17a-5d35-4c96-9dbf-a079f59588be}">
      <Declaration><![CDATA[METHOD M_CallUpdateVehicleMontage : INT
VAR_INPUT
	nVehicleID			: UINT;										(* Magnemotion Vehicle ID *)
	bTool				: BOOL;										(*  *)
	sToolID				: STRING(30);								(* Tool ID *)
	bMaterial			: BOOL;										(*  *)
	sMaterialID			: STRING(30);								(* Material ID string *)
	bReserved			: BOOL;										(* TRUE signals vehicle is reserved for montage line *)
END_VAR
VAR
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF (stUpdateVehicleMontageData.iStatus = 2) OR (stUpdateVehicleMontageData.iStatus = 3) THEN
	stUpdateVehicleMontageData.iStatus := 0;
END_IF

IF (bConnectedMethod AND NOT bBusyMethod) THEN
	IF (stUpdateVehicleMontageData.iStatus = 0) THEN
	(* Setup method calling parameters *)
		(* Method identifier *)
		sObjectIDentifier := stUpdateVehicleMontageData.sObjectID;
		sMethodIdentifier := stUpdateVehicleMontageData.sMethodID;
	
		(* Method Inputs *)
		stUpdateVehicleMontageData.stInput.eInputType := E_MMVehicleInputType.eMMVehicleInputType_VehicleID;
		stUpdateVehicleMontageData.stInput.sInput := UINT_TO_STRING(nVehicleID);
		stUpdateVehicleMontageData.stInput.bTool := bTool;
		stUpdateVehicleMontageData.stInput.sToolID := sToolID;
		stUpdateVehicleMontageData.stInput.bMaterial := bMaterial;
		stUpdateVehicleMontageData.stInput.sMaterialID := sMaterialID;
		stUpdateVehicleMontageData.stInput.bReserved := bReserved;
		
		(* Fill input data area with method arguments *)
		MEMSET(ADR(aInputData), 0 ,SIZEOF(aInputData));
		nOffset := 0;
		nOffset := nOffset + MEMCPY(ADR(aInputData)+nOffset, ADR(stUpdateVehicleMontageData.stInput),	MIN(SIZEOF(stUpdateVehicleMontageData.stInput), (SIZEOF(aInputData)-nOffset)) );
		(* Number of input arguments *)
		nNoOfInputArgs := stUpdateVehicleMontageData.iNoOfInputArgs;
		(* Set up input argument information *)
		MEMSET(ADR(aInputArgInfo), 0, SIZEOF(aInputArgInfo));
		aInputArgInfo[1].DataType := eUAType_UInt16;
		aInputArgInfo[1].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[1].nLenData := SIZEOF(stUpdateVehicleMontageData.stInput.eInputType);
		aInputArgInfo[2].DataType := eUAType_String;
		aInputArgInfo[2].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[2].nLenData := SIZEOF(stUpdateVehicleMontageData.stInput.sInput);
		aInputArgInfo[3].DataType := eUAType_Boolean;
		aInputArgInfo[3].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[3].nLenData := SIZEOF(stUpdateVehicleMontageData.stInput.bTool);
		aInputArgInfo[4].DataType := eUAType_String;
		aInputArgInfo[4].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[4].nLenData := SIZEOF(stUpdateVehicleMontageData.stInput.sToolID);
		aInputArgInfo[5].DataType := eUAType_Boolean;
		aInputArgInfo[5].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[5].nLenData := SIZEOF(stUpdateVehicleMontageData.stInput.bMaterial);
		aInputArgInfo[6].DataType := eUAType_String;
		aInputArgInfo[6].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[6].nLenData := SIZEOF(stUpdateVehicleMontageData.stInput.sMaterialID);
		aInputArgInfo[7].DataType := eUAType_Boolean;
		aInputArgInfo[7].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[7].nLenData := SIZEOF(stUpdateVehicleMontageData.stInput.bReserved);
		
		(* Method outputs *)
		(* Clear output data area *)
		(* Number of output arguments *)
		nNoOfOutputArgs := stUpdateVehicleMontageData.iNoOfOutputArgs;
		(* Set up output argument information *)
		MEMSET(ADR(aOutputArgInfo), 0, SIZEOF(aOutputArgInfo));
		aOutputArgInfo[1].DataType := eUAType_Uint16;
		aOutputArgInfo[1].ValueRank := -1;
		aOutputArgInfo[1].nLenData := SIZEOF(stUpdateVehicleMontageData.stOutput.eStatus);
		aOutputArgInfo[2].DataType := eUAType_String;
		aOutputArgInfo[2].ValueRank := -1;
		aOutputArgInfo[2].nLenData := SIZEOF(stUpdateVehicleMontageData.stOutput.sMessage);
		(* Set up output  *)
		MEMSET(ADR(stUpdateVehicleMontageData.stOutput), 0, SIZEOF(stUpdateVehicleMontageData.stOutput));
		stUpdateVehicleMontageData.stOutput.nNumberOfOutputArguments := nNoOfOutputArgs;
		stUpdateVehicleMontageData.stOutput.stOutputArgInfo[1] := aOutputArgInfo[1];
		stUpdateVehicleMontageData.stOutput.stOutputArgInfo[2] := aOutputArgInfo[2];
	
		(* Execute FB *)
		fbCallMethod.nNumberOfInputArguments := nNoOfInputArgs;
		fbCallMethod.pInputArgInfo := ADR(aInputArgInfo);
		fbCallMethod.cbInputArgInfo := (SIZEOF(aInputArgInfo[1])*nNoOfInputArgs);
		fbCallMethod.pInputArgData := ADR(aInputData);
		fbCallMethod.cbInputArgData := nOffset;
		fbCallMethod.nNumberOfOutputArguments := nNoOfOutputArgs; 
		fbCallMethod.pOutputArgInfo := ADR(aOutputArgInfo); 
		fbCallMethod.cbOutputArgInfo := (SIZEOF(aOutputArgInfo[1]) * nNoOfOutputArgs); 
		fbCallMethod.pOutputArgInfoAndData := ADR(stUpdateVehicleMontageData.stOutput);
		fbCallMethod.cbOutputArgInfoAndData := SIZEOF(stUpdateVehicleMontageData.stOutput);
		
		stUpdateVehicleMontageData.iStatus := 1;
		bCallMethod := TRUE;
		
	ELSIF (stUpdateVehicleMontageData.iStatus = 1) THEN
		// Method call Completed...
		IF (UINT_TO_STRING(nVehicleID) = stUpdateVehicleMontageData.stInput.sInput) THEN
			IF (eStateMethod = E_TrackClientState.Connected) THEN
				// Method call OK
				IF (stUpdateVehicleMontageData.stOutput.eStatus = E_MMServerStatus.eMMServerStatus_Success) THEN
					// Method returned OK
					stUpdateVehicleMontageData.iStatus := 2;
					// Trig vehicle data reading because data has changed
					M_VehicleToReadAdd(nVehicleID);
									
				ELSE
					// Method returned with error
					stUpdateVehicleMontageData.iStatus := 3;
					stUpdateVehicleMontageData.stOutput.sMessage;
					
				END_IF
				
			ELSIF (eStateMethod = E_TrackClientState.Error) THEN
				// Method call failed
				stUpdateVehicleMontageData.iStatus := 3;
	
			END_IF
		ELSE
			// Wrong vehicle ID
			F_LogLine('TC_VMD: Wrong Vehicle ID (%d)', nVehicleID);
			
		END_IF
	END_IF
ELSE
	M_CallUpdateVehicleMontage := -1;
	RETURN;

END_IF

M_CallUpdateVehicleMontage := stUpdateVehicleMontageData.iStatus;	
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_CallUpdateVehicleOwner" Id="{5b44b485-93bc-45c9-8b6a-282eaee4e001}">
      <Declaration><![CDATA[METHOD PROTECTED M_CallUpdateVehicleOwner : INT
VAR_INPUT
	nVehicleID			: UINT;										(* Magnemotion Vehicle ID *)
	eInputType			: E_MMVehicleInputType;
	sInput				: STRING(30);
	sCellID				: STRING(30);
END_VAR
VAR
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF (stUpdateVehicleOwnerData.iStatus = 2) OR (stUpdateVehicleOwnerData.iStatus = 3) THEN
	stUpdateVehicleOwnerData.iStatus := 0;
END_IF

IF (bConnectedMethod AND NOT bBusyMethod) THEN
	IF (stUpdateVehicleOwnerData.iStatus = 0) THEN
	(* Setup method calling parameters *)
		(* Method identifier *)
		sObjectIDentifier := stUpdateVehicleOwnerData.sObjectID;
		sMethodIdentifier := stUpdateVehicleOwnerData.sMethodID;
	
		(* Method Inputs *)
		stUpdateVehicleOwnerData.stInput.eInputType := eInputType;
		stUpdateVehicleOwnerData.stInput.sInput := sInput;
		stUpdateVehicleOwnerData.stInput.sCellID := sCellID;
		
		(* Fill input data area with method arguments *)
		MEMSET(ADR(aInputData), 0 ,SIZEOF(aInputData));
		nOffset := 0;
		nOffset := nOffset + MEMCPY(ADR(aInputData)+nOffset, ADR(stUpdateVehicleOwnerData.stInput),	MIN(SIZEOF(stUpdateVehicleOwnerData.stInput), (SIZEOF(aInputData)-nOffset)) );
		(* Number of input arguments *)
		nNoOfInputArgs := stUpdateVehicleOwnerData.iNoOfInputArgs;
		(* Set up input argument information *)
		MEMSET(ADR(aInputArgInfo), 0, SIZEOF(aInputArgInfo));
		aInputArgInfo[1].DataType := eUAType_UInt16;
		aInputArgInfo[1].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[1].nLenData := SIZEOF(stUpdateVehicleOwnerData.stInput.eInputType);
		aInputArgInfo[2].DataType := eUAType_String;
		aInputArgInfo[2].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[2].nLenData := SIZEOF(stUpdateVehicleOwnerData.stInput.sInput);
		aInputArgInfo[3].DataType := eUAType_String;
		aInputArgInfo[3].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[3].nLenData := SIZEOF(stUpdateVehicleOwnerData.stInput.sCellID);
		
		(* Method outputs *)
		(* Clear output data area *)
		(* Number of output arguments *)
		nNoOfOutputArgs := stUpdateVehicleOwnerData.iNoOfOutputArgs;
		(* Set up output argument information *)
		MEMSET(ADR(aOutputArgInfo), 0, SIZEOF(aOutputArgInfo));
		aOutputArgInfo[1].DataType := eUAType_Uint16;
		aOutputArgInfo[1].ValueRank := -1;
		aOutputArgInfo[1].nLenData := SIZEOF(stUpdateVehicleOwnerData.stOutput.eStatus);
		aOutputArgInfo[2].DataType := eUAType_String;
		aOutputArgInfo[2].ValueRank := -1;
		aOutputArgInfo[2].nLenData := SIZEOF(stUpdateVehicleOwnerData.stOutput.sMessage);
		(* Set up output  *)
		MEMSET(ADR(stUpdateVehicleOwnerData.stOutput), 0, SIZEOF(stUpdateVehicleOwnerData.stOutput));
		stUpdateVehicleOwnerData.stOutput.nNumberOfOutputArguments := nNoOfOutputArgs;
		stUpdateVehicleOwnerData.stOutput.stOutputArgInfo[1] := aOutputArgInfo[1];
		stUpdateVehicleOwnerData.stOutput.stOutputArgInfo[2] := aOutputArgInfo[2];
	
		(* Execute FB *)
		fbCallMethod.nNumberOfInputArguments := nNoOfInputArgs;
		fbCallMethod.pInputArgInfo := ADR(aInputArgInfo);
		fbCallMethod.cbInputArgInfo := (SIZEOF(aInputArgInfo[1])*nNoOfInputArgs);
		fbCallMethod.pInputArgData := ADR(aInputData);
		fbCallMethod.cbInputArgData := nOffset;
		fbCallMethod.nNumberOfOutputArguments := nNoOfOutputArgs; 
		fbCallMethod.pOutputArgInfo := ADR(aOutputArgInfo); 
		fbCallMethod.cbOutputArgInfo := (SIZEOF(aOutputArgInfo[1]) * nNoOfOutputArgs); 
		fbCallMethod.pOutputArgInfoAndData := ADR(stUpdateVehicleOwnerData.stOutput);
		fbCallMethod.cbOutputArgInfoAndData := SIZEOF(stUpdateVehicleOwnerData.stOutput);
		
		stUpdateVehicleOwnerData.iStatus := 1;
		bCallMethod := TRUE;
		
	ELSIF (stUpdateVehicleOwnerData.iStatus = 1) THEN
		// Method call Completed...
		IF (eStateMethod = E_TrackClientState.Connected) THEN
			// Method call OK
			IF (stUpdateVehicleOwnerData.stOutput.eStatus = E_MMServerStatus.eMMServerStatus_Success) THEN
				// Method returned OK
				stUpdateVehicleOwnerData.iStatus := 2;
				// Trig vehicle data reading because data has changed
				M_VehicleToReadAdd(nVehicleID);
				
			ELSE
				// Method returned with error
				stUpdateVehicleOwnerData.iStatus := 3;
				stUpdateVehicleOwnerData.stOutput.sMessage;

			END_IF
		ELSIF (eStateMethod = E_TrackClientState.Error) THEN
			// Method call failed
			stUpdateVehicleOwnerData.iStatus := 3;

		END_IF
		
	END_IF
ELSE
	M_CallUpdateVehicleOwner := -1;
	RETURN;

END_IF

M_CallUpdateVehicleOwner := stUpdateVehicleOwnerData.iStatus;	
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_CallUpdateVehicleReservationData" Id="{4b57a1ab-f899-4caf-ae31-65d088b92f63}">
      <Declaration><![CDATA[METHOD M_CallUpdateVehicleReservationData : INT
VAR_INPUT
	nVehicleID			: UINT;										(* Magnemotion vehicle ID *)
	sTargetStationID	: STRING(30);								(* Target station ID *)
	sCarrierID			: STRING(30);								(* Carrier ID *)
	sJobID				: STRING(30);								(* Job ID string *)
	nTicket				: UINT;										(* Ticket number *)
	nCarriersInPackage	: UINT;										(* Ticket size *)
	nPriority			: UINT;										(* Ticket priority *)
END_VAR
VAR
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF (stUpdateVehicleReservationDataData.iStatus = 2) OR (stUpdateVehicleReservationDataData.iStatus = 3) THEN
	stUpdateVehicleReservationDataData.iStatus := 0;
END_IF

IF (bConnectedMethod AND NOT bBusyMethod) THEN
	IF (stUpdateVehicleReservationDataData.iStatus = 0) THEN
	(* Setup method calling parameters *)
		(* Method identifier *)
		sObjectIDentifier := stUpdateVehicleReservationDataData.sObjectID;
		sMethodIdentifier := stUpdateVehicleReservationDataData.sMethodID;
	
		(* Method Inputs *)
		stUpdateVehicleReservationDataData.stInput.sTargetStationID := sTargetStationID;
		stUpdateVehicleReservationDataData.stInput.sCarrierID := sCarrierID;
		stUpdateVehicleReservationDataData.stInput.sJobID := sJobID;
		stUpdateVehicleReservationDataData.stInput.nTicket := nTicket;
		stUpdateVehicleReservationDataData.stInput.nCarriersInPackage := nCarriersInPackage;
		stUpdateVehicleReservationDataData.stInput.nPriority := nPriority;
		
		(* Fill input data area with method arguments *)
		MEMSET(ADR(aInputData), 0 ,SIZEOF(aInputData));
		nOffset := 0;
		nOffset := nOffset + MEMCPY(ADR(aInputData)+nOffset, ADR(stUpdateVehicleReservationDataData.stInput),	MIN(SIZEOF(stUpdateVehicleReservationDataData.stInput), (SIZEOF(aInputData)-nOffset)) );
		(* Number of input arguments *)
		nNoOfInputArgs := stUpdateVehicleReservationDataData.iNoOfInputArgs;
		(* Set up input argument information *)
		MEMSET(ADR(aInputArgInfo), 0, SIZEOF(aInputArgInfo));
		aInputArgInfo[1].DataType := eUAType_String;
		aInputArgInfo[1].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[1].nLenData := SIZEOF(stUpdateVehicleReservationDataData.stInput.sTargetStationID);
		aInputArgInfo[2].DataType := eUAType_String;
		aInputArgInfo[2].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[2].nLenData := SIZEOF(stUpdateVehicleReservationDataData.stInput.sCarrierID);
		aInputArgInfo[3].DataType := eUAType_String;
		aInputArgInfo[3].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[3].nLenData := SIZEOF(stUpdateVehicleReservationDataData.stInput.sJobID);
		aInputArgInfo[4].DataType := eUAType_UInt16;
		aInputArgInfo[4].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[4].nLenData := SIZEOF(stUpdateVehicleReservationDataData.stInput.nTicket);
		aInputArgInfo[5].DataType := eUAType_UInt16;
		aInputArgInfo[5].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[5].nLenData := SIZEOF(stUpdateVehicleReservationDataData.stInput.nCarriersInPackage);
		aInputArgInfo[6].DataType := eUAType_UInt16;
		aInputArgInfo[6].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[6].nLenData := SIZEOF(stUpdateVehicleReservationDataData.stInput.nPriority);
		
		(* Method outputs *)
		(* Clear output data area *)
		(* Number of output arguments *)
		nNoOfOutputArgs := stUpdateVehicleReservationDataData.iNoOfOutputArgs;
		(* Set up output argument information *)
		MEMSET(ADR(aOutputArgInfo), 0, SIZEOF(aOutputArgInfo));
		aOutputArgInfo[1].DataType := eUAType_Uint16;
		aOutputArgInfo[1].ValueRank := -1;
		aOutputArgInfo[1].nLenData := SIZEOF(stUpdateVehicleReservationDataData.stOutput.eStatus);
		aOutputArgInfo[2].DataType := eUAType_String;
		aOutputArgInfo[2].ValueRank := -1;
		aOutputArgInfo[2].nLenData := SIZEOF(stUpdateVehicleReservationDataData.stOutput.sMessage);
		(* Set up output  *)
		MEMSET(ADR(stUpdateVehicleReservationDataData.stOutput), 0, SIZEOF(stUpdateVehicleReservationDataData.stOutput));
		stUpdateVehicleReservationDataData.stOutput.nNumberOfOutputArguments := nNoOfOutputArgs;
		stUpdateVehicleReservationDataData.stOutput.stOutputArgInfo[1] := aOutputArgInfo[1];
		stUpdateVehicleReservationDataData.stOutput.stOutputArgInfo[2] := aOutputArgInfo[2];
	
		(* Execute FB *)
		fbCallMethod.nNumberOfInputArguments := nNoOfInputArgs;
		fbCallMethod.pInputArgInfo := ADR(aInputArgInfo);
		fbCallMethod.cbInputArgInfo := (SIZEOF(aInputArgInfo[1])*nNoOfInputArgs);
		fbCallMethod.pInputArgData := ADR(aInputData);
		fbCallMethod.cbInputArgData := nOffset;
		fbCallMethod.nNumberOfOutputArguments := nNoOfOutputArgs; 
		fbCallMethod.pOutputArgInfo := ADR(aOutputArgInfo); 
		fbCallMethod.cbOutputArgInfo := (SIZEOF(aOutputArgInfo[1]) * nNoOfOutputArgs); 
		fbCallMethod.pOutputArgInfoAndData := ADR(stUpdateVehicleReservationDataData.stOutput);
		fbCallMethod.cbOutputArgInfoAndData := SIZEOF(stUpdateVehicleReservationDataData.stOutput);
		
		stUpdateVehicleReservationDataData.iStatus := 1;
		bCallMethod := TRUE;
		
	ELSIF (stUpdateVehicleReservationDataData.iStatus = 1) THEN
		// Method call Completed...
		IF (eStateMethod = E_TrackClientState.Connected) THEN
			// Method call OK
			IF (stUpdateVehicleReservationDataData.stOutput.eStatus = E_MMServerStatus.eMMServerStatus_Success) THEN
				// Method returned OK
				stUpdateVehicleReservationDataData.iStatus := 2;
				// Trig vehicle data reading because data has changed
				M_VehicleToReadAdd(nVehicleID);
				
			ELSE
				// Method returned with error
				stUpdateVehicleReservationDataData.iStatus := 3;
				stUpdateVehicleReservationDataData.stOutput.sMessage;

			END_IF

		ELSIF (eStateMethod = E_TrackClientState.Error) THEN
			// Method call failed
			stUpdateVehicleReservationDataData.iStatus := 3;

		END_IF
		
	END_IF
ELSE
	M_CallUpdateVehicleReservationData := -1;
	RETURN;

END_IF

M_CallUpdateVehicleReservationData := stUpdateVehicleReservationDataData.iStatus;	
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_CallUpdateVehicleReworkData" Id="{35e08d3d-3091-4034-b597-597ed59aaf02}">
      <Declaration><![CDATA[METHOD M_CallUpdateVehicleReworkData : INT
VAR_INPUT
	nVehicleID			: UINT;										(* Magnemotion Vehicle ID *)
	sCarrierID			: STRING(30);								(* Carrier ID *)
	bNOK				: BOOL;										(* TRUE signals that rework is required *)
END_VAR
VAR
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF (stUpdateVehicleReworkDataData.iStatus = 2) OR (stUpdateVehicleReworkDataData.iStatus = 3) THEN
	stUpdateVehicleReworkDataData.iStatus := 0;
END_IF

IF (bConnectedMethod AND NOT bBusyMethod) THEN
	IF (stUpdateVehicleReworkDataData.iStatus = 0) THEN
	(* Setup method calling parameters *)
		(* Method identifier *)
		sObjectIDentifier := stUpdateVehicleReworkDataData.sObjectID;
		sMethodIdentifier := stUpdateVehicleReworkDataData.sMethodID;
	
		(* Method Inputs *)
		stUpdateVehicleReworkDataData.stInput.sCarrierID := sCarrierID;
		stUpdateVehicleReworkDataData.stInput.bNOK := bNOK;
		
		(* Fill input data area with method arguments *)
		MEMSET(ADR(aInputData), 0 ,SIZEOF(aInputData));
		nOffset := 0;
		nOffset := nOffset + MEMCPY(ADR(aInputData)+nOffset, ADR(stUpdateVehicleReworkDataData.stInput),	MIN(SIZEOF(stUpdateVehicleReworkDataData.stInput), (SIZEOF(aInputData)-nOffset)) );
		(* Number of input arguments *)
		nNoOfInputArgs := stUpdateVehicleReworkDataData.iNoOfInputArgs;
		(* Set up input argument information *)
		MEMSET(ADR(aInputArgInfo), 0, SIZEOF(aInputArgInfo));
		aInputArgInfo[1].DataType := eUAType_String;
		aInputArgInfo[1].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[1].nLenData := SIZEOF(stUpdateVehicleReworkDataData.stInput.sCarrierID);
		aInputArgInfo[2].DataType := eUAType_Boolean;
		aInputArgInfo[2].ValueRank := -1;	// -1: Scalar 
		aInputArgInfo[2].nLenData := SIZEOF(stUpdateVehicleReworkDataData.stInput.bNOK);
		
		(* Method outputs *)
		(* Clear output data area *)
		(* Number of output arguments *)
		nNoOfOutputArgs := stUpdateVehicleReworkDataData.iNoOfOutputArgs;
		(* Set up output argument information *)
		MEMSET(ADR(aOutputArgInfo), 0, SIZEOF(aOutputArgInfo));
		aOutputArgInfo[1].DataType := eUAType_Uint16;
		aOutputArgInfo[1].ValueRank := -1;
		aOutputArgInfo[1].nLenData := SIZEOF(stUpdateVehicleReworkDataData.stOutput.eStatus);
		aOutputArgInfo[2].DataType := eUAType_String;
		aOutputArgInfo[2].ValueRank := -1;
		aOutputArgInfo[2].nLenData := SIZEOF(stUpdateVehicleReworkDataData.stOutput.sMessage);
		(* Set up output  *)
		MEMSET(ADR(stUpdateVehicleReworkDataData.stOutput), 0, SIZEOF(stUpdateVehicleReworkDataData.stOutput));
		stUpdateVehicleReworkDataData.stOutput.nNumberOfOutputArguments := nNoOfOutputArgs;
		stUpdateVehicleReworkDataData.stOutput.stOutputArgInfo[1] := aOutputArgInfo[1];
		stUpdateVehicleReworkDataData.stOutput.stOutputArgInfo[2] := aOutputArgInfo[2];
	
		(* Execute FB *)
		fbCallMethod.nNumberOfInputArguments := nNoOfInputArgs;
		fbCallMethod.pInputArgInfo := ADR(aInputArgInfo);
		fbCallMethod.cbInputArgInfo := (SIZEOF(aInputArgInfo[1])*nNoOfInputArgs);
		fbCallMethod.pInputArgData := ADR(aInputData);
		fbCallMethod.cbInputArgData := nOffset;
		fbCallMethod.nNumberOfOutputArguments := nNoOfOutputArgs; 
		fbCallMethod.pOutputArgInfo := ADR(aOutputArgInfo); 
		fbCallMethod.cbOutputArgInfo := (SIZEOF(aOutputArgInfo[1]) * nNoOfOutputArgs); 
		fbCallMethod.pOutputArgInfoAndData := ADR(stUpdateVehicleReworkDataData.stOutput);
		fbCallMethod.cbOutputArgInfoAndData := SIZEOF(stUpdateVehicleReworkDataData.stOutput);
		
		stUpdateVehicleReworkDataData.iStatus := 1;
		bCallMethod := TRUE;
		
	ELSIF (stUpdateVehicleReworkDataData.iStatus = 1) THEN
		// Method call Completed...
		IF (eStateMethod = E_TrackClientState.Connected) THEN
			// Method call OK
			IF (stUpdateVehicleReworkDataData.stOutput.eStatus = E_MMServerStatus.eMMServerStatus_Success) THEN
				// Method returned OK
				stUpdateVehicleReworkDataData.iStatus := 2;
				// Trig vehicle data reading because data has changed
				M_VehicleToReadAdd(nVehicleID);
								
			ELSE
				// Method returned with error
				stUpdateVehicleReworkDataData.iStatus := 3;
				stUpdateVehicleReworkDataData.stOutput.sMessage;
				
			END_IF
			
		ELSIF (eStateMethod = E_TrackClientState.Error) THEN
			// Method call failed
			stUpdateVehicleReworkDataData.iStatus := 3;

		END_IF
		
	END_IF
ELSE
	M_CallUpdateVehicleReworkData := -1;
	RETURN;

END_IF

M_CallUpdateVehicleReworkData := stUpdateVehicleReworkDataData.iStatus;	
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_CarrierIDToVehicleID" Id="{08a565de-8270-4e6c-be7d-d28b35e5c0e0}">
      <Declaration><![CDATA[METHOD PROTECTED M_CarrierIDToVehicleID : UINT
VAR_INPUT
	sCarrierID		: STRING(30);
END_VAR

VAR
	i: INT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[
// Find vehicle with specified Carrier ID
FOR i := 1 TO MM_MAX_NUMBER_OF_VEHICLE_ELEMENTS BY 1 DO
	IF (aReadVehicleData[i].stVehicle.bDataValid) THEN
		IF (F_StringCompNoCase(aReadVehicleData[i].stVehicle.sCarrierID, sCarrierID) ) THEN
			M_CarrierIDToVehicleID := aReadVehicleData[i].stVehicle.nVehicleID;
			RETURN;
		END_IF
	END_IF
END_FOR

// Not found!
M_CarrierIDToVehicleID := 0;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_CheckStationIndex" Id="{17b0b2e4-1e13-461c-9a9f-fc544d74087a}">
      <Declaration><![CDATA[/// Check if a specified station index belongs to this cell
METHOD PROTECTED M_CheckStationIndex : BOOL
VAR_INPUT
	iStationNo		: UINT;
END_VAR
VAR
	i				: UINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
FOR i := 1 TO 5 BY 1 DO
	IF (aStations[i].bPresent) THEN
		IF (iThisStationIndex[i] = iStationNo) THEN
			// Station index found
			M_CheckStationIndex := TRUE;
			RETURN;			
		END_IF
	END_IF
END_FOR

// Not found
M_CheckStationIndex := FALSE;
RETURN;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_CheckStationsRead" Id="{c0200038-6928-4202-b86b-98923d328126}">
      <Declaration><![CDATA[/// Check if indexes are found for all specified stations
METHOD PROTECTED M_CheckStationsRead : BOOL
VAR
	i				: UINT;
	bReturn			: BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
bReturn := TRUE;

FOR i := 1 TO 5 BY 1 DO
	IF (aStations[i].bPresent) THEN
		IF (iThisStationIndex[i] > 0) THEN
			// Station index found
		ELSE
			// Index for this station is not found!
			bReturn := FALSE;
			EXIT;
		END_IF
	END_IF
END_FOR

// Not found
M_CheckStationsRead := bReturn;
RETURN;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_CheckVehicleEventRead" Id="{afde6db3-8165-4ca2-bc1e-cfee91df1de6}">
      <Declaration><![CDATA[/// Check if specified vehicle is Owned by this cell and is to be read (evet-driven reading)
METHOD PROTECTED M_CheckVehicleEventRead : BOOL
VAR_INPUT
	iVehicleNo		: UINT;		// MagneMotion Vehicle number
END_VAR
VAR
	i				: UINT;
	bVehicleOwned	: BOOL;
	bVehicleDoRead	: BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
FOR i := 1 TO MM_MAX_NUMBER_OF_VEHICLE_ELEMENTS BY 1 DO
	IF (anVehiclesToRead[i] = iVehicleNo) THEN
		// Vehicle is found in to-read list
		M_CheckVehicleEventRead := TRUE;
		RETURN;
	END_IF

END_FOR

// Not found
M_CheckVehicleEventRead := FALSE;
RETURN;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_CheckVehicleOwned" Id="{e41741fc-4227-442f-b07b-3e2869eddce6}">
      <Declaration><![CDATA[/// Check if specified vehicle is Owned by this cell
METHOD PROTECTED M_CheckVehicleOwned : BOOL
VAR_INPUT
	iVehicleNo		: UINT;		// MagneMotion Vehicle number
END_VAR
VAR
	i				: UINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
FOR i := 1 TO MM_MAX_NUMBER_OF_VEHICLE_ELEMENTS BY 1 DO
	IF (aReadCellData.stCell.anVehicles[i] = iVehicleNo) THEN
		// Vehicle is found
		M_CheckVehicleOwned := TRUE;
		RETURN;
	END_IF
END_FOR

// Not found
M_CheckVehicleOwned := FALSE;
RETURN;
           ]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_CheckVehicleSurvail" Id="{57a1d781-5991-4c44-834a-d4fcef59c758}">
      <Declaration><![CDATA[/// Check if specified vehicle is survailed by this cell
METHOD PROTECTED M_CheckVehicleSurvail : BOOL
VAR_INPUT
	iVehicleNo		: UINT;		// MagneMotion Vehicle number
END_VAR
VAR
	i				: UINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
FOR i := 1 TO MM_MAX_NUMBER_OF_VEHICLE_ELEMENTS BY 1 DO
	IF (anExtraVehicles[i] = iVehicleNo) THEN
		// Vehicle is found
		M_CheckVehicleSurvail := TRUE;
		RETURN;
	END_IF
END_FOR

// Not found
M_CheckVehicleSurvail := FALSE;
RETURN;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_ClearAll" Id="{39d6c25d-bfba-40b0-9d86-85672d6eb51a}">
      <Declaration><![CDATA[METHOD M_ClearAll : BOOL
VAR_INPUT
END_VAR
VAR
	i	: UINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
//Clear data on station(s)
FOR i:=1 TO 5 DO
	IF aStations[i].bPresent THEN
		// Station data
		aStations[i].stStationData1.nTicket := 0;
		aStations[i].stStationData1.nTicketSize := 0;
		aStations[i].stStationData1.CurrentPriority := 0;
		aStations[i].stStationData1.nCurrentVehicleID := 0;
		aStations[i].stStationData1.nReservedVehicleID := 0;
		aStations[i].stStationData2.nTicket := 0;
		aStations[i].stStationData2.nTicketSize := 0;
		aStations[i].stStationData2.CurrentPriority := 0;
		aStations[i].stStationData2.nCurrentVehicleID := 0;
		aStations[i].stStationData2.nReservedVehicleID := 0;
		
		// Station in/output
		bReadyStationIn[i] := FALSE;
		bReadyStationOut[i] := FALSE;

	END_IF
END_FOR

M_ClearAll := TRUE;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_CommandData" Id="{904b5ce0-46cc-4181-91bc-a3e47c4bbb8c}">
      <Declaration><![CDATA[METHOD PROTECTED M_CommandData
VAR_INPUT
END_VAR
VAR
	i			: USINT;
	iRes		: UINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Handle the command data from OPC UA (stCommand)

CASE eCommandDataState OF
	// Init state
	E_CommandDataState.Undefined:
		eCommandDataState := E_CommandDataState.CheckRequest;		

	// Check command data request
	E_CommandDataState.CheckRequest:
		IF ((stCommand.ChangeRequest <> stStatus.ChangeStatus) AND (stCommand.ChangeRequest > 0)) THEN
			// Check if changes is allowed on mapping data (from LC)
			IF (stAdditionalDataIn.MESHandShakes.DataChangeStatusTransportStatus = stStatus.DataChange) THEN
// NOTE: Changed to match new LC software!!! - Hack!				
//				stStatus.ChangeAcknowledge := stCommand.ChangeRequest;
//				stStatus.DataChange := stStatus.DataChange + 1;
			
				// Find vehicle ID for specified Carrier ID
				iCommandDataVehicleID := M_CarrierIDToVehicleID(stCommand.CarrierID);
				IF ((iCommandDataVehicleID > 0) AND (iCommandDataVehicleID <= MM_MAX_NUMBER_OF_VEHICLE_ELEMENTS)) THEN
					// Specified vehicle found
					IF (F_StringCompNoCase(aReadVehicleData[iCommandDataVehicleID].stVehicle.sOwnerCell, sCellID)) THEN
						// Vehicle belongs to this cell
						stStatus.ValidRequest := TRUE;
						IF (stCommand.Ticket <= 0) THEN
							// Clear reservation data for this carrier (do not add reservation)
							eCommandDataState := E_CommandDataState.UpdateJobData;
						ELSE
							// Add reservation to track server
							eCommandDataState := E_CommandDataState.AddReservation;
						END_IF
					ELSE
						eCommandDataState := E_CommandDataState.Error;
					END_IF
				ELSE
					eCommandDataState := E_CommandDataState.Error;
				END_IF
			END_IF
		END_IF
		
	E_CommandDataState.AddReservation:
		iRes := M_CallAddReservation(	sStationID := stCommand.TargetStation,
										sCarrierID := stCommand.CarrierID,
										nTicket := stCommand.Ticket,
										nTicketSize := stCommand.CarriersInPackage,
										nPriority := stCommand.Priority 	);
		IF (iRes = 2) THEN
			// Success
			eCommandDataState := E_CommandDataState.UpdateJobData;
		ELSIF (iRes = 3) THEN
			// Error!
			F_LogLine('ERROR: AddReservation (Ticket: %d)', stCommand.Ticket);
			eCommandDataState := E_CommandDataState.Error;
		END_IF
	
	E_CommandDataState.UpdateJobData:
		iRes := M_CallUpdateVehicleReservationData(	nVehicleID := iCommandDataVehicleID,
													sTargetStationID := stCommand.TargetStation,
													sCarrierID := stCommand.CarrierID,
													nTicket := stCommand.Ticket,
													nCarriersInPackage := stCommand.CarriersInPackage,
													nPriority := stCommand.Priority,
													sJobID := stCommand.JobID 	);
		IF (iRes = 2) THEN
			// Success
			eCommandDataState := E_CommandDataState.Done;
		ELSIF (iRes = 3) THEN
			// Error!
			F_LogLine('ERROR: UpdateJobData (Ticket: %d)', stCommand.Ticket);
			eCommandDataState := E_CommandDataState.Error;
		END_IF
	
	E_CommandDataState.Done:
		stStatus.LatestTicket := stCommand.Ticket;
		stStatus.NumberOfCarriers := stCommand.CarriersInPackage;
		stStatus.ChangeStatus := stCommand.ChangeRequest;
// NOTE: Changed to match new LC software!!! - Hack!				
		stStatus.ChangeAcknowledge := stCommand.ChangeRequest;
		stStatus.DataChange := stStatus.DataChange + 1;
		eCommandDataState := E_CommandDataState.Undefined;
		
	E_CommandDataState.Error:
		stStatus.ValidRequest := FALSE;
		stStatus.ChangeStatus := stCommand.ChangeRequest;
// NOTE: Changed to match new LC software!!! - Hack!				
		stStatus.ChangeAcknowledge := stCommand.ChangeRequest;
		stStatus.DataChange := stStatus.DataChange + 1;
		eCommandDataState := E_CommandDataState.Undefined;
		
END_CASE
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_CopyAndClearBufferData" Id="{be8b5ba0-b2c5-4458-931a-caaad8c7d2d1}">
      <Declaration><![CDATA[/// Copy vehicle and ticket information from Source to Target and DELETES information on Source!!
METHOD PROTECTED M_CopyAndClearBufferData : BOOL
VAR_IN_OUT
	stSource		: ST_MMBuffer;
	stTarget		: ST_MMBuffer;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
	// Update data for target location
	stTarget.nTicket := stSource.nTicket;
	stTarget.nTicketSize := stSource.nTicketSize;
	stTarget.CurrentPriority := stSource.CurrentPriority;
	stTarget.nReservedVehicleID := stSource.nReservedVehicleID;
	stTarget.nCurrentVehicleID := stSource.nCurrentVehicleID;
	// Clear data for source location
	stSource.nTicket := 0;
	stSource.nTicketSize := 0;
	stSource.CurrentPriority := 0;
	stSource.nCurrentVehicleID := 0;
	stSource.nReservedVehicleID := 0;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_CopyBufferData" Id="{d04f8618-5494-4b8a-a309-80314dd3e340}">
      <Declaration><![CDATA[/// Copy vehicle and ticket information from Source to Target and DELETES information on Source!!
METHOD PROTECTED M_CopyBufferData : BOOL
VAR_IN_OUT
	stSource		: ST_MMBuffer;
	stTarget		: ST_MMBuffer;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
	// Update data for target location
	stTarget.nTicket := stSource.nTicket;
	stTarget.nTicketSize := stSource.nTicketSize;
	stTarget.CurrentPriority := stSource.CurrentPriority;
	stTarget.nReservedVehicleID := stSource.nReservedVehicleID;
	stTarget.nCurrentVehicleID := stSource.nCurrentVehicleID;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_DefinePath" Id="{d6dd8c8b-6c7e-4e6e-a2ed-ce346467b26a}">
      <Declaration><![CDATA[// Set path to control from this cell
METHOD PUBLIC M_DefinePath : BOOL
VAR_INPUT
	nPathNo				: UINT;		// Path number
END_VAR
VAR
	i					: UINT;
	bFound				: BOOL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[
bFound := FALSE;

IF ( (nPathNo > 0) AND (nPathNo <= MM_MAX_NUMBER_OF_PATH_ELEMENTS) ) THEN
	FOR i := 1 TO MM_MAX_NUMBER_OF_PATH_ELEMENTS BY 1 DO
		IF (aPaths[i] = nPathNo) THEN
			// Same path found
			IF (bFound) THEN
				// Already added to list, but found again, delete old value
				aPaths[i] := 0;
			END_IF
			bFound := TRUE;
		ELSIF ( (aPaths[i] = 0) AND NOT bFound ) THEN
			// Free spot found, assign value
			aPaths[i] := nPathNo;
			bFound := TRUE;
		END_IF
	END_FOR
END_IF

M_DefinePath := bFound;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_DefinePathSegment" Id="{ef3e9644-bd4c-4eb5-b126-cc812d729970}">
      <Declaration><![CDATA[METHOD PUBLIC M_DefinePathSegment : BOOL
VAR_INPUT
	nPathSegmentNo	: UINT;
	nPathID			: UINT;		// Path number
	rPositionBegin	: REAL;		// Distance on the specified path to begin segment
	rPositionEnd	: REAL;		// Distance on the specified path to end segment
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Check if data is valid
IF ( (nPathID > 0) AND (rPositionBegin >= 0.0) AND (rPositionEnd > rPositionBegin) ) THEN
	IF (nPathSegmentNo = 1) THEN
		stExitPointSeg1LocBegin.nPathID := nPathID;
		stExitPointSeg1LocBegin.fPosition := rPositionBegin;
		stExitPointSeg1LocEnd.nPathID := nPathID;
		stExitPointSeg1LocEnd.fPosition := rPositionEnd;
		M_DefinePathSegment := TRUE;
		
	ELSIF (nPathSegmentNo = 2) THEN
		stExitPointSeg2LocBegin.nPathID := nPathID;
		stExitPointSeg2LocBegin.fPosition := rPositionBegin;
		stExitPointSeg2LocEnd.nPathID := nPathID;
		stExitPointSeg2LocEnd.fPosition := rPositionEnd;
		M_DefinePathSegment := TRUE;
		
	ELSE
		M_DefinePathSegment := FALSE;
		
	END_IF

ELSE
	M_DefinePathSegment := FALSE;
	
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_DefineStation" Id="{9ef508f7-a4c4-48b8-8a54-b8a3b8faf0f2}">
      <Declaration><![CDATA[// Set data for traffic light
METHOD PUBLIC M_DefineStation : BOOL
VAR_INPUT
	nStationNo			: UINT(1..5);
	sStationID			: STRING(30);
	nLoc1PathID			: UINT;		// Path number for input location
	rLoc1Position		: REAL;		// Distance on the specified path for input location
	nLoc2PathID			: UINT;		// Path number for output location (0 if single station)
	rLoc2Position		: REAL;		// Distance on the specified path for output location (0.0 if single station)
	nLocDecPathID		: UINT;		// Path number for decision point location
	rLocDecPosition		: REAL;		// Distance on the specified path for decision point location
	nPreBufferSize		: UINT;		// Size of pre buffer (number of positions)
	nPostBufferSize		: UINT;		// Size of post buffer (number of positions)
END_VAR
VAR
	i					: UINT;
	bReInit				: BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF ( (nLoc1PathID > 0) AND (rLoc1Position >= 0.0) AND
//	 (nLoc2PathID > 0) AND (rLoc2Position >= 0.0) AND	// Allow single position stations!
	 (nLocDecPathID > 0) AND (rLocDecPosition >= 0.0) AND 
	 (nStationNo >= 1) AND (nStationNo <= 5) AND
	 (sStationID <> '') ) THEN
	
	IF ( (aStations[nStationNo].sStationID <> sStationID) OR
		 (aStations[nStationNo].stStationData1.stLocation.nPathID <> nLoc1PathID) OR
		 (aStations[nStationNo].stStationData1.stLocation.fPosition <> rLoc1Position) OR
		 (aStations[nStationNo].stStationData2.stLocation.nPathID <> nLoc2PathID) OR
		 (aStations[nStationNo].stStationData2.stLocation.fPosition <> rLoc2Position) OR
		 (aStations[nStationNo].stDecisionLocation.nPathID <> nLocDecPathID) OR
		 (aStations[nStationNo].stDecisionLocation.fPosition <> rLocDecPosition) OR
		 (aStations[nStationNo].bPresent = FALSE) ) THEN
		
		bReInit := TRUE;
	END_IF

	aStations[nStationNo].sStationID := sStationID;
	aStations[nStationNo].stStationData1.stLocation.nPathID := nLoc1PathID;
	aStations[nStationNo].stStationData1.stLocation.fPosition := rLoc1Position;
	IF (nLoc1PathID > 0) THEN
		aStations[nStationNo].stStationData1.bPresent := TRUE;
	ELSE
		aStations[nStationNo].stStationData1.bPresent := FALSE;		
	END_IF
	aStations[nStationNo].stStationData2.stLocation.nPathID := nLoc2PathID;
	aStations[nStationNo].stStationData2.stLocation.fPosition := rLoc2Position;
	IF (nLoc2PathID > 0) THEN
		aStations[nStationNo].stStationData2.bPresent := TRUE;
	ELSE
		aStations[nStationNo].stStationData2.bPresent := FALSE;		
	END_IF
	aStations[nStationNo].stDecisionLocation.nPathID := nLocDecPathID;
	aStations[nStationNo].stDecisionLocation.fPosition := rLocDecPosition;

	// Buffers	
	FOR i := 1 TO MM_MAX_BUFFER_INDEX BY 1 DO
		IF ( (aStations[nStationNo].astPreBuffer[i].bPresent <> (i <= nPreBufferSize)) OR
			 (aStations[nStationNo].astPostBuffer[i].bPresent <> (i <= nPostBufferSize)) ) THEN
			bReInit := TRUE;
		END_IF
		aStations[nStationNo].astPreBuffer[i].bPresent := (i <= nPreBufferSize);
		aStations[nStationNo].astPostBuffer[i].bPresent := (i <= nPostBufferSize);
	END_FOR
	aStations[nStationNo].bPresent := TRUE;
	
	M_DefineStation := TRUE;
ELSE
	M_DefineStation := FALSE;
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_DefineStationBufferAdjust" Id="{ea76cb0a-33c6-400e-83de-2b7df949d5d7}">
      <Declaration><![CDATA[// Set data for traffic light
METHOD PUBLIC M_DefineStationBufferAdjust : BOOL
VAR_INPUT
	nStationNo			: UINT(1..5);
	rPreBufferAdjust	: REAL;		// Distance to adjust pre-buffer position (M) - Should be negative for pre-buffer
	rPostBufferAdjust	: REAL;		// Distance to adjust post-buffer position (M) - Should be negative for pre-buffer
END_VAR
VAR
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF ( (nStationNo > 0) AND (nStationNo <= 5) ) THEN
	IF (aStations[nStationNo].bPresent) THEN
		// Station defined
		aStationPreBufAdj[nStationNo] := rPreBufferAdjust;
		aStationPostBufAdj[nStationNo] := rPostBufferAdjust;
		M_DefineStationBufferAdjust := TRUE;
	ELSE
		// Station not defined
		M_DefineStationBufferAdjust := FALSE;
	END_IF
ELSE
	// Outside range
	M_DefineStationBufferAdjust := FALSE;
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_DefineTrafficLight" Id="{e9787981-10aa-43a3-953d-e2259c325ef5}">
      <Declaration><![CDATA[// Set data for traffic light
METHOD PUBLIC M_DefineTrafficLight : BOOL
VAR_INPUT
	nTrafficLightNo	: UINT;
	nPathID			: UINT;		// Path number
	rPosition		: REAL;		// Distance on the specified path
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
IF ((nTrafficLightNo > 0) AND (nPathID > 0) AND (rPosition >= 0.0)) THEN
	IF (nTrafficLightNo = 1) THEN
		stTrafficLightLocation.nPathID := nPathID;
		stTrafficLightLocation.fPosition := rPosition;
		M_DefineTrafficLight := TRUE;

	ELSIF (nTrafficLightNo = 2) THEN
		stTrafficLight2Location.nPathID := nPathID;
		stTrafficLight2Location.fPosition := rPosition;
		M_DefineTrafficLight := TRUE;

	ELSE
		M_DefineTrafficLight := FALSE;
		
	END_IF
ELSE
	M_DefineTrafficLight := FALSE;
	
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_EnableStation" Id="{9438130a-40b8-466a-b73c-7eeb3aec0a92}">
      <Declaration><![CDATA[// Set data for enable/disable station
METHOD PUBLIC M_EnableStation : BOOL
VAR_INPUT
	nStationNo			: UINT(1..5);
	bPresent			: BOOL;
END_VAR
VAR
	i					: UINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF (nStationNo <= 5) THEN
	aStations[nStationNo].bPresent := bPresent;
	
	M_EnableStation := TRUE;
ELSE
	M_EnableStation := FALSE;
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_ErrorWarning" Id="{06aa7e66-21cb-4c9d-b9a5-322fe9803221}">
      <Declaration><![CDATA[METHOD PROTECTED M_ErrorWarning
VAR_INPUT
END_VAR
VAR
	bDataChange:BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
bDataChange S= 
M_ErrorWarningObj(arErrorWaringData:= stErrorWarning.ErrorWarningData,
	bActive:= eTrackState = E_TrackState.Error, 
	iErrorWarningType:= 2, 
	diErrorWarningID:= E_AlarmCategory.TrackClient + 0, 
	sDeviceID:= 'Track Client',
	iSeverity:= 2, 
	iNativeID:= 0, 
	sNativeMessage:= 'Error State Machine');
	
bDataChange S= 
M_ErrorWarningObj(arErrorWaringData:= stErrorWarning.ErrorWarningData,
	bActive:= eStateMethod = E_TrackState.Error, 
	iErrorWarningType:= 2, 
	diErrorWarningID:= E_AlarmCategory.TrackClient + 1, 
	sDeviceID:= 'Track Client',
	iSeverity:= 2, 
	iNativeID:= 0, 
	sNativeMessage:= 'Error State Machine Method');
	
bDataChange S= 
M_ErrorWarningObj(arErrorWaringData:= stErrorWarning.ErrorWarningData,
	bActive:= eStateNode = E_TrackState.Error, 
	iErrorWarningType:= 2, 
	diErrorWarningID:= E_AlarmCategory.TrackClient + 2, 
	sDeviceID:= 'Track Client',
	iSeverity:= 2, 
	iNativeID:= 0, 
	sNativeMessage:= 'Error State Machine Node ADS');


stErrorWarning.DataChange := stErrorWarning.DataChange + TO_UINT(bDataChange);
bDataChange := FALSE;]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_ErrorWarningObj" Id="{97ecedeb-8310-4597-8db4-64c05fc8f0bf}">
      <Declaration><![CDATA[METHOD M_ErrorWarningObj : BOOL
VAR_INPUT
	bActive				: BOOL;
	iErrorWarningType	: UINT;
	diErrorWarningID 	: UDINT;
	sDeviceID			: STRING(30);
	iSeverity			: UINT;
	iNativeID			: UDINT;
	sNativeMessage		: STRING(80);
END_VAR
VAR_IN_OUT
	arErrorWaringData	: ARRAY [1..255] OF ST_ErrorWarningDataX;
END_VAR
VAR
	iFoundPos			: UINT;
	i					: UINT;
	j					: UINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[//Look through array to find existing record(s)
FOR i := 1 TO 255 DO
	IF arErrorWaringData[i].ErrorWarningID = 0 THEN
		EXIT;
	END_IF
	//Existing alarm - first
	IF arErrorWaringData[i].ErrorWarningID = diErrorWarningID AND iFoundPos = 0 THEN
		iFoundPos := i;
	//Multiple records - delete
	ELSIF arErrorWaringData[i].ErrorWarningID = diErrorWarningID AND iFoundPos <> 0 THEN
		MEMSET(ADR(arErrorWaringData[i]), 0, SIZEOF(arErrorWaringData[i]));
		M_ErrorWarningObj := TRUE;
	END_IF
END_FOR

//Alarm high
IF bActive THEN
	//New alarm
	IF iFoundPos = 0 THEN
		arErrorWaringData[i].ErrorWarningType := iErrorWarningType;
		arErrorWaringData[i].DeviceID := sDeviceID;
		arErrorWaringData[i].Severity := iSeverity;
		arErrorWaringData[i].NativeID := iNativeID;
		arErrorWaringData[i].NativeMessage := sNativeMessage;
		arErrorWaringData[i].ErrorWarningID := diErrorWarningID;
		arErrorWaringData[i].DateTime := SYSTEMTIME_TO_STRING(fbGetTime.TIMESTR);
		M_ErrorWarningObj := TRUE;
	END_IF
	
//Alarm low
ELSIF NOT bActive AND iFoundPos <> 0 THEN
	MEMSET(ADR(arErrorWaringData[iFoundPos]), 0, SIZEOF(arErrorWaringData[iFoundPos]));
	M_ErrorWarningObj := TRUE;
END_IF

//Defrag
IF M_ErrorWarningObj THEN
	FOR i:= 1 TO 254 DO
		//Find first empty spot
		IF arErrorWaringData[i].ErrorWarningID = 0 THEN
			//Find first record
			FOR j:= i TO 255 DO
				IF arErrorWaringData[j].ErrorWarningID <> 0 THEN
					//Move to empty spot
					arErrorWaringData[i] := arErrorWaringData[j];
					MEMSET(ADR(arErrorWaringData[j]), 0, SIZEOF(arErrorWaringData[j]));
					EXIT;
				END_IF
			END_FOR
		END_IF
		//No more records
		IF j >= 255 THEN
			RETURN;
		END_IF
	END_FOR
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_ExtraVehicleAdd" Id="{52fed8e5-609f-420b-b891-df588ae939ad}">
      <Declaration><![CDATA[/// Add vehicle to be survailed
METHOD PROTECTED M_ExtraVehicleAdd : BOOL
VAR_INPUT
	iVehicleNo		: UINT;
END_VAR
VAR
	i				: UINT;
	bAdded			: BOOL;
	bRemoved		: BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
FOR i := 1 TO MM_MAX_NUMBER_OF_VEHICLE_ELEMENTS BY 1 DO
	// Check if already excists in list
	IF (anExtraVehicles[i] = iVehicleNo) THEN
		anExtraVehicles[i] := 0;
		bRemoved := TRUE;
	END_IF
	// Add to list
	IF ( (NOT bAdded) AND (anExtraVehicles[i] = 0) ) THEN
		anExtraVehicles[i] := iVehicleNo;
		bAdded := TRUE;
	END_IF
	// Check if finished
	IF (bAdded AND bRemoved) THEN
		M_ExtraVehicleAdd := TRUE;
		RETURN;
	END_IF
	
END_FOR

IF (bAdded) THEN
	// Added
	M_ExtraVehicleAdd := TRUE;
	RETURN;
ELSE
	// NOT Added (list is maybe full!)
	M_ExtraVehicleAdd := FALSE;
	RETURN;	
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_ExtraVehicleRemove" Id="{488ac611-b893-4238-ba10-e6edae0f29b1}">
      <Declaration><![CDATA[/// Remove vehicle from surveillance list
METHOD PROTECTED M_ExtraVehicleRemove : BOOL
VAR_INPUT
	iVehicleNo		: UINT;
END_VAR
VAR
	i				: UINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
FOR i := 1 TO MM_MAX_NUMBER_OF_VEHICLE_ELEMENTS BY 1 DO
	IF (anExtraVehicles[i] = iVehicleNo) THEN
		anExtraVehicles[i] := 0;
		M_ExtraVehicleRemove := TRUE;
		RETURN;
	END_IF
END_FOR

// Not found
M_ExtraVehicleRemove := FALSE;
RETURN;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_Init" Id="{1750c38c-e1c3-435a-a405-b6117cd09d25}">
      <Declaration><![CDATA[METHOD PROTECTED M_Init : BOOL
VAR_INPUT
END_VAR
VAR
	i : UINT;
	sTemp : STRING;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF (NOT bInitDone) THEN
// Client information to stations
	FOR i := 1 TO 5 BY 1 DO
		aStations[i].sCellID := sCellID;
	END_FOR

// OPC UA Method calling information
	(* Use no encryption *)
	stConnectInfoMethod.eSecurityMode 			:= eUASecurityMsgMode_None;
	(*  *)
	stConnectInfoMethod.eSecurityPolicyUri		:= eUASecurityPolicy_None;
	(* USe TCP transport profile *)
	stConnectInfoMethod.eTransportProfileUri	:= eUATransportProfileUri_UATcp;
	(* Application name *)
	stConnectInfoMethod.sApplicationName		:= '';
	(* Connection timeout *)
	stConnectInfoMethod.tConnectTimeout			:= T#1M;
	(* Session timeout *)
	stConnectInfoMethod.tSessionTimeout			:= T#10M;
	(* Method node ID *)
	stObjectNodeID.eIdentifierType				:= E_UAIdentifierType.eUAIdentifierType_String;
	stMethodNodeID.eIdentifierType				:= E_UAIdentifierType.eUAIdentifierType_String;
	(* Method data *)
	M_InitMethodData();
	
// OPC UA Node reading information
	(* Use no encryption *)
	stConnectInfoNodes.eSecurityMode 			:= eUASecurityMsgMode_None;
	(*  *)
	stConnectInfoNodes.eSecurityPolicyUri		:= eUASecurityPolicy_None;
	(* USe TCP transport profile *)
	stConnectInfoNodes.eTransportProfileUri		:= eUATransportProfileUri_UATcp;
	(* Application name *)
	stConnectInfoNodes.sApplicationName			:= '';
	(* Connection timeout *)
	stConnectInfoNodes.tConnectTimeout			:= T#1M;
	(* Session timeout *)
	stConnectInfoNodes.tSessionTimeout			:= T#10M;

	
	bInitDone := TRUE;
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_InitMethodData" Id="{19ca9e8b-89b7-47f8-a1cd-d258530813a4}">
      <Declaration><![CDATA[METHOD PROTECTED M_InitMethodData : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
(* Method data *)
stAddStationDoubleData.iStatus				:= 0;
stAddStationSingleData.iStatus				:= 0;
stEnableStationData.iStatus					:= 0;
stRemoveStationData.iStatus					:= 0;

stGetCellIndexData.iStatus					:= 0;

stAddPathData.iStatus						:= 0;
stRemovePathData.iStatus					:= 0;
stStartPathData.iStatus						:= 0;
stResetPathData.iStatus						:= 0;
stSuspendPathData.iStatus					:= 0;
stResumePathData.iStatus					:= 0;

stAddTrafficLightData.iStatus				:= 0;
stRemoveTrafficLightData.iStatus			:= 0;
stTrafficLightColorData.iStatus				:= 0;
stSetTrafficLightColorData.iStatus			:= 0;

stMoveToStationInData.iStatus				:= 0;
stMoveToStationOutData.iStatus				:= 0;
stMoveToPositionData.iStatus				:= 0;
stMoveToBufferData.iStatus					:= 0;
stMoveToDecisionPointData.iStatus			:= 0;
stMoveToScannerData.iStatus					:= 0;

//stUpdateVehicleDataData.iStatus			:= 0;
stUpdateVehicleReservationDataData.iStatus	:= 0;
stUpdateVehicleMappingDataData.iStatus		:= 0;
stUpdateVehicleReworkDataData.iStatus		:= 0;

]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_InitNodeData" Id="{2ec3e5fa-b79a-4527-9486-48de86728ba0}">
      <Declaration><![CDATA[METHOD PROTECTED M_InitNodeData : BOOL
VAR
	i				: UINT;
	sPrefix 		: STRING;
	
	bReturn			: BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
(* Node data, init to use string identifier and set namespace index *)
FOR i:=1 TO nMaxNodeIDsInList BY 1 DO
	aNodeIDs[i].eIdentifierType := eUAIdentifierType_String;
	aNodeIDs[i].nNamespaceIndex := nNameSpaceIndexNodes;
END_FOR

nNoOfNodes := 0;
cbDataTotal := 0;

// TEST
//eReadType := E_OPC_NodeType.Nodes;
//iReadIndex := 1;

// Comm type selection
CASE eReadType OF
	E_OPC_NodeType.Vehicles:
		// Select vehicle to read data from
		REPEAT
			iReadIndex := iReadIndex+1;
			IF (iReadIndex > MM_MAX_NUMBER_OF_VEHICLE_ELEMENTS) THEN
				EXIT;
			END_IF
			UNTIL (aReadCellData.stCell.anVehicles[iReadIndex] > 0)
		END_REPEAT
		IF (iReadIndex <= MM_MAX_NUMBER_OF_VEHICLE_ELEMENTS) THEN
			// Build remote symbol name
			sPrefix := CONCAT(sObjectIDentifier, '.stTrackStatus');
			// Data pointer for received data
			pReadNodeData := ADR(aReadVehicleData[iReadIndex]);
			// Header data size
			cbDataTotal := SIZEOF(aReadVehicleData[iReadIndex].stReadListReturnInfo);
			
			// Specify nodes to read by variable name
			nNoOfNodes := nNoOfNodes + 1;
			aNodeIDs[nNoOfNodes].sIdentifier := CONCAT(sPrefix, '.aVehicles[');
			aNodeIDs[nNoOfNodes].sIdentifier := CONCAT(aNodeIDs[nNoOfNodes].sIdentifier, UINT_TO_STRING(aReadCellData.stCell.anVehicles[iReadIndex]));
			aNodeIDs[nNoOfNodes].sIdentifier := CONCAT(aNodeIDs[nNoOfNodes].sIdentifier, ']');
			acbDatas[nNoOfNodes] := SIZEOF(aReadVehicleData[iReadIndex]);
			cbDataTotal := cbDataTotal + acbDatas[nNoOfNodes];
			bReturn := TRUE;
		ELSE
			// Read next type
			iReadIndex := 0;
			eReadType := E_OPC_NodeType.Paths;
			bReturn := FALSE;
		END_IF			
		
	E_OPC_NodeType.Paths:
		// Select path to read data from
		REPEAT
			iReadIndex := iReadIndex+1;
			IF (iReadIndex > MM_MAX_NUMBER_OF_PATH_ELEMENTS) THEN
				EXIT;
			END_IF
			UNTIL (abControlledPaths[i])
		END_REPEAT
		IF (iReadIndex <= MM_MAX_NUMBER_OF_PATH_ELEMENTS) THEN
			// Build remote symbol name
			sPrefix := CONCAT(sObjectIDentifier, '.stTrackStatus');
			// Data pointer for received data
			pReadNodeData := ADR(aReadPathData[iReadIndex]);
			// Header data size
			cbDataTotal := SIZEOF(aReadPathData[iReadIndex].stReadListReturnInfo);
			
			// Specify nodes to read by variable name
			nNoOfNodes := nNoOfNodes + 1;
			aNodeIDs[nNoOfNodes].sIdentifier := CONCAT(sPrefix, '.aPaths[');
			aNodeIDs[nNoOfNodes].sIdentifier := CONCAT(aNodeIDs[nNoOfNodes].sIdentifier, UINT_TO_STRING(iReadIndex));
			aNodeIDs[nNoOfNodes].sIdentifier := CONCAT(aNodeIDs[nNoOfNodes].sIdentifier, ']');
			acbDatas[nNoOfNodes] := SIZEOF(aReadPathData[iReadIndex]);
			cbDataTotal := cbDataTotal + acbDatas[nNoOfNodes];
			bReturn := TRUE;
		ELSE
			// Read next type
			iReadIndex := 0;
			eReadType := E_OPC_NodeType.Stations;
			bReturn := FALSE;
		END_IF
		
	E_OPC_NodeType.Stations:
		// Select Station to read data from
		iReadIndex := iReadIndex+1;
		IF (iReadIndex <= MM_MAX_NUMBER_OF_STATION_ELEMENTS) THEN
			// Build remote symbol name
			sPrefix := CONCAT(sObjectIDentifier, '.stTrackStatus');
			// Data pointer
			pReadNodeData := ADR(aReadStationData[iReadIndex]);
			
			// Header data
			cbDataTotal := SIZEOF(aReadStationData[iReadIndex].stReadListReturnInfo);
			
			// Specify nodes to read by variable name
			nNoOfNodes := nNoOfNodes + 1;
			aNodeIDs[nNoOfNodes].sIdentifier := CONCAT(sPrefix, '.aStations[');
			aNodeIDs[nNoOfNodes].sIdentifier := CONCAT(aNodeIDs[nNoOfNodes].sIdentifier, UINT_TO_STRING(iReadIndex));
			aNodeIDs[nNoOfNodes].sIdentifier := CONCAT(aNodeIDs[nNoOfNodes].sIdentifier, ']');
			acbDatas[nNoOfNodes] := SIZEOF(aReadStationData[iReadIndex].stStationData);
			cbDataTotal := cbDataTotal + acbDatas[nNoOfNodes];
			bReturn := TRUE;
		ELSE
			// Read next type
			iReadIndex := 0;
			eReadType := E_OPC_NodeType.Cells;
			bReturn := FALSE;
		END_IF
		
	E_OPC_NodeType.Cells:
		// Select cell status to read data from
		iReadIndex := iThisCellIndex;
		IF (iReadIndex > 0 AND iReadIndex <= MM_MAX_NUMBER_OF_STATION_ELEMENTS) THEN
			// Build remote symbol name
			sPrefix := CONCAT(sObjectIDentifier, '.stTrackStatus');
			// Data pointer
			pReadNodeData := ADR(aReadCellData);
			
			// Header data
			cbDataTotal := SIZEOF(aReadCellData.stReadListReturnInfo);
			
			// Specify nodes to read by variable name
			nNoOfNodes := nNoOfNodes + 1;
			aNodeIDs[nNoOfNodes].sIdentifier := CONCAT(sPrefix, '.aCells[');
			aNodeIDs[nNoOfNodes].sIdentifier := CONCAT(aNodeIDs[nNoOfNodes].sIdentifier, UINT_TO_STRING(iReadIndex));
			aNodeIDs[nNoOfNodes].sIdentifier := CONCAT(aNodeIDs[nNoOfNodes].sIdentifier, ']');
			acbDatas[nNoOfNodes] := SIZEOF(aReadCellData.stCell);
			cbDataTotal := cbDataTotal + acbDatas[nNoOfNodes]; 
			bReturn := TRUE;

			// continue to next type after this read!
			iReadIndex := 0;
			eReadType := E_OPC_NodeType.Vehicles;
		ELSE
			// Read next type
			iReadIndex := 0;
			eReadType := E_OPC_NodeType.Vehicles;
			bReturn := FALSE;
		END_IF
	
END_CASE
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_InitNodeData_ADS" Id="{5984c523-b795-4b39-9e4a-723ce44ca072}">
      <Declaration><![CDATA[METHOD PROTECTED M_InitNodeData_ADS : BOOL
VAR
	i				: UINT;
	sPrefix 		: STRING;
	
	bReturn			: BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
nNoOfNodes := 0;
cbDataTotal := 0;

// TEST NEW
IF ( (nDecisionPointVehicleNo > 0) AND bReadDecPointVehicle ) THEN
	// Read data from vehicle at decision point (Higher priority!)
	// Build remote symbol name
	sPrefix := CONCAT(sObjectIDentifier, '.stTrackStatus');
	// Data pointer for received data
	pReadNodeData := ADR(aReadVehicleData[nDecisionPointVehicleNo].stVehicle);
	// Header data size
	cbDataTotal := SIZEOF(aReadVehicleData[nDecisionPointVehicleNo].stVehicle);
	
	// Specify nodes to read by variable name
	sTrackServerSymbol := CONCAT(sPrefix, '.aVehicles[');
	sTrackServerSymbol := CONCAT(sTrackServerSymbol, UINT_TO_STRING(nDecisionPointVehicleNo));
	sTrackServerSymbol := CONCAT(sTrackServerSymbol, ']');

	// Remove this vehicle from the event-driven reading list (to make sure it is not continously read!)
	M_VehicleToReadRemove(nDecisionPointVehicleNo);
				
	bReadDecPointVehicle := FALSE;	// Done in M_StateMachineNode_ADS
	bReadDecPointVehicleBusy := TRUE;
	bReturn := TRUE;

	M_InitNodeData_ADS := bReturn;
	RETURN;
END_IF
// END TEST NEW

// Comm type selection
CASE eReadType OF
	E_OPC_NodeType.Vehicles:
		IF ( (nDecisionPointVehicleNo > 0) AND bReadDecPointVehicle ) THEN
			// Read data from vehicle at decision point (Higher priority!)
			// Build remote symbol name
			sPrefix := CONCAT(sObjectIDentifier, '.stTrackStatus');
			// Data pointer for received data
			pReadNodeData := ADR(aReadVehicleData[nDecisionPointVehicleNo].stVehicle);
			// Header data size
			cbDataTotal := SIZEOF(aReadVehicleData[nDecisionPointVehicleNo].stVehicle);
			
			// Specify nodes to read by variable name
			sTrackServerSymbol := CONCAT(sPrefix, '.aVehicles[');
			sTrackServerSymbol := CONCAT(sTrackServerSymbol, UINT_TO_STRING(nDecisionPointVehicleNo));
			sTrackServerSymbol := CONCAT(sTrackServerSymbol, ']');

			// Remove this vehicle from the event-driven reading list (to make sure it is not continously read!)
			M_VehicleToReadRemove(nDecisionPointVehicleNo);
				
			bReadDecPointVehicle := FALSE;	// Done in M_StateMachineNode_ADS
			bReadDecPointVehicleBusy := TRUE;
			bReturn := TRUE;			
		ELSE
	// NEW!!!
			// NOTE: iReadIndex is MagneMotion vehicle No
			REPEAT
				iReadIndex := iReadIndex + 1;
				IF (M_CheckVehicleOwned(iReadIndex)) THEN
					// Vehicle is owned by this cell... Read data from Track Server for this vehicle
					IF (M_CheckVehicleEventRead(iReadIndex)) THEN
						// Vehicle data is selected to be read! (event-based reading)
						EXIT;
					END_IF
				ELSIF (M_CheckVehicleSurvail(iReadIndex)) THEN
					// Vehicle is survailed by this cell (read data continously!)... Read data from Track Server for this vehicle
					EXIT;
				ELSIF (iReadIndex <> nDecisionPointVehicleNo) THEN
					// Not owned or surveilled or being handled by decision point. Delete any previous read data
					IF (iReadIndex > 0 AND iReadIndex <= MM_MAX_NUMBER_OF_VEHICLE_ELEMENTS) THEN
						aReadVehicleData[iReadIndex].stVehicle.bDataValid := FALSE;
					END_IF
				END_IF
				UNTIL (iReadIndex >= MM_MAX_NUMBER_OF_VEHICLE_ELEMENTS)
			END_REPEAT
			
			IF (iReadIndex <= MM_MAX_NUMBER_OF_VEHICLE_ELEMENTS) THEN
				// Build remote symbol name
				sPrefix := CONCAT(sObjectIDentifier, '.stTrackStatus');
				// Data pointer for received data
				pReadNodeData := ADR(aReadVehicleData[iReadIndex].stVehicle);
				// Header data size
				cbDataTotal := SIZEOF(aReadVehicleData[iReadIndex].stVehicle);
				
				// Specify nodes to read by variable name
				sTrackServerSymbol := CONCAT(sPrefix, '.aVehicles[');
				sTrackServerSymbol := CONCAT(sTrackServerSymbol, UINT_TO_STRING(iReadIndex));
				sTrackServerSymbol := CONCAT(sTrackServerSymbol, ']');
				
				// Remove this vehicle from the event-driven reading list
				M_VehicleToReadRemove(iReadIndex);
				
				bReturn := TRUE;
			ELSE
				// Read next type
				iReadIndex := 0;
				eReadType := E_OPC_NodeType.Paths;
				bReturn := FALSE;
			END_IF
	// NEW END!!!	
			// Select vehicle to read data from (only the vehicles this cell is responsible for)
(*			REPEAT
				iReadIndex := iReadIndex+1;
				IF (iReadIndex > MM_MAX_NUMBER_OF_VEHICLE_ELEMENTS) THEN
					EXIT;
				END_IF
				UNTIL (aReadCellData.stCell.anVehicles[iReadIndex] > 0)
			END_REPEAT
			IF (iReadIndex <= MM_MAX_NUMBER_OF_VEHICLE_ELEMENTS) THEN
				// Build remote symbol name
				sPrefix := CONCAT(sObjectIDentifier, '.stTrackStatus');
				// Data pointer for received data
				pReadNodeData := ADR(aReadVehicleData[aReadCellData.stCell.anVehicles[iReadIndex]].stVehicle);
				// Header data size
				cbDataTotal := SIZEOF(aReadVehicleData[aReadCellData.stCell.anVehicles[iReadIndex]].stVehicle);
				
				// Specify nodes to read by variable name
				sTrackServerSymbol := CONCAT(sPrefix, '.aVehicles[');
				sTrackServerSymbol := CONCAT(sTrackServerSymbol, UINT_TO_STRING(aReadCellData.stCell.anVehicles[iReadIndex]));
				sTrackServerSymbol := CONCAT(sTrackServerSymbol, ']');
				bReturn := TRUE;
			ELSE
				// Read next type
				iReadIndex := 0;
				eReadType := E_OPC_NodeType.Paths;
				bReturn := FALSE;
			END_IF		*)
		END_IF
		
	E_OPC_NodeType.Paths:
		// Select path to read data from
		REPEAT
			iReadIndex := iReadIndex+1;
			IF (iReadIndex > MM_MAX_NUMBER_OF_PATH_ELEMENTS) THEN
				EXIT;
			END_IF
			UNTIL (abControlledPaths[iReadIndex])
		END_REPEAT
		IF ((iReadIndex <= MM_MAX_NUMBER_OF_PATH_ELEMENTS) AND NOT tonSkipPathRead.Q) THEN	// Skip path reading when paths are started!
			// Build remote symbol name
			sPrefix := CONCAT(sObjectIDentifier, '.stTrackStatus');
			// Data pointer for received data
			pReadNodeData := ADR(aReadPathData[iReadIndex].stPathData);
			// Header data size
			cbDataTotal := SIZEOF(aReadPathData[iReadIndex].stPathData);
			
			// Specify nodes to read by variable name
			sTrackServerSymbol := CONCAT(sPrefix, '.aPaths[');
			sTrackServerSymbol := CONCAT(sTrackServerSymbol, UINT_TO_STRING(iReadIndex));
			sTrackServerSymbol := CONCAT(sTrackServerSymbol, ']');
			bReturn := TRUE;
		ELSE
			// Read next type
			iReadIndex := 0;
			eReadType := E_OPC_NodeType.Stations;
			bReturn := FALSE;
		END_IF
		
	E_OPC_NodeType.Stations:
		// Select Station to read data from
// TEST
		IF (M_CheckStationsRead()) THEN
			// Index for station data from track server has been found... Only read these stations
			REPEAT
				iReadIndex := iReadIndex+1;
				IF (iReadIndex > MM_MAX_NUMBER_OF_STATION_ELEMENTS) THEN
					EXIT;
				END_IF
				UNTIL (M_CheckStationIndex(iReadIndex))
			END_REPEAT
		ELSE
			// Index for station data from track server has NOT been found... Read data from all stations
			iReadIndex := iReadIndex + 1;
		END_IF
// TEST END
//		iReadIndex := iReadIndex+1;
		IF (iReadIndex <= MM_MAX_NUMBER_OF_STATION_ELEMENTS) THEN
			// Build remote symbol name
			sPrefix := CONCAT(sObjectIDentifier, '.stTrackStatus');
			// Data pointer
			pReadNodeData := ADR(aReadStationData[iReadIndex].stStationData);
			// Header data
			cbDataTotal := SIZEOF(aReadStationData[iReadIndex].stStationData);
			
			// Specify nodes to read by variable name
			sTrackServerSymbol := CONCAT(sPrefix, '.aStations[');
			sTrackServerSymbol := CONCAT(sTrackServerSymbol, UINT_TO_STRING(iReadIndex));
			sTrackServerSymbol := CONCAT(sTrackServerSymbol, ']');
			bReturn := TRUE;
		ELSE
			// Read next type
			iReadIndex := 0;
			eReadType := E_OPC_NodeType.Cells;
			bReturn := FALSE;
		END_IF
	
	E_OPC_NodeType.Cells:
		// Select Station to read data from
		iReadIndex := iThisCellIndex;
		IF (iReadIndex > 0 AND iReadIndex <= MM_MAX_NUMBER_OF_CELL_ELEMENTS) THEN
			// Build remote symbol name
			sPrefix := CONCAT(sObjectIDentifier, '.stTrackStatus');
			// Data pointer
			pReadNodeData := ADR(aReadCellData.stCell);
			// Header data
			cbDataTotal := SIZEOF(aReadCellData.stCell);
			
			// Specify nodes to read by variable name
			sTrackServerSymbol := CONCAT(sPrefix, '.aCells[');
			sTrackServerSymbol := CONCAT(sTrackServerSymbol, UINT_TO_STRING(iReadIndex));
			sTrackServerSymbol := CONCAT(sTrackServerSymbol, ']');
			bReturn := TRUE;

			// continue to next type after this read!
			iReadIndex := 0;
			bReadDecPointVehicle := TRUE;	// Force reading of the vehicle at decision point before other vehicles
			IF (NOT bReadDecPointCellDone) THEN
				bReadDecPointCell := TRUE;
			END_IF
			eReadType := E_OPC_NodeType.Vehicles;
		ELSE
			// Read next type
			iReadIndex := 0;
			bReadDecPointVehicle := TRUE;	// Force reading of the vehicle at decision point before other vehicles
			eReadType := E_OPC_NodeType.Vehicles;
			bReturn := FALSE;
		END_IF

END_CASE

M_InitNodeData_ADS := bReturn;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_InitNodeData_OPCUA" Id="{d0af0184-d04d-4703-a126-3478d4c3c72f}">
      <Declaration><![CDATA[METHOD PROTECTED M_InitNodeData_OPCUA : BOOL
VAR
	i		: UINT;
	sPrefix : STRING;
END_VAR
VAR
	cbDataTotal2 : UINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// NOTE!!!
// Maximum of 10 elements to read for each Node List reading!


(* Node data, init to use string identifier and set namespace index *)
FOR i:=1 TO nMaxNodeIDsInList BY 1 DO
	aNodeIDs[i].eIdentifierType := eUAIdentifierType_String;
	aNodeIDs[i].nNamespaceIndex := nNameSpaceIndexNodes;
END_FOR

nNoOfNodes := 0;
cbDataTotal := 0;

// TEST
eReadType := E_OPC_NodeType.Nodes;
iReadIndex := 1;

// Comm type selection
CASE eReadType OF
	E_OPC_NodeType.Vehicles:
		// Limit number of elements
		iReadIndex := LIMIT(1, iReadIndex, MM_MAX_NUMBER_OF_VEHICLE_ELEMENTS);
		// Build remote symbol name
		sPrefix := CONCAT(sObjectIDentifier, '.stTrackStatus.aVehicles[');
		sPrefix := CONCAT(sPrefix, UINT_TO_STRING(iReadIndex));
		sPrefix := CONCAT(sPrefix, ']');
		// Data pointer
		pReadNodeData := ADR(aReadVehicleData[iReadIndex]);
		// Header data
		cbDataTotal := SIZEOF(aReadVehicleData[iReadIndex].stReadListReturnInfo);
		
		// Specify nodes to read by variable name
		nNoOfNodes := nNoOfNodes + 1;
		aNodeIDs[nNoOfNodes].sIdentifier := CONCAT(sPrefix, '.nVehicleID');
		acbDatas[nNoOfNodes] := SIZEOF(aReadVehicleData[iReadIndex].nVehicleID);
		cbDataTotal := cbDataTotal + acbDatas[nNoOfNodes];
		
		nNoOfNodes := nNoOfNodes + 1;
		aNodeIDs[nNoOfNodes].sIdentifier := CONCAT(sPrefix, '.bVehiclePresent');
		acbDatas[nNoOfNodes] := SIZEOF(aReadVehicleData[iReadIndex].bVehiclePresent);
		cbDataTotal := cbDataTotal + acbDatas[nNoOfNodes];
		
		nNoOfNodes := nNoOfNodes + 1;
		aNodeIDs[nNoOfNodes].sIdentifier := CONCAT(sPrefix, '.nState');
		acbDatas[nNoOfNodes] := SIZEOF(aReadVehicleData[iReadIndex].nState);
		cbDataTotal := cbDataTotal + acbDatas[nNoOfNodes];
		
		nNoOfNodes := nNoOfNodes + 1;
		aNodeIDs[nNoOfNodes].sIdentifier := CONCAT(sPrefix, '.nPathID');
		acbDatas[nNoOfNodes] := SIZEOF(aReadVehicleData[iReadIndex].nPathID);
		cbDataTotal := cbDataTotal + acbDatas[nNoOfNodes];
		
		nNoOfNodes := nNoOfNodes + 1;
		aNodeIDs[nNoOfNodes].sIdentifier := CONCAT(sPrefix, '.fPosition');
		acbDatas[nNoOfNodes] := SIZEOF(aReadVehicleData[iReadIndex].fPosition);
		cbDataTotal := cbDataTotal + acbDatas[nNoOfNodes];
		
		nNoOfNodes := nNoOfNodes + 1;
		aNodeIDs[nNoOfNodes].sIdentifier := CONCAT(sPrefix, '.nTargetPathID');
		acbDatas[nNoOfNodes] := SIZEOF(aReadVehicleData[iReadIndex].nTargetPathID);
		cbDataTotal := cbDataTotal + acbDatas[nNoOfNodes];
		
		nNoOfNodes := nNoOfNodes + 1;
		aNodeIDs[nNoOfNodes].sIdentifier := CONCAT(sPrefix, '.fTargetPosition');
		acbDatas[nNoOfNodes] := SIZEOF(aReadVehicleData[iReadIndex].fTargetPosition);
		cbDataTotal := cbDataTotal + acbDatas[nNoOfNodes];
		
		nNoOfNodes := nNoOfNodes + 1;
		aNodeIDs[nNoOfNodes].sIdentifier := CONCAT(sPrefix, '.fVelocity');
		acbDatas[nNoOfNodes] := SIZEOF(aReadVehicleData[iReadIndex].fVelocity);
		cbDataTotal := cbDataTotal + acbDatas[nNoOfNodes];
				
		// Read next vehicle value
		iReadIndex := iReadIndex+1;;
		IF (iReadIndex > MM_MAX_NUMBER_OF_VEHICLE_ELEMENTS) THEN
			// Read next type
			iReadIndex := 0;
			eReadType := E_OPC_NodeType.Paths;
		END_IF

	E_OPC_NodeType.Paths:
		// Limit number of elements
		iReadIndex := LIMIT(1, iReadIndex, MM_MAX_NUMBER_OF_PATH_ELEMENTS);
		// Build remote symbol name
		sPrefix := CONCAT(sObjectIDentifier, '.stTrackStatus.aPaths[');
		sPrefix := CONCAT(sPrefix, UINT_TO_STRING(iReadIndex));
		sPrefix := CONCAT(sPrefix, ']');
		// Data pointer
		pReadNodeData := ADR(aReadPathData[iReadIndex]);
		
		// Header data
		cbDataTotal := SIZEOF(aReadPathData[iReadIndex].stReadListReturnInfo);
		
		// Specify nodes to read by variable name
		nNoOfNodes := nNoOfNodes + 1;
		aNodeIDs[nNoOfNodes].sIdentifier := CONCAT(sPrefix, '.nPathID');
		acbDatas[nNoOfNodes] := SIZEOF(aReadPathData[iReadIndex].nPathID);
		cbDataTotal := cbDataTotal + acbDatas[nNoOfNodes];

		nNoOfNodes := nNoOfNodes + 1;
		aNodeIDs[nNoOfNodes].sIdentifier := CONCAT(sPrefix, '.sCellID');
		acbDatas[nNoOfNodes] := SIZEOF(aReadPathData[iReadIndex].sCellID);
		cbDataTotal := cbDataTotal + acbDatas[nNoOfNodes];

		nNoOfNodes := nNoOfNodes + 1;
		aNodeIDs[nNoOfNodes].sIdentifier := CONCAT(sPrefix, '.bPathPresent');
		acbDatas[nNoOfNodes] := SIZEOF(aReadPathData[iReadIndex].bPathPresent);
		cbDataTotal := cbDataTotal + acbDatas[nNoOfNodes];

		nNoOfNodes := nNoOfNodes + 1;
		aNodeIDs[nNoOfNodes].sIdentifier := CONCAT(sPrefix, '.nState');
		acbDatas[nNoOfNodes] := SIZEOF(aReadPathData[iReadIndex].nState);
		cbDataTotal := cbDataTotal + acbDatas[nNoOfNodes];

		// Read next path value
		iReadIndex := iReadIndex+1;
		IF (iReadIndex > MM_MAX_NUMBER_OF_PATH_ELEMENTS) THEN
			// Read next type
			iReadIndex := 0;
			eReadType := E_OPC_NodeType.Nodes;
			//eReadType := E_OPC_NodeType.Vehicles;
		END_IF
		
		
	E_OPC_NodeType.Nodes:
		// Limit number of elements
		iReadIndex := LIMIT(1, iReadIndex, 10);
		// Build remote symbol name
		sPrefix := CONCAT(sObjectIDentifier, '.stTrackStatus');
		// Data pointer
		pReadNodeData := ADR(aReadNodeData[iReadIndex]);
		
		// Header data
		cbDataTotal := SIZEOF(aReadNodeData[iReadIndex].stReadListReturnInfo);
		cbDataTotal2 := SIZEOF(aReadNodeData[iReadIndex]);
		
		// Specify nodes to read by variable name
		nNoOfNodes := nNoOfNodes + 1;
		aNodeIDs[nNoOfNodes].sIdentifier := CONCAT(sPrefix, '.aNodes[');
		aNodeIDs[nNoOfNodes].sIdentifier := CONCAT(aNodeIDs[nNoOfNodes].sIdentifier, UINT_TO_STRING(iReadIndex));
		aNodeIDs[nNoOfNodes].sIdentifier := CONCAT(aNodeIDs[nNoOfNodes].sIdentifier, ']');
		acbDatas[nNoOfNodes] := SIZEOF(aReadNodeData[iReadIndex].stNodeData);
		cbDataTotal := cbDataTotal + acbDatas[nNoOfNodes];

		// Read next node value
		iReadIndex := iReadIndex+1;
		IF (iReadIndex > 10) THEN
			// Read next type
			iReadIndex := 0;
			eReadType := E_OPC_NodeType.Vehicles;
		END_IF

END_CASE
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_MappingData" Id="{556fccca-69db-43f4-b7b4-ab5b0d065e23}">
      <Declaration><![CDATA[METHOD PROTECTED M_MappingData
VAR_INPUT
END_VAR
VAR
	i			: USINT;
	iRes		: UINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Handle the mapping data from OPC UA (stCommand)

CASE eMappingDataState OF
	// Init state
	E_MappingDataState.Undefined:
		eMappingDataState := E_MappingDataState.CheckRequest;
	
	// Check command data request
	E_MappingDataState.CheckRequest:
		IF ((stMappingIn.ChangeRequest <> stMappingOut.ChangeStatus) AND (stMappingIn.ChangeRequest > 0)) THEN
			// Check if changes is allowed on mapping data (from LC)
			IF (stAdditionalDataIn.MESHandShakes.DataChangeStatusTransportMapping = stMappingOut.DataChange) THEN
				stMappingOut.ChangeAcknowlegde := stMappingIn.ChangeRequest;
				stMappingOut.DataChange := stMappingOut.DataChange + 1;
				
				// Find vehicle ID with specified carrier ID
				iMappingDataVehicleID := M_CarrierIDToVehicleID(stMappingIn.Carrier.CarrierID);
	
				// Check vehicle number
				IF (iMappingDataVehicleID > 0) THEN
					eMappingDataState := E_MappingDataState.UpdateMappingData;
				ELSE
					eMappingDataState := E_MappingDataState.Error;
				END_IF
			END_IF	
		END_IF	
	
	// Perform data update
	E_MappingDataState.UpdateMappingData:
		iRes := M_CallUpdateVehicleMappingData(	nVehicleID := iMappingDataVehicleID,
												sCarrierID := stMappingIn.Carrier.CarrierID, 
												bTool := stMappingIn.Carrier.Tool, 
												sToolID := stMappingIn.Carrier.ToolID, 
												bMaterial := stMappingIn.Carrier.Material,
												sMaterialID := stMappingIn.Carrier.MaterialID 	);
		IF (iRes = 2) THEN
			// Success.
			eMappingDataState := E_MappingDataState.UpdateReworkData;
		ELSIF (iRes = 3) THEN
			// Error!
			eMappingDataState := E_MappingDataState.Error;
		END_IF
	
	// Perform rework update
	E_MappingDataState.UpdateReworkData:
		iRes := M_CallUpdateVehicleReworkData(	nVehicleID := iMappingDataVehicleID,
												sCarrierID := stMappingIn.Carrier.CarrierID,
												bNOK := stMappingIn.Carrier.NOK	); 
		IF (iRes = 2) THEN
			// Success..
			eMappingDataState := E_MappingDataState.Done;
		ELSIF (iRes = 3) THEN
			// Error!
			eMappingDataState := E_MappingDataState.Error;
		END_IF
	
	E_MappingDataState.Done:
		// Completed... Update output mapping data
		stMappingOut.ValidRequest := TRUE;
		stMappingOut.Carrier := stMappingIn.Carrier;
		stMappingOut.StationBuffer := stMappingIn.StationBuffer;
		stMappingOut.ChangeStatus := stMappingIn.ChangeRequest;
		stMappingOut.DataChange := stMappingOut.DataChange + 1;
		eMappingDataState := E_MappingDataState.Undefined;
	
	E_MappingDataState.Error:
		// Error... Valid request = FALSE
		stMappingOut.ValidRequest := FALSE;
		stMappingOut.ChangeStatus := stMappingIn.ChangeRequest;
		stMappingOut.DataChange := stMappingOut.DataChange + 1;
		eMappingDataState := E_MappingDataState.Undefined;
	
END_CASE
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_ReworkData" Id="{fb0c97a7-e083-4c09-9fc7-0083f6bba4ec}">
      <Declaration><![CDATA[METHOD PROTECTED M_ReworkData
VAR_INPUT
END_VAR
VAR
	i			: USINT;
	iRes		: UINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Handle the mapping data from OPC UA (stCommand)

CASE eReworkDataState OF
	// Init state
	E_ReworkDataState.Undefined:
		bReworkValue := FALSE;
		iReworkDataStation := 0;
		iReworkDataStationNo := 0;
		eReworkDataState := E_ReworkDataState.CheckRequest;
	
	// Check command data request
	E_ReworkDataState.CheckRequest:
		FOR i := 1 TO 5 BY 1 DO
			/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
			// Rework completed from station (shoe rework is done handled)
			/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
			IF (abStation1ReworkDone[i]) THEN
				iReworkDataStation := i;
				iReworkDataStationNo := 1;

				// Check vehicle at station
				iReworkDataVehicleID := aStations[iReworkDataStation].stStationData1.nCurrentVehicleID;
				IF ((iReworkDataVehicleID > 0) AND (iReworkDataVehicleID <= MM_MAX_NUMBER_OF_VEHICLE_ELEMENTS) ) THEN
					// There is a vehicle on that station! Get the Carrier ID
					sReworkDataCarrierID := aReadVehicleData[iReworkDataVehicleID].stVehicle.sCarrierID;
					
					// Check carrier ID of vehicle
					IF (sReworkDataCarrierID <> '') THEN
						bReworkValue := FALSE;	// Set carrier status to rework NOT needed!
						eReworkDataState := E_ReworkDataState.UpdateReworkData;
					ELSE
						// Error!
						eReworkDataState := E_ReworkDataState.Error;
					
					END_IF
				ELSE
					// Error!
					eReworkDataState := E_ReworkDataState.Error;
				
				END_IF

				EXIT;
				
			ELSIF (abStation2ReworkDone[i]) THEN
				iReworkDataStation := i;
				iReworkDataStationNo := 2;

				iReworkDataVehicleID := aStations[iReworkDataStation].stStationData2.nCurrentVehicleID;
				IF ((iReworkDataVehicleID > 0) AND (iReworkDataVehicleID <= MM_MAX_NUMBER_OF_VEHICLE_ELEMENTS) ) THEN
					// There is a vehicle on that station! Get the Carrier ID
					sReworkDataCarrierID := aReadVehicleData[iReworkDataVehicleID].stVehicle.sCarrierID;
					
					// Check carrier ID of vehicle
					IF (sReworkDataCarrierID <> '') THEN
						bReworkValue := FALSE;	// Set carrier status to rework NOT needed!
						eReworkDataState := E_ReworkDataState.UpdateReworkData;
					ELSE
						// Error!
						eReworkDataState := E_ReworkDataState.Error;
					
					END_IF				
				ELSE
					// Error!
					eReworkDataState := E_ReworkDataState.Error;
				
				END_IF

				EXIT;

			/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
			// Rework request from station (shoe needs to be reworked)
			/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
			ELSIF (abStation1ReworkReq[i]) THEN
				iReworkDataStation := i;
				iReworkDataStationNo := 1;

				// Check vehicle at station
				iReworkDataVehicleID := aStations[iReworkDataStation].stStationData1.nCurrentVehicleID;
				IF ((iReworkDataVehicleID > 0) AND (iReworkDataVehicleID <= MM_MAX_NUMBER_OF_VEHICLE_ELEMENTS) ) THEN
					// There is a vehicle on that station! Get the Carrier ID
					sReworkDataCarrierID := aReadVehicleData[iReworkDataVehicleID].stVehicle.sCarrierID;
					
					// Check carrier ID of vehicle
					IF (sReworkDataCarrierID <> '') THEN
						bReworkValue := TRUE;	// Set carrier status to rework needed!
						eReworkDataState := E_ReworkDataState.UpdateReworkData;
					ELSE
						// Error!
						eReworkDataState := E_ReworkDataState.Error;
					
					END_IF
				ELSE
					// Error!
					eReworkDataState := E_ReworkDataState.Error;
				
				END_IF

				EXIT;
				
			ELSIF (abStation2ReworkReq[i]) THEN
				iReworkDataStation := i;
				iReworkDataStationNo := 2;

				iReworkDataVehicleID := aStations[iReworkDataStation].stStationData2.nCurrentVehicleID;
				IF ((iReworkDataVehicleID > 0) AND (iReworkDataVehicleID <= MM_MAX_NUMBER_OF_VEHICLE_ELEMENTS) ) THEN
					// There is a vehicle on that station! Get the Carrier ID
					sReworkDataCarrierID := aReadVehicleData[iReworkDataVehicleID].stVehicle.sCarrierID;
					
					// Check carrier ID of vehicle
					IF (sReworkDataCarrierID <> '') THEN
						bReworkValue := TRUE;	// Set carrier status to rework needed!
						eReworkDataState := E_ReworkDataState.UpdateReworkData;
					ELSE
						// Error!
						eReworkDataState := E_ReworkDataState.Error;
					
					END_IF				
				ELSE
					// Error!
					eReworkDataState := E_ReworkDataState.Error;
				
				END_IF

				EXIT;
			END_IF
		END_FOR
	
	// Perform rework update
	E_ReworkDataState.UpdateReworkData:
		iRes := M_CallUpdateVehicleReworkData(	nVehicleID := iReworkDataVehicleID,
												sCarrierID := sReworkDataCarrierID,
												bNOK := bReworkValue 	);
		IF (iRes = 2) THEN
			// Success..
			F_LogLine(CONCAT('TC_RWK: Vehicle ', CONCAT(UINT_TO_STRING(iReworkDataVehicleID), ' NOK set to %d')), BOOL_TO_DINT(bReworkValue));
			eReworkDataState := E_ReworkDataState.Done;
		ELSIF (iRes = 3) THEN
			// Error!
			eReworkDataState := E_ReworkDataState.Error;
		END_IF
	
	E_ReworkDataState.Done:
		// Completed... Wait until activation bit is sert to FALSE (when vehicle has been removed from station)
		IF (bReworkValue) THEN
			IF (iReworkDataStationNo = 1) THEN
				IF (NOT abStation1ReworkReq[iReworkDataStation]) THEN
					eReworkDataState := E_ReworkDataState.Undefined;		
				END_IF
	
			ELSIF (iReworkDataStationNo = 2) THEN
				IF (NOT abStation2ReworkReq[iReworkDataStation]) THEN
					eReworkDataState := E_ReworkDataState.Undefined;
				END_IF
	
			END_IF
		ELSE
			IF (iReworkDataStationNo = 1) THEN
				IF (NOT abStation1ReworkDone[iReworkDataStation]) THEN
					eReworkDataState := E_ReworkDataState.Undefined;		
				END_IF
	
			ELSIF (iReworkDataStationNo = 2) THEN
				IF (NOT abStation2ReworkDone[iReworkDataStation]) THEN
					eReworkDataState := E_ReworkDataState.Undefined;
				END_IF
	
			END_IF
		END_IF
	
	E_ReworkDataState.Error:
		// Error... Wait until activation bit is sert to FALSE (when vehicle has been removed from station)
		// TODO!!! Alarm!
		IF (bReworkValue) THEN
			IF (iReworkDataStationNo = 1) THEN
				IF (NOT abStation1ReworkReq[iReworkDataStation]) THEN
					eReworkDataState := E_ReworkDataState.Undefined;		
				END_IF
	
			ELSIF (iReworkDataStationNo = 2) THEN
				IF (NOT abStation2ReworkReq[iReworkDataStation]) THEN
					eReworkDataState := E_ReworkDataState.Undefined;
				END_IF
	
			END_IF
		ELSE
			IF (iReworkDataStationNo = 1) THEN
				IF (NOT abStation1ReworkDone[iReworkDataStation]) THEN
					eReworkDataState := E_ReworkDataState.Undefined;		
				END_IF
	
			ELSIF (iReworkDataStationNo = 2) THEN
				IF (NOT abStation2ReworkDone[iReworkDataStation]) THEN
					eReworkDataState := E_ReworkDataState.Undefined;
				END_IF
	
			END_IF
		END_IF

END_CASE
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_Run" Id="{32f5619d-9c61-45ef-983b-857f7d3984c4}">
      <Declaration><![CDATA[METHOD PROTECTED M_Run : BOOL
VAR_INPUT
END_VAR
VAR
	i	: USINT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Get system time
fbGetTime(	NETID:= '',	// Local PLC 
			START:= NOT fbGetTime.START AND NOT fbGetTime.BUSY, 
			TMOUT:= T#5S	);

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// FB's for method calling
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	(* Handle server connect *)
	fbConnectMethod(	Execute				:= , 
						ServerUrl			:= sTrackServerUrl, 
						SessionConnectInfo	:= stConnectInfoMethod, 
						Timeout				:= T#10S, 
						ConnectionHdl		=> , 
						Done				=> , 
						Busy				=> , 
						Error				=> , 
						ErrorID				=> 	);
					
	(* Handle server dicconnect *)
	fbDisconnectMethod(	Execute				:= , 
						ConnectionHdl		:= nConnectHdlMethod, 
						Timeout				:= T#10S, 
						Done				=> , 
						Busy				=> , 
						Error				=> , 
						ErrorID				=> 	);
						
	(* Get namepsace *)
	fbGetNamespaceMethod(	Execute				:= , 
							ConnectionHdl		:= nConnectHdlMethod, 
							NamespaceUri		:= sNameSpaceUri, 
							Timeout				:= T#10S, 
							NamespaceIndex		=> , 
							Done				=> , 
							Busy				=> , 
							Error				=> , 
							ErrorID				=> 	);
	
	(* Get method handle *)
	stObjectNodeID.nNamespaceIndex := nNameSpaceIndexMethod;
	stObjectNodeID.sIdentifier := sObjectIDentifier;
	stMethodNodeID.nNamespaceIndex := nNameSpaceIndexMethod;
	stMethodNodeID.sIdentifier := sMethodIdentifier;
	fbGetHandleMethod(	Execute				:= , 
						ConnectionHdl		:= nConnectHdlMethod, 
						ObjectNodeID		:= stObjectNodeID, 
						MethodNodeID		:= stMethodNodeID, 
						Timeout				:= T#10S, 
						MethodHdl			=> , 
						Done				=> , 
						Busy				=> , 
						Error				=> , 
						ErrorID				=>	);
	
	(* Call method *)
	fbCallMethod(	Execute					:= , 
					ConnectionHdl			:= nConnectHdlMethod, 
					MethodHdl				:= nHandleMethod, 
					nNumberOfInputArguments	:= , 
					pInputArgInfo			:= , 
					cbInputArgInfo			:= , 
					pInputArgData			:= , 
					cbInputArgData			:= , 
					pInputWriteData			:= 0,
					cbInputWriteData		:= 0,
					nNumberOfOutputArguments:= , 
					pOutputArgInfo			:= , 
					cbOutputArgInfo			:= , 
					pOutputArgInfoAndData	:= , 
					cbOutputArgInfoAndData	:= , 
					Timeout					:= T#10S, 
					cbRead_R				=> , 
					Done					=> , 
					Busy					=> , 
					Error					=> , 
					ErrorID					=> );
	
	(* Release method handle *)
	fbReleaseHandleMethod(	Execute			:= , 
							ConnectionHdl	:= nConnectHdlMethod, 
							MethodHdl		:= nHandleMethod, 
							Timeout			:= T#10S, 
							Done			=> , 
							Busy			=> , 
							Error			=> , 
							ErrorID			=> 	);

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// FB's for method calling
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	(* Handle server connect *)
	fbConnectNodes(	Execute				:= , 
					ServerUrl			:= sTrackServerUrl, 
					SessionConnectInfo	:= stConnectInfoNodes, 
					Timeout				:= T#10S, 
					ConnectionHdl		=> , 
					Done				=> , 
					Busy				=> , 
					Error				=> , 
					ErrorID				=> 	);
					
	(* Handle server dicconnect *)
	fbDisconnectNodes(	Execute				:= , 
						ConnectionHdl		:= nConnectHandleNodes, 
						Timeout				:= T#10S, 
						Done				=> , 
						Busy				=> , 
						Error				=> , 
						ErrorID				=> 	);
						
	(* Get namepsace *)
	fbGetNamespaceNodes(	Execute				:= , 
						ConnectionHdl		:= nConnectHandleNodes, 
						NamespaceUri		:= sNameSpaceUri, 
						Timeout				:= T#10S, 
						NamespaceIndex		=> , 
						Done				=> , 
						Busy				=> , 
						Error				=> , 
						ErrorID				=> 	);
	
	(* Get node handle *)
	fbGetHandleNodes(	Execute				:= , 
						ConnectionHdl		:= nConnectHandleNodes, 
						NodeIDCount			:= nNoOfNodes,
						NodeIDs				:= aNodeIDs, 
						Timeout				:= T#10S, 
						NodeHdls			=> , 
						Done				=> , 
						Busy				=> , 
						Error				=> , 
						ErrorID				=> 	);
		
	(* Read node data *)
	fbReadNodes(	Execute:= , 
					ConnectionHdl			:= nConnectHandleNodes,
					NodeHdlCount			:= nNoOfNodes,
					NodeHdls				:= anHandleNodes, 
					stNodeAddInfo			:= astNodeAddInfo, 
					pVariable				:= pReadNodeData, 
					cbData					:= acbDatas,
					cbDataTotal				:= cbDataTotal, 
					Timeout					:= T#10S, 
					Done					=> , 
					Busy					=> , 
					Error					=> , 
					ErrorID					=> , 
					cbData_R				=> 	);
					
	(* Release node handle list *)
	fbReleaseHandleNodes(	Execute			:= , 
							ConnectionHdl	:= nConnectHandleNodes, 
							NodeHdlCount	:= nNoOfNodes, 
							NodeHdls		:= anHandleNodes, 
							Timeout			:= T#10S, 
							NodeErrorIDs	=> , 
							Done			=> , 
							Busy			=> , 
							Error			=> , 
							ErrorID			=> 	);
	
	(* Read interval *)
	tonReadInterval(	IN	:= ,
						PT	:= REAL_TO_TIME(rReadInterval * 1000.0),
						Q	=> ,
						ET	=> 	);
						
	(* Error automatic reset delay *)
	tonErrorReset(		IN	:= ,
						PT	:= REAL_TO_TIME(rErrorResetDelay * 1000.0),
						Q	=> ,
						ET	=> 	);

// Update Additional Data variables
	stAdditionaldataOut.bConnectedMethod := bConnectedMethod;
	stAdditionaldataOut.bConnectedNode := bConnectedNode;
	stAdditionaldataOut.bTrackReady := P_bTrackReady;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_StateMachine" Id="{75832c14-cca9-41ab-90e4-a04ce178e3d7}">
      <Declaration><![CDATA[METHOD PROTECTED M_StateMachine : BOOL
VAR_INPUT
END_VAR
VAR
	iRes	: INT;
	i		: UINT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[
CASE eTrackState OF
	E_TrackState.Undefined:
		bStarted := FALSE;
		bSuspended := FALSE;
		iStationID := 1;
		iPathID := 1;
		iPathIndex := 1;
		IF (bConnectedMethod AND bConnectedNode) THEN
			// Communication connections established
			IF (bEnable) THEN
				eTrackState := E_TrackState.CheckInitDone;
			END_IF
		END_IF
	
	E_TrackState.CheckInitDone:
		// Check if track has been setup from this cell already on the track server
		iRes := M_CallGetCellIndex(sCellID);
		IF (iRes = 2) THEN
			// Success... Init done
			// Save found index
			iThisCellIndex := stGetCellIndexData.stOutput.nCellIndex;
			IF (iThisCellIndex > 0) THEN
				bTrackInitDone := TRUE;
				eTrackState := E_TrackState.Starting;
			ELSE
				bTrackInitDone := FALSE;
				bStationData1Done := FALSE;
				bStationData2Done := FALSE;
				// Clear station index
				FOR i := 1 TO 5 BY 1 DO
					iThisStationIndex[i] := 0;
				END_FOR
				eTrackState := E_TrackState.WaitAllowInit;
			END_IF
		ELSIF (iRes = 3) THEN
			// Error!
			// Clear station index
			FOR i := 1 TO 5 BY 1 DO
				iThisStationIndex[i] := 0;
			END_FOR
			eTrackState := E_TrackState.WaitAllowInit;
		END_IF
	
//	E_TrackState.InitDecisionPoint:
//		// Initialized with stations
//		eTrackState := E_TrackState.InitStations;
	
	E_TrackState.WaitAllowInit:
		// Initialized with stations
		IF (stAdditionalDataIn.bAllowInit) THEN
			stAdditionalDataIn.bAllowInit := FALSE;
			eTrackState := E_TrackState.InitStations;
		ELSIF (NOT bEnable OR NOT bConnectedMethod OR NOT bConnectedNode) THEN
			eTrackState := E_TrackState.Undefined;
		END_IF

	E_TrackState.InitStations:
		IF (aStations[iStationID].bPresent) THEN
			IF (aStations[iStationID].stStationData2.stLocation.nPathID > 0) THEN
				// Double position station
				iRes := M_CallAddStationDouble(nStationNo := iStationID);
				IF (iRes = 2) THEN
					// Success... Next station
					iStationID := iStationID + 1;
				ELSIF (iRes = 3) THEN
					// Error!
					// TODO!!!
					;				
				END_IF
			ELSE
				// Single position station
				iRes := M_CallAddStationSingle(nStationNo := iStationID);
				IF (iRes = 2) THEN
					// Success... Next station
					iStationID := iStationID + 1;
				ELSIF (iRes = 3) THEN
					// Error!
					// TODO!!!
					;				
				END_IF
			END_IF
		ELSE
			// Not enabled... Next station
			iStationID := iStationID + 1;
		END_IF
		IF (iStationID >= 5) THEN
			// All added
			iStationID := 1;
//			eTrackState := E_TrackState.InitPathsStations;	// init paths from stations, traffic lights and decision point 
			eTrackState := E_TrackState.SetPreBufferAdjust;
		END_IF
		
	E_TrackState.SetPreBufferAdjust:
		IF (aStations[iStationID].bPresent) THEN
			IF (aStationPreBufAdj[iStationID] <> 0.0) THEN
				iRes := M_CallAdjustBufferPosition(	nStationNo := iStationID,
													eBufferType := E_MMStationBuffer.eMMStationBuffer_PreProcess,
													rDistance := aStationPreBufAdj[iStationID]	);
				IF (iRes = 2) THEN
					// Success... Next station
					iStationID := iStationID + 1;
				ELSIF (iRes = 3) THEN
					// Error!
					// TODO!!!
					;
				END_IF
				
			ELSE
				// No adustment needed
				iStationID := iStationID + 1;
			END_IF
		ELSE
			// Not enabled... Next station
			iStationID := iStationID + 1;
		END_IF
		IF (iStationID >= 5) THEN
			// All checked/adjusted
			iStationID := 1;
			eTrackState := E_TrackState.SetPostBufferAdjust;
		END_IF
		
	E_TrackState.SetPostBufferAdjust:
		IF (aStations[iStationID].bPresent) THEN
			IF (aStationPostBufAdj[iStationID] <> 0.0) THEN
				iRes := M_CallAdjustBufferPosition(	nStationNo := iStationID,
													eBufferType := E_MMStationBuffer.eMMStationBuffer_PostProcess,
													rDistance := aStationPostBufAdj[iStationID]	);
				IF (iRes = 2) THEN
					// Success... Next station
					iStationID := iStationID + 1;
				ELSIF (iRes = 3) THEN
					// Error!
					// TODO!!!
					;
				END_IF
				
			ELSE
				// No adustment needed
				iStationID := iStationID + 1;
			END_IF
		ELSE
			// Not enabled... Next station
			iStationID := iStationID + 1;
		END_IF
		IF (iStationID >= 5) THEN
			// All checked/adjusted
			iStationID := 1;
			eTrackState := E_TrackState.InitPaths;
		END_IF
		
	// Create/init paths on track server for this cell
	E_TrackState.InitPaths:	
		IF (aPaths[iPathID] > 0) THEN
			iRes := M_CallAddPath(nPathNo := aPaths[iPathID]);
			IF (iRes = 2) THEN
				// Success... Next Path
				abControlledPaths[aPaths[iPathID]] := TRUE;
				iPathID := iPathID + 1;
			ELSIF (iRes = 3) THEN
				// Error!
				// TODO!!!
				;
			END_IF
		ELSE
			// All added
			iPathID := 1;
			eTrackState := E_TrackState.InitGetCellIndex;
		END_IF
(*		
	// Create/init paths on track server for this cell
	E_TrackState.InitPathsStations:	
		IF (aStations[iStationID].bPresent) THEN
			IF (NOT bStationData1Done) THEN
				iRes := M_CallAddPath(nPathNo := aStations[iStationID].stStationData1.stLocation.nPathID);
				IF (iRes = 2) THEN
					// Success... Next station
					abControlledPaths[aStations[iStationID].stStationData1.stLocation.nPathID] := TRUE;
					bStationData1Done := TRUE;
					IF (aStations[iStationID].stStationData1.stLocation.nPathID = aStations[iStationID].stStationData2.stLocation.nPathID) THEN
						// Station 2 is on the same path
						bStationData2Done := TRUE;
						iStationID := iStationID + 1;						
					ELSE
						// Station 2 is on a different path
						
					END_IF
				ELSIF (iRes = 3) THEN
					// Error!
					// TODO!!!
					;
				END_IF
			ELSIF (NOT bStationData2Done) THEN
				iRes := M_CallAddPath(nPathNo := aStations[iStationID].stStationData2.stLocation.nPathID);
				IF (iRes = 2) THEN
					// Success... Next station
					abControlledPaths[aStations[iStationID].stStationData2.stLocation.nPathID] := TRUE;
					bStationData2Done := TRUE;
					iStationID := iStationID + 1;
				ELSIF (iRes = 3) THEN
					// Error!
					// TODO!!!
					;
				END_IF
			END_IF
		ELSE
			// Not enabled... Next station
			iStationID := iStationID + 1;
		END_IF
		IF (iStationID >= 5) THEN
			// All added
			iStationID := 1;
			eTrackState := E_TrackState.InitPathsDecisionPoint;
		END_IF
	
	// Create/init paths on track server for this cell
	E_TrackState.InitPathsDecisionPoint:	
		IF (aStations[iStationID].bPresent) THEN
			iRes := M_CallAddPath(nPathNo := aStations[iStationID].stDecisionLocation.nPathID);
			IF (iRes = 2) THEN
				// Success... Next station
				abControlledPaths[aStations[iStationID].stDecisionLocation.nPathID] := TRUE;
				iStationID := iStationID + 1;
			ELSIF (iRes = 3) THEN
				// Error!
				// TODO!!!
				;
			END_IF
		ELSE
			// Not enabled... Next station
			iStationID := iStationID + 1;
		END_IF
		IF (iStationID >= 5) THEN
			// All added
			iStationID := 1;
			eTrackState := E_TrackState.InitPathsTrafficLight;
		END_IF

	// Create/init paths on track server for this cell
	E_TrackState.InitPathsTrafficLight:	
		IF (stTrafficLightLocation.nPathID > 0) THEN
			iRes := M_CallAddPath(nPathNo := stTrafficLightLocation.nPathID);	
			IF (iRes = 2) THEN
				// Success
				abControlledPaths[stTrafficLightLocation.nPathID] := TRUE;
				eTrackState := E_TrackState.InitGetCellIndex;
			ELSIF (iRes = 3) THEN
				// Error!
				// TODO!!!
				;
			END_IF
		ELSE
			eTrackState := E_TrackState.InitGetCellIndex;			
		END_IF
*)
	E_TrackState.InitGetCellIndex:
		iRes := M_CallGetCellIndex(sCellID);
		IF (iRes = 2) THEN
			// Success... Init done
			// Save found index
			iThisCellIndex := stGetCellIndexData.stOutput.nCellIndex;
			bTrackInitDone := TRUE;
			eTrackState := E_TrackState.Resetting;
		ELSIF (iRes = 3) THEN
			// Error!
			// TODO!!!
			;
		END_IF	
	
	E_TrackState.Starting:
		IF (abControlledPaths[iPathID]) THEN
			// This path is controlled by this cell
			iRes := M_CallStartPath(nPathNo := iPathID);
			IF (iRes = 2) THEN
				// Success... Next station
				iPathID := iPathID + 1;
			ELSIF (iRes = 3) THEN
				// Error!
				// TODO!!!
				;
			END_IF
			
		ELSE
			iPathID := iPathID + 1;
		END_IF
		IF (iPathID >= MM_MAX_NUMBER_OF_PATH_ELEMENTS) THEN
			// All started
			iPathID := 1;
			bPathsOperational := TRUE;
			bPathsSuspended := FALSE;
			eTrackState := E_TrackState.StartCheck;
		END_IF
	
	E_TrackState.StartCheck:
		IF (abControlledPaths[iPathID]) THEN
			// Is this path controlled by this cell
			IF (aReadPathData[iPathID].stPathData.bPathPresent AND (aReadPathData[iPathID].stPathData.nState = E_MMPathState.eMMPathState_Operational)) THEN
				// This path is operational
				bPathsOperational := bPathsOperational AND TRUE;
			ELSE
				// Not operational
				bPathsOperational := FALSE;
			END_IF
			IF (aReadPathData[iPathID].stPathData.nMotionStatus = E_MMPathMotionStatus.eMMPathMotionStatus_SuspendedByCommand) THEN
				// This path is suspended!
				bPathsSuspended := TRUE;
			END_IF
		END_IF
		iPathID := iPathID + 1;
		IF (iPathID > MM_MAX_NUMBER_OF_PATH_ELEMENTS) THEN
			IF (bPathsOperational) THEN
				// All paths OK... Continue
				iPathID := 1;
				eTrackState := E_TrackState.InitTrafficLight;
			ELSIF (NOT bEnable) THEN
				// Stop
				eTrackState := E_TrackState.Undefined;			
			ELSE
				// All paths NOT OK!
				bPathsOperational := TRUE;
				bPathsSuspended := FALSE;
				iPathID := 1;
			END_IF
		END_IF
	
	E_TrackState.InitTrafficLight:
		// Check if Traffic light is defined!
		IF (stTrafficLightLocation.nPathID > 0) THEN
			iRes := M_CallAddTrafficLight(	nTrafficLightID := 1,
											nPathID := stTrafficLightLocation.nPathID,
											fPosition := stTrafficLightLocation.fPosition);
			IF (iRes = 2) THEN
				// Success... Init done
				eTrackState := E_TrackState.InitTrafficLight2;
			ELSIF (iRes = 3) THEN
				// Error!
				// TODO!!!
				;				
			END_IF
		ELSE
			eTrackState := E_TrackState.InitTrafficLight2;
		END_IF
	
	E_TrackState.InitTrafficLight2:
		// Check if Traffic light 2 is defined!
		IF (stTrafficLight2Location.nPathID > 0) THEN
			iRes := M_CallAddTrafficLight(	nTrafficLightID := 2,
											nPathID := stTrafficLight2Location.nPathID,
											fPosition := stTrafficLight2Location.fPosition);
			IF (iRes = 2) THEN
				// Success... Init done
				eTrackState := E_TrackState.InitPathSegment;
			ELSIF (iRes = 3) THEN
				// Error!
				// TODO!!!
				;				
			END_IF
		ELSE
			eTrackState := E_TrackState.InitPathSegment;
		END_IF

	E_TrackState.InitPathSegment:
		// Check if Path Segment is defined!
		IF (stExitPointSeg1LocBegin.nPathID > 0) THEN
			iRes := M_CallAddPathSegment(	iSegmentNo := 1,
											nPathNo := stExitPointSeg1LocBegin.nPathID,
											rBeginPosition := stExitPointSeg1LocBegin.fPosition,
											rEndPosition := stExitPointSeg1LocEnd.fPosition);
			IF (iRes = 2) THEN
				// Success... Init done
				eTrackState := E_TrackState.InitPathSegment2;
			ELSIF (iRes = 3) THEN
				// Error!
				// TODO!!!
				;				
			END_IF
		ELSE
			eTrackState := E_TrackState.InitPathSegment2;
		END_IF
	
	E_TrackState.InitPathSegment2:
		// Check if Path Segment is defined!
		IF (stExitPointSeg2LocBegin.nPathID > 0) THEN
			iRes := M_CallAddPathSegment(	iSegmentNo := 2,
											nPathNo := stExitPointSeg2LocBegin.nPathID,
											rBeginPosition := stExitPointSeg2LocBegin.fPosition,
											rEndPosition := stExitPointSeg2LocEnd.fPosition);
			IF (iRes = 2) THEN
				// Success... Init done
				eTrackState := E_TrackState.InitVehicles;
			ELSIF (iRes = 3) THEN
				// Error!
				// TODO!!!
				;				
			END_IF
		ELSE
			eTrackState := E_TrackState.InitVehicles;
		END_IF
	
	E_TrackState.InitVehicles:
		IF (bVehicleInitDone) THEN
			// Init done, go to started!
			eTrackState := E_TrackState.Started;
		ELSE
			iVehicleIndex := iVehicleIndex + 1;	// Start from 0!
			IF (aReadCellData.stCell.anVehicles[iVehicleIndex] > 0) THEN
				// Handle this vehicle
				iRes := M_CallMoveVehicleToScanner(	eInputType := E_MMVehicleInputType.eMMVehicleInputType_VehicleID,
													sInput := UINT_TO_STRING(aReadCellData.stCell.anVehicles[iVehicleIndex]),
													eDirection := E_MMDirection.eMMDirection_Forward, 
													fVelocity := 1,
													fAcceleration := 1 	);
				IF (iRes = 2) THEN
					// Next vehicle
					iVehicleIndex := iVehicleIndex + 1;
				ELSIF (iRes = 3) THEN
					// Error!
					// TODO!!!
					;
				END_IF
			ELSE
				// Next vehicle
				iVehicleIndex := iVehicleIndex + 1;
			END_IF
			IF (iVehicleIndex >= MM_MAX_NUMBER_OF_VEHICLE_ELEMENTS) THEN
				// All inited
				bVehicleInitDone := TRUE;
				iVehicleIndex := 0;
				eTrackState := E_TrackState.Started;
			END_IF
		END_IF
		
	E_TrackState.Started:
		bStarted := TRUE;
		IF (NOT bEnable) THEN
			// Disable
			eTrackState := E_TrackState.Undefined;
		ELSIF (iThisCellIndex <= 0) THEN
			// Re-Init cell index from track server
			iRes := M_CallGetCellIndex(sCellID);
			IF (iRes = 2) THEN
				// Success... Init done
				// Save found index
				iThisCellIndex := stGetCellIndexData.stOutput.nCellIndex;
			ELSIF (iRes = 3) THEN
				// Error!
				// TODO!!!
				;
			END_IF	
		ELSIF (bSuspend) THEN
			// Activate suspend on paths
			eTrackState := E_TrackState.Suspend;
		ELSIF (bPathsSuspended AND NOT bSuspend) THEN
			// Some paths are suspended and should not be
			eTrackState := E_TrackState.Resume;
		END_IF

	E_TrackState.Suspend:
		IF ( abControlledPaths[iPathID] AND (aReadPathData[iPathID].stPathData.nMotionStatus <> E_MMPathMotionStatus.eMMPathMotionStatus_SuspendedByCommand) ) THEN
			// This path is controlled by this cell and is not suspended
			iRes := M_CallSuspendPath(nPathNo := iPathID);
			IF (iRes = 2) THEN
				// Success... Next station
				iPathID := iPathID + 1;
			ELSIF (iRes = 3) THEN
				// Error!
				// TODO!!!
				;
			END_IF
		ELSE
			iPathID := iPathID + 1;
		END_IF
		IF (iPathID >= MM_MAX_NUMBER_OF_PATH_ELEMENTS) THEN
			// All suspended
			iPathID := 1;
			bPathsSuspended := TRUE;
			eTrackState := E_TrackState.Suspending;
		END_IF
		
	E_TrackState.Suspending:
		IF (abControlledPaths[iPathID]) THEN
			// Is this path controlled by this cell
			IF (aReadPathData[iPathID].stPathData.nMotionStatus = E_MMPathMotionStatus.eMMPathMotionStatus_SuspendedByCommand) THEN
				// This path is suspended
				bPathsSuspended := bPathsSuspended AND TRUE;
			ELSE
				// Not operational
				bPathsSuspended := FALSE;
			END_IF
		END_IF
		iPathID := iPathID + 1;
		IF (iPathID > MM_MAX_NUMBER_OF_PATH_ELEMENTS) THEN
			IF (bPathsSuspended) THEN
				// All paths Suspended... Continue
				iPathID := 1;
				eTrackState := E_TrackState.Suspended;
			ELSIF (NOT bEnable) THEN
				// Stop
				eTrackState := E_TrackState.Undefined;			
			ELSE
				// All paths NOT Suspended!
				iPathID := 1;
				bPathsSuspended := TRUE;
			END_IF
		END_IF		
	
	E_TrackState.Suspended:
		IF (NOT bSuspend) THEN
			bSuspended := FALSE;
			eTrackState := E_TrackState.Resume;
		ELSIF (NOT bEnable) THEN
			eTrackState := E_TrackState.Undefined;			
		END_IF
		
	E_TrackState.Resume:
		IF ( abControlledPaths[iPathID] AND aReadPathData[iPathID].stPathData.nMotionStatus = E_MMPathMotionStatus.eMMPathMotionStatus_SuspendedByCommand ) THEN
			// This path is controlled by this cell
			iRes := M_CallResumePath(nPathNo := iPathID);
			IF (iRes = 2) THEN
				// Success... Next station
				iPathID := iPathID + 1;
			ELSIF (iRes = 3) THEN
				// Error!
				// TODO!!!
				;
			END_IF
			
		ELSE
			iPathID := iPathID + 1;
		END_IF
		IF (iPathID >= MM_MAX_NUMBER_OF_PATH_ELEMENTS) THEN
			// All started
			iPathID := 1;
			bPathsResumed := TRUE;
			eTrackState := E_TrackState.Resuming;
		END_IF
	
	E_TrackState.Resuming:
		IF (abControlledPaths[iPathID]) THEN
			// Is this path controlled by this cell
			IF (aReadPathData[iPathID].stPathData.nMotionStatus <> E_MMPathMotionStatus.eMMPathMotionStatus_SuspendedByCommand) THEN
				// This path is operational
				bPathsResumed := bPathsResumed AND TRUE;
			ELSE
				// Not operational
				bPathsResumed := FALSE;
			END_IF
		END_IF
		iPathID := iPathID + 1;
		IF (iPathID > MM_MAX_NUMBER_OF_PATH_ELEMENTS) THEN
			IF (bPathsResumed) THEN
				// All paths Resumed... Continue
				iPathID := 1;
				bPathsSuspended := FALSE;
				eTrackState := E_TrackState.Started;
			ELSIF (NOT bEnable) THEN
				// Stop
				eTrackState := E_TrackState.Undefined;			
			ELSE
				// All paths NOT OK!
				bPathsResumed := TRUE;
				iPathID := 1;
			END_IF
		END_IF		
	
	E_TrackState.Resetting:
		IF (abControlledPaths[iPathID]) THEN
			// This path is controlled by this cell
			iRes := M_CallResetPath(nPathNo := iPathID);
			IF (iRes = 2) THEN
				// Success... Next station
				iPathID := iPathID + 1;
			ELSIF (iRes = 3) THEN
				// Error!
				// TODO!!!
				;
			END_IF
			
		ELSE
			iPathID := iPathID + 1;
		END_IF
		IF (iPathID >= MM_MAX_NUMBER_OF_PATH_ELEMENTS) THEN
			// All reset
			iPathID := 1;
			eTrackState := E_TrackState.ResetWait;
		END_IF

	E_TrackState.ResetWait:
		tonResetTime(IN := TRUE, PT := T#4S);
		IF (tonResetTime.Q) THEN
			tonResetTime(IN := FALSE);
			eTrackState := E_TrackState.ResetCheck;						
		END_IF
	
	E_TrackState.ResetCheck:
		IF (abControlledPaths[iPathID]) THEN
			// Is this path controlled by this cell
			IF (aReadPathData[iPathID].stPathData.bPathPresent AND
				( (aReadPathData[iPathID].stPathData.nState = E_MMPathState.eMMPathState_Operational) OR (aReadPathData[iPathID].stPathData.nState = E_MMPathState.eMMPathState_Initialization) )) THEN
				// This path is operational or reset completed
				bPathsReset := bPathsReset AND TRUE;
			ELSE
				// Not operational
				bPathsReset := FALSE;
			END_IF
		END_IF
		iPathID := iPathID + 1;
		IF (iPathID > MM_MAX_NUMBER_OF_PATH_ELEMENTS) THEN
			IF (bPathsReset) THEN
				// All paths OK... Continue
				iPathID := 1;
				eTrackState := E_TrackState.Idle;
			ELSIF (NOT bEnable) THEN
				// Stop
				eTrackState := E_TrackState.Undefined;			
			ELSE
				// All paths NOT OK!
				bPathsReset := TRUE;
				iPathID := 1;
			END_IF
		END_IF

	E_TrackState.Idle:
		IF (bEnable) THEN
			eTrackState := E_TrackState.Undefined;
		END_IF

	E_TrackState.Error:

END_CASE

tonSkipPathRead(IN := (eTrackState = E_TrackState.Started),
				PT := T#5S,
				Q => ,
				ET =>	);

// Shut down track from OPC-UA interface
IF (stAdditionalDataIn.bShutDown) THEN
	stAdditionalDataIn.bShutDown := FALSE;
	bEnable := FALSE;
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_StateMachineMethod" Id="{d89a46e6-0e6c-475c-b1d1-e8c3887e2e35}">
      <Declaration><![CDATA[METHOD PROTECTED M_StateMachineMethod : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[CASE eStateMethod OF
	E_TrackClientState.Disconnected:
		bConnectedMethod := FALSE;
		bBusyMethod := FALSE;
		fbConnectMethod.Execute := FALSE;
		fbDisconnectMethod.Execute := FALSE;
		fbGetNamespaceMethod.Execute := FALSE;
		fbGetHandleMethod.Execute := FALSE;
		fbCallMethod.Execute := FALSE;
		fbReleaseHandleMethod.Execute := FALSE;
		IF (bEnable) THEN
			bErrorMethod := FALSE;
			nErrorMethodID := 0;
			eStateMethod := E_TrackClientState.Connecting;
		END_IF
	
	E_TrackClientState.Connecting:
		IF (fbConnectMethod.Execute AND NOT fbConnectMethod.Busy) THEN
			fbConnectMethod.Execute := FALSE;
			IF (NOT fbConnectMethod.Error) THEN
				(* Connected *)
				nConnectHdlMethod := fbConnectMethod.ConnectionHdl;
				eStateMethod := E_TrackClientState.GetNamespaceIndex;
			ELSE
				(* Error during connection *)
				bErrorMethod := TRUE;
				nErrorMethodID := fbConnectMethod.ErrorID;
				eLastErrorMethodID := nErrorMethodID;
				nConnectHdlMethod := 0;
				eStateMethod := E_TrackClientState.Error;
			END_IF
		ELSE
			fbConnectMethod.Execute := TRUE;		
		END_IF
	
	E_TrackClientState.GetNamespaceIndex:
		IF (fbGetNamespaceMethod.Execute AND NOT fbGetNamespaceMethod.Busy) THEN
			fbGetNamespaceMethod.Execute := FALSE;
			IF (NOT fbGetNamespaceMethod.Error) THEN
				nNameSpaceIndexMethod := fbGetNamespaceMethod.NamespaceIndex;
				eStateMethod := E_TrackClientState.Connected;
			ELSE
				(* Error during get namepsace index *)
				nNameSpaceIndexMethod := 0;
				bErrorMethod := TRUE;
				nErrorMethodID := fbGetNamespaceMethod.ErrorID;
				eStateMethod := E_TrackClientState.Disconnecting;
			END_IF
		ELSE
			fbGetNamespaceMethod.Execute := TRUE;
		END_IF
	
	E_TrackClientState.Connected:
		bConnectedMethod := TRUE;
		bBusyMethod := FALSE;
		IF (NOT bEnable) THEN
			bConnectedMethod := FALSE;
			eStateMethod := E_TrackClientState.Disconnecting;
		ELSIF (bCallMethod) THEN
			bCallMethod := FALSE;
			bBusyMethod := TRUE;
			eStateMethod := E_TrackClientState.GetHandle;
		END_IF
		
	E_TrackClientState.GetHandle:
		IF (fbGetHandleMethod.Execute AND NOT fbGetHandleMethod.Busy) THEN
			fbGetHandleMethod.Execute := FALSE;
			IF (NOT fbGetHandleMethod.Error) THEN
				nHandleMethod := fbGetHandleMethod.MethodHdl;
				eStateMethod := E_TrackClientState.Execute;
			ELSE
				(* Error during get method handle *)
				nHandleMethod := 0;
				bErrorMethod := TRUE;
				nErrorMethodID := fbGetHandleMethod.ErrorID;
				eStateMethod := E_TrackClientState.Disconnecting;
			END_IF
		ELSE
			fbGetHandleMethod.Execute := TRUE;
		END_IF

	E_TrackClientState.Execute:
		IF (fbCallMethod.Execute AND NOT fbCallMethod.Busy) THEN
			fbCallMethod.Execute := FALSE;
			IF (NOT fbCallMethod.Error) THEN
				eStateMethod := E_TrackClientState.ReleaseHandle;
			ELSE
				(* Error during get namespace index *)
				bErrorMethod := TRUE;
				nErrorMethodID := fbCallMethod.ErrorID;
				eStateMethod := E_TrackClientState.ReleaseHandle;
			END_IF
		ELSE
			fbCallMethod.Execute := TRUE;
		END_IF
	
	E_TrackClientState.ReleaseHandle:
		IF (fbReleaseHandleMethod.Execute AND NOT fbReleaseHandleMethod.Busy) THEN
			fbReleaseHandleMethod.Execute := FALSE;
			IF (bErrorMethod) THEN
				eStateMethod := E_TrackClientState.Error;	
				nHandleMethod := 0;
			ELSIF (NOT fbReleaseHandleMethod.Error) THEN
				nHandleMethod := 0;
				eStateMethod := E_TrackClientState.Connected;
			ELSE
				(* Error during release handle *)
				bErrorMethod := TRUE;
				nErrorMethodID := fbReleaseHandleMethod.ErrorID;
				nHandleMethod := 0;
				eStateMethod := E_TrackClientState.Disconnecting;
			END_IF
		ELSE
			fbReleaseHandleMethod.Execute := TRUE;
		END_IF
	
	E_TrackClientState.Disconnecting:
		bConnectedMethod := FALSE;
		IF (fbDisconnectMethod.Execute AND NOT fbDisconnectMethod.Busy) THEN
			fbDisconnectMethod.Execute := FALSE;
			IF (bErrorMethod) THEN
				eStateMethod := E_TrackClientState.Error;	
				nConnectHdlMethod := 0;				
			ELSIF (NOT fbDisconnectMethod.Error) THEN
				(* Disconnected *)
				nConnectHdlMethod := 0;
				eStateMethod := E_TrackClientState.Disconnected;
			ELSE
				(* Error during disconnection *)
				bErrorMethod := TRUE;
				nErrorMethodID := fbDisconnectMethod.ErrorID;
				nConnectHdlMethod := 0;
				eStateMethod := E_TrackClientState.Error;
			END_IF
		ELSE
			fbDisconnectMethod.Execute := TRUE;
		END_IF
	
	E_TrackClientState.Error:
		eStateMethod := E_TrackClientState.Disconnected;
		
END_CASE
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_StateMachineNode_ADS" Id="{6dcba053-df50-46f8-98a7-c28bc41e7c44}">
      <Declaration><![CDATA[METHOD PROTECTED M_StateMachineNode_ADS : INT
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[CASE eStateNode OF
	E_TrackClientState.Disconnected:
		bConnectedNode := FALSE;
		fbReadADS( bEnable := FALSE ); 
		IF (bEnable) THEN
			bErrorNode := FALSE;
			nErrorNodeID := 0;
			eStateNode := E_TrackClientState.Connected;
		END_IF
	
	E_TrackClientState.Connecting:
		eStateNode := E_TrackClientState.GetNamespaceIndex;
	
	E_TrackClientState.GetNamespaceIndex:
		eStateNode := E_TrackClientState.Connected;
	
	E_TrackClientState.Connected:	
//		bConnectedNode := TRUE;
		IF (NOT bEnable) THEN
			bConnectedNode := FALSE;
			eStateNode := E_TrackClientState.Disconnecting;
		ELSIF (M_InitNodeData_ADS()) THEN
			eStateNode := E_TrackClientState.Execute;			
		END_IF
		
	E_TrackClientState.GetHandle:
		eStateNode := E_TrackClientState.Execute;
	
	E_TrackClientState.Execute:
		fbReadADS(	bEnable:= TRUE, 
							eType:= E_ADS_Comm_Type.ADS_RD_FAST, 
							rInterval:= rReadInterval, 
							pLocalVar:= pReadNodeData, // M_InitNodeData_ADS 
							nLocalSize:= UDINT_TO_UINT(cbDataTotal), // M_InitNodeData_ADS
							sNetID:= sTrackServerNetID, 
							nPort:= nTrackServerPortNo, 
							sVarName:= sTrackServerSymbol, // M_InitNodeData_ADS
							bWriteError=> , 
							bReadError=> , 
							bParameterError=> );
		IF (fbReadADS.bReadError OR fbReadADS.bParameterError) THEN
			eStateNode := E_TrackClientState.Error;			
		ELSIF (fbReadADS.M_SendRecvCompleted()) THEN
			bConnectedNode := TRUE;
			fbReadADS( bEnable := FALSE );
			IF (bReadDecPointVehicleBusy) THEN
				// Reading of decision point vehicle data has completed! 
				bReadDecPointVehicleBusy := FALSE;
			
			ELSIF (eReadType = E_OPC_NodeType.Stations) THEN
				// Reading stations
				IF (F_StringCompNoCase(aReadStationData[iReadIndex].stStationData.sCellID, sCellID)) THEN
					// The read station belongs to this cell
					FOR iStatIndex := 1 TO 5 BY 1 DO
						 IF (aStations[iStatIndex].bPresent) THEN
							// Station is present, check station ID against the read station ID
							IF (F_StringCompNoCase(aReadStationData[iReadIndex].stStationData.sStationID, aStations[iStatIndex].sStationID)) THEN
								// Found matching station ID. Store it...
								iThisStationIndex[iStatIndex] := iReadIndex;
							END_IF
						ELSE
							iThisStationIndex[iStatIndex] := 0;
						END_IF
					END_FOR
				END_IF
			
			ELSIF (bReadDecPointCell) THEN
				// Reading cell data completed
				bReadDecPointCell := FALSE;
				bReadDecPointCellDone := TRUE;
			
			END_IF
			
			eStateNode := E_TrackClientState.Connected;
			iLastReadTimeMS := iReadTimeMS;
			iReadTimeMS := 0;
		END_IF
	
	E_TrackClientState.ReleaseHandle:
		eStateNode := E_TrackClientState.Connected;
	
	E_TrackClientState.Disconnecting:
		bConnectedNode := FALSE;
		eStateNode := E_TrackClientState.Disconnected;
	
	E_TrackClientState.Error:
		tonErrorReset.IN := TRUE;
		IF (tonErrorReset.Q) THEN
			tonErrorReset.IN := FALSE;
			eStateNode := E_TrackClientState.Disconnected;
		END_IF
		
END_CASE

// Read timer
iReadTimeMS := iReadTimeMS + 10;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_ThisCellDataIndex" Id="{11157ab8-8c73-4a36-913e-bbb5350ce1c2}">
      <Declaration><![CDATA[METHOD PROTECTED M_ThisCellDataIndex : UINT
VAR_INPUT
END_VAR
VAR
	i		: UINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Locate the status data for this cell!

(*
// Check if a value is already found
IF (iThisCellIndex > 0) THEN 
	// Check previous found value
	IF (F_StringCompNoCase(	s1 := sCellID, s2 := aReadCellData[iThisCellIndex].stCell.sCellID)) THEN
		// Previous found value is OK
		;
	ELSE
		// Previous found value is NOT OK, find correct value
		iThisCellIndex := 0;
	END_IF
END_IF

IF (iThisCellIndex = 0) THEN 
	// Find correct value
	FOR i := 1 TO MM_MAX_NUMBER_OF_STATION_ELEMENTS BY 1 DO
		IF (F_StringCompNoCase(sCellID, s2 := aReadCellData[i].stCell.sCellID)) THEN
			// Correct cell ID found
			iThisCellIndex := i;
			EXIT;
		END_IF
	END_FOR
END_IF
*)

M_ThisCellDataIndex := iThisCellIndex;	
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_UpdateStatus" Id="{5f0f8b17-844e-4675-bc4e-f1b959826218}">
      <Declaration><![CDATA[METHOD PROTECTED M_UpdateStatus : BOOL
VAR_INPUT
END_VAR
VAR
	iBuffer				: UINT;
	iVehicleID			: UINT;
	iVehicleIndex		: UINT;
	bDataChanged		: BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Update status values

// Check if LC allows to change status data
IF (stAdditionalDataIn.MESHandShakes.DataChangeStatusTransportStatus = stStatus.DataChange) THEN
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// Vehicles
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	iVehicleIndex := 1;
	iVehicleID := 1;
	bDataChanged := FALSE;
	MEMSET(ADR(stStatus.Carrier), 0, SIZEOF(stStatus.Carrier));
	WHILE iVehicleID < MM_MAX_NUMBER_OF_VEHICLE_ELEMENTS DO
	
		IF ((aReadVehicleData[iVehicleID].stVehicle.nVehicleID > 0) AND
			(aReadVehicleData[iVehicleID].stVehicle.bDataValid) ) THEN
			// Vehicle has valid data
			IF ((aReadVehicleData[iVehicleID].stVehicle.sOwnerCell = sCellID) AND M_CheckVehicleOwned(aReadVehicleData[iVehicleID].stVehicle.nVehicleID)) THEN
				// Vehicle belongs to this cell
				stStatus.Carrier[iVehicleIndex].CarrierID := aReadVehicleData[iVehicleID].stVehicle.sCarrierID;
				stStatus.Carrier[iVehicleIndex].CarriersInPackage := aReadVehicleData[iVehicleID].stVehicle.nTicketSize; 
				stStatus.Carrier[iVehicleIndex].CarrierStatus := aReadVehicleData[iVehicleID].stVehicle.nState;
				stStatus.Carrier[iVehicleIndex].CurrentPath := aReadVehicleData[iVehicleID].stVehicle.nPathID;
				stStatus.Carrier[iVehicleIndex].CurrentPosition := aReadVehicleData[iVehicleID].stVehicle.fPosition;
				stStatus.Carrier[iVehicleIndex].CurrentStation := aReadVehicleData[iVehicleID].stVehicle.sCurrentStationID;
				stStatus.Carrier[iVehicleIndex].JobID := aReadVehicleData[iVehicleID].stVehicle.sJobID;
				IF (aReadVehicleData[iVehicleID].stVehicle.sLastScan <> '') THEN
					stStatus.Carrier[iVehicleIndex].LastScan := STRING_TO_DT(CONCAT('DT#', aReadVehicleData[iVehicleID].stVehicle.sLastScan));
				END_IF
				stStatus.Carrier[iVehicleIndex].Material := aReadVehicleData[iVehicleID].stVehicle.bMaterial;
				stStatus.Carrier[iVehicleIndex].MaterialID := aReadVehicleData[iVehicleID].stVehicle.sMaterialID;
				stStatus.Carrier[iVehicleIndex].Priority := aReadVehicleData[iVehicleID].stVehicle.nPriority;
				IF (aReadVehicleData[iVehicleID].stVehicle.sTargetStationID <> '') THEN
					stStatus.Carrier[iVehicleIndex].TargetReached := (aReadVehicleData[iVehicleID].stVehicle.sTargetStationID = aReadVehicleData[iVehicleID].stVehicle.sCurrentStationID);
				ELSE
					stStatus.Carrier[iVehicleIndex].TargetReached := FALSE;
				END_IF
				// Update Target Reached Counter
				IF ((aOldVehicleData[iVehicleID].sCurrentStationID = '') AND (aReadVehicleData[iVehicleID].stVehicle.sCurrentStationID <> '')) THEN
					IF (aReadVehicleData[iVehicleID].stVehicle.sTargetStationID = aReadVehicleData[iVehicleID].stVehicle.sCurrentStationID) THEN
						// First scan this vehicle is on position
						aOldVehicleTargetReachedCnt[iVehicleID] := aOldVehicleTargetReachedCnt[iVehicleID] + 1;
						IF (aOldVehicleTargetReachedCnt[iVehicleID] >= 100) THEN
							aOldVehicleTargetReachedCnt[iVehicleID] := 0;
						END_IF
					END_IF
				END_IF
				stStatus.Carrier[iVehicleIndex].TargetReachedCounter := (iThisCellIndex * 100) + aOldVehicleTargetReachedCnt[iVehicleID];
				stStatus.Carrier[iVehicleIndex].TargetStation := aReadVehicleData[iVehicleID].stVehicle.sTargetStationID;
				stStatus.Carrier[iVehicleIndex].Ticket := aReadVehicleData[iVehicleID].stVehicle.nTicket;
				stStatus.Carrier[iVehicleIndex].Tool := aReadVehicleData[iVehicleID].stVehicle.bTool;
				stStatus.Carrier[iVehicleIndex].ToolID := aReadVehicleData[iVehicleID].stVehicle.sToolID;
				stStatus.Carrier[iVehicleIndex].ValidData := aReadVehicleData[iVehicleID].stVehicle.bDataValid;
				stStatus.Carrier[iVehicleIndex].NOK := aReadVehicleData[iVehicleID].stVehicle.bNOK;
				
				iVehicleIndex := iVehicleIndex + 1;
				
				// Compare with old vehicle data
				bDataChanged := bDataChanged OR M_UpdateStatusCompare(iVehicleID);
			END_IF
		END_IF
	
		// Save as old vehicle data
		aOldVehicleData[iVehicleID] := aReadVehicleData[iVehicleID].stVehicle;
		
		// Next vehicle
		iVehicleID := iVehicleID + 1;
	END_WHILE
	stStatus.NumberOfCarriers := (iVehicleIndex - 1);
	// Check if number of carriers has changed and update data if it has
	IF (stStatus.NumberOfCarriers <> iOldVehicleCount) THEN
		bDataChanged := TRUE;
		iOldVehicleCount := stStatus.NumberOfCarriers;
	END_IF
	
	// Check if data has changed
	IF (bDataChanged OR bForceVehicleUpdateOPC) THEN
		bForceVehicleUpdateOPC := FALSE;
		stStatus.DataChange := stStatus.DataChange + 1;
	END_IF
	
	
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// Stations
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	iStation := iStation + 1;
	IF (iStation > 5) THEN
		iStation := 1;
	END_IF
	// Station ID
	stStatus.StationBuffer[iStation].StationID := aStations[iStation].sStationID;
	IF (aStations[iStation].bPresent) THEN
		// Station 1 (input) values (placed at the first Pre-buffer index!)
		stStatus.StationBuffer[iStation].PreBuffer.BufferIndex[1].Present := aStations[iStation].stStationData1.bPresent;
		stStatus.StationBuffer[iStation].PreBuffer.BufferIndex[1].CarrierID := M_VehicleIDToCarrierID(aStations[iStation].stStationData1.nCurrentVehicleID);
		stStatus.StationBuffer[iStation].PreBuffer.BufferIndex[1].Ticket := aStations[iStation].stStationData1.nTicket;
		// Station 2 (output) values (placed at the first Post-buffer index!)
		stStatus.StationBuffer[iStation].PostBuffer.BufferIndex[1].Present := aStations[iStation].stStationData2.bPresent;
		stStatus.StationBuffer[iStation].PostBuffer.BufferIndex[1].CarrierID := M_VehicleIDToCarrierID(aStations[iStation].stStationData2.nCurrentVehicleID);
		stStatus.StationBuffer[iStation].PostBuffer.BufferIndex[1].Ticket := aStations[iStation].stStationData2.nTicket;
		// Buffers
		stStatus.StationBuffer[iStation].PreBuffer.Capacity := 0;
		stStatus.StationBuffer[iStation].PreBuffer.CapacityUsed := 0;
		stStatus.StationBuffer[iStation].PostBuffer.Capacity := 0;
		stStatus.StationBuffer[iStation].PostBuffer.CapacityUsed := 0;
		FOR iBuffer := 1 TO MM_MAX_BUFFER_INDEX BY 1 DO
			// Pre-buffer capacity
			IF (aStations[iStation].astPreBuffer[iBuffer].bPresent) THEN
				stStatus.StationBuffer[iStation].PreBuffer.Capacity := stStatus.StationBuffer[iStation].PreBuffer.Capacity + 1;
			END_IF
			// Pre-buffer used capacity
			IF (aStations[iStation].astPreBuffer[iBuffer].nCurrentVehicleID > 0) THEN
				stStatus.StationBuffer[iStation].PreBuffer.CapacityUsed := stStatus.StationBuffer[iStation].PreBuffer.CapacityUsed + 1;
			END_IF
			// Pre-buffer values
			stStatus.StationBuffer[iStation].PreBuffer.BufferIndex[iBuffer+1].Present := aStations[iStation].astPreBuffer[iBuffer].bPresent;
			stStatus.StationBuffer[iStation].PreBuffer.BufferIndex[iBuffer+1].CarrierID := M_VehicleIDToCarrierID(aStations[iStation].astPreBuffer[iBuffer].nCurrentVehicleID);
			stStatus.StationBuffer[iStation].PreBuffer.BufferIndex[iBuffer+1].Ticket := aStations[iStation].astPreBuffer[iBuffer].nTicket;
			// Post-buffer capacity
			IF (aStations[iStation].astPostBuffer[iBuffer].bPresent) THEN
				stStatus.StationBuffer[iStation].PostBuffer.Capacity := stStatus.StationBuffer[iStation].PostBuffer.Capacity + 1;
			END_IF
			// Post-buffer used capacity
			IF (aStations[iStation].astPostBuffer[iBuffer].nCurrentVehicleID > 0) THEN
				stStatus.StationBuffer[iStation].PostBuffer.CapacityUsed := stStatus.StationBuffer[iStation].PostBuffer.CapacityUsed + 1;
			END_IF
			// Post-buffer values
			stStatus.StationBuffer[iStation].PostBuffer.BufferIndex[iBuffer+1].Present := aStations[iStation].astPostBuffer[iBuffer].bPresent;
			stStatus.StationBuffer[iStation].PostBuffer.BufferIndex[iBuffer+1].CarrierID := M_VehicleIDToCarrierID(aStations[iStation].astPostBuffer[iBuffer].nCurrentVehicleID);
			stStatus.StationBuffer[iStation].PostBuffer.BufferIndex[iBuffer+1].Ticket := aStations[iStation].astPostBuffer[iBuffer].nTicket;
			
		END_FOR
	END_IF

END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_UpdateStatusCompare" Id="{7d09dc7d-0580-4962-897a-5c7e9c84fa80}">
      <Declaration><![CDATA[/// Compares two vehicle data sets. Returns TRUE if different
METHOD PROTECTED M_UpdateStatusCompare : BOOL
VAR_INPUT
	iVehicleID		: UINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
// Check for changes (uncomment/comment to choose which values should be compared!)
IF ( (iVehicleID >= 1) AND (iVehicleID <= MM_MAX_NUMBER_OF_VEHICLE_ELEMENTS) ) THEN
	IF ( 	(aReadVehicleData[iVehicleID].stVehicle.bDataValid <> aOldVehicleData[iVehicleID].bDataValid) OR
			(aReadVehicleData[iVehicleID].stVehicle.bMaterial <> aOldVehicleData[iVehicleID].bMaterial) OR
			(aReadVehicleData[iVehicleID].stVehicle.bNOK <> aOldVehicleData[iVehicleID].bNOK) OR
			(aReadVehicleData[iVehicleID].stVehicle.bTool <> aOldVehicleData[iVehicleID].bTool) OR
			(aReadVehicleData[iVehicleID].stVehicle.bVehiclePresent <> aOldVehicleData[iVehicleID].bVehiclePresent) OR
//			(aReadVehicleData[iVehicleID].stVehicle.fPosition <> aOldVehicleData[iVehicleID].fPosition) OR
//			(aReadVehicleData[iVehicleID].stVehicle.fTargetPosition <> aOldVehicleData[iVehicleID].fTargetPosition) OR
//			(aReadVehicleData[iVehicleID].stVehicle.fVelocity <> aOldVehicleData[iVehicleID].fVelocity) OR
//			(aReadVehicleData[iVehicleID].stVehicle.nPathID <> aOldVehicleData[iVehicleID].nPathID) OR
			(aReadVehicleData[iVehicleID].stVehicle.nPriority <> aOldVehicleData[iVehicleID].nPriority) OR
//			(aReadVehicleData[iVehicleID].stVehicle.nState <> aOldVehicleData[iVehicleID].nState) OR
//			(aReadVehicleData[iVehicleID].stVehicle.nTargetPathID <> aOldVehicleData[iVehicleID].nTargetPathID) OR
			(aReadVehicleData[iVehicleID].stVehicle.nTicket <> aOldVehicleData[iVehicleID].nTicket) OR
			(aReadVehicleData[iVehicleID].stVehicle.nTicketSize <> aOldVehicleData[iVehicleID].nTicketSize) OR
			(aReadVehicleData[iVehicleID].stVehicle.nVehicleID <> aOldVehicleData[iVehicleID].nVehicleID) OR
			(aReadVehicleData[iVehicleID].stVehicle.sCarrierID <> aOldVehicleData[iVehicleID].sCarrierID) OR
			(aReadVehicleData[iVehicleID].stVehicle.sCurrentStationID <> aOldVehicleData[iVehicleID].sCurrentStationID) OR
			(aReadVehicleData[iVehicleID].stVehicle.sJobID <> aOldVehicleData[iVehicleID].sJobID) OR
			(aReadVehicleData[iVehicleID].stVehicle.sLastScan <> aOldVehicleData[iVehicleID].sLastScan) OR
			(aReadVehicleData[iVehicleID].stVehicle.sMaterialID <> aOldVehicleData[iVehicleID].sMaterialID) OR
			(aReadVehicleData[iVehicleID].stVehicle.sOwnerCell <> aOldVehicleData[iVehicleID].sOwnerCell) OR
			(aReadVehicleData[iVehicleID].stVehicle.sTargetStationID <> aOldVehicleData[iVehicleID].sTargetStationID) OR
			(aReadVehicleData[iVehicleID].stVehicle.sToolID <> aOldVehicleData[iVehicleID].sToolID)
		) THEN
		// Change detected. Return TRUE
		M_UpdateStatusCompare := TRUE;
		RETURN;
	END_IF
END_IF

M_UpdateStatusCompare := FALSE;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_VehicleIDToCarrierID" Id="{1010ebd7-d6ed-40d5-97a1-367a1bc6d91f}">
      <Declaration><![CDATA[METHOD PROTECTED M_VehicleIDToCarrierID : STRING(30)
VAR_INPUT
	nVehicleID		: UINT;
END_VAR

VAR
	i: INT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[

IF (nVehicleID > 0 AND nVehicleID <= MM_MAX_NUMBER_OF_VEHICLE_ELEMENTS) THEN
	M_VehicleIDToCarrierID := aReadVehicleData[nVehicleID].stVehicle.sCarrierID;
	
ELSE
	M_VehicleIDToCarrierID := '';
	
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_VehicleToReadAdd" Id="{a0aa4f66-4471-4cda-a80e-bc2f02e6f23c}">
      <Declaration><![CDATA[/// Adds a vehicle to list of vehicles to read evnet-driven data from
METHOD M_VehicleToReadAdd : BOOL
VAR_INPUT
	iVehicleNo		: UINT;
END_VAR
VAR
	i				: UINT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[
IF (iVehicleNo > 0 AND iVehicleNo <= MM_MAX_NUMBER_OF_VEHICLE_ELEMENTS) THEN
	FOR i := 1 TO MM_MAX_NUMBER_OF_VEHICLE_ELEMENTS BY 1 DO
		IF (anVehiclesToRead[i] = iVehicleNo) THEN
			// Vehicle is already added
			M_VehicleToReadAdd := TRUE;
			RETURN;
		
		ELSIF (anVehiclesToRead[i] = 0) THEN
			// Empty index found
			anVehiclesToRead[i] := iVehicleNo;
			M_VehicleToReadAdd := TRUE;
			RETURN;
			
		END_IF
	END_FOR
	
ELSE
	// Not within range
	M_VehicleToReadAdd := FALSE;
	
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_VehicleToReadRemove" Id="{5f83c716-b2a2-4298-a7b9-54128794aacb}">
      <Declaration><![CDATA[/// Removes a vehicle from list of vehicles to read evnet-driven data from
METHOD M_VehicleToReadRemove : BOOL
VAR_INPUT
	iVehicleNo		: UINT;
END_VAR
VAR
	i				: UINT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[
IF (iVehicleNo > 0 AND iVehicleNo <= MM_MAX_NUMBER_OF_VEHICLE_ELEMENTS) THEN
	FOR i := 1 TO MM_MAX_NUMBER_OF_VEHICLE_ELEMENTS BY 1 DO
		IF (anVehiclesToRead[i] = iVehicleNo) THEN
			// Vehicle is found
			anVehiclesToRead[i] := 0;
			M_VehicleToReadRemove := TRUE;
			RETURN;
			
		END_IF
	END_FOR
	
ELSE
	// Not within range
	M_VehicleToReadRemove := FALSE;
	
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Property Name="P_bForceVehicleUpdateOPC" Id="{e3de05d9-bf15-4006-8645-6bca37fa13a2}">
      <Declaration><![CDATA[PROPERTY PUBLIC P_bForceVehicleUpdateOPC : BOOL]]></Declaration>
      <Get Name="Get" Id="{890e6faa-0b13-4388-985b-1f92d2037962}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[P_bForceVehicleUpdateOPC := bForceVehicleUpdateOPC;
]]></ST>
        </Implementation>
      </Get>
      <Set Name="Set" Id="{f73b0f77-ee39-49f4-bcfd-a3070f03a59d}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[bForceVehicleUpdateOPC := P_bForceVehicleUpdateOPC;
]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Property Name="P_bTrackReady" Id="{563c5a2a-b947-4cfc-b8ff-ede349f496cc}">
      <Declaration><![CDATA[/// When TRUE it is OK to run DecisionPoint, ExitPoint and Buffer handling
PROPERTY PUBLIC P_bTrackReady : BOOL]]></Declaration>
      <Get Name="Get" Id="{4d1cb31f-2455-4823-9437-6f43cbe07729}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[// TRUE if track client is ready to use
P_bTrackReady := bEnable AND bConnectedMethod AND bConnectedNode AND bTrackInitDone AND (eTrackState = E_TrackState.Started);
]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="P_eCellType" Id="{f8b89a3c-d4eb-4974-a116-e6eec1810f83}">
      <Declaration><![CDATA[PROPERTY PUBLIC P_eCellType : E_CellType]]></Declaration>
      <Get Name="Get" Id="{006cbb3d-a5c5-4ee1-9b95-11aef70b137a}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[P_eCellType := eCellType;
]]></ST>
        </Implementation>
      </Get>
      <Set Name="Set" Id="{14cc0dd7-2e32-465b-a1bc-9e64e02fe4e8}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[eCellType := P_eCellType;
]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Property Name="P_nTrackserverPort" Id="{9ee8c101-fd90-4b09-85be-1e0628572d3d}">
      <Declaration><![CDATA[PROPERTY PUBLIC P_nTrackserverPort : UINT]]></Declaration>
      <Get Name="Get" Id="{0914898f-abcb-4ecd-8f3c-551f5fea0a19}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[P_nTrackserverPort := nTrackServerPortNo;
]]></ST>
        </Implementation>
      </Get>
      <Set Name="Set" Id="{3e945c77-02b4-4deb-8672-0c5c041f42b7}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[nTrackServerPortNo := P_nTrackserverPort;
]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Property Name="P_rErrorResetDelay" Id="{3d49e448-b86b-4ee0-8ddb-1b333b59596c}">
      <Declaration><![CDATA[PROPERTY PUBLIC P_rErrorResetDelay : REAL]]></Declaration>
      <Get Name="Get" Id="{72d8357e-1e35-4de1-abef-6ad5331a419a}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[P_rErrorResetDelay := rErrorResetDelay;
]]></ST>
        </Implementation>
      </Get>
      <Set Name="Set" Id="{b972263f-3cd7-4b94-9d48-32641e5a40f7}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[rErrorResetDelay := P_rErrorResetDelay;
]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Property Name="P_rPollingInterval" Id="{f49f6fd9-e679-404d-8a03-5145bc48e193}">
      <Declaration><![CDATA[PROPERTY PUBLIC P_rPollingInterval : REAL]]></Declaration>
      <Get Name="Get" Id="{28d08fd3-eed1-4ca6-a523-f1fdc1b8ae50}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[P_rPollingInterval := rReadInterval;
]]></ST>
        </Implementation>
      </Get>
      <Set Name="Set" Id="{ed2c62b3-522f-4f15-9696-e47959a2fb8d}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[rReadInterval := P_rPollingInterval;
]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Property Name="P_sCellID" Id="{e88ab857-2756-4b4a-8845-c2333efc8a0b}">
      <Declaration><![CDATA[PROPERTY PUBLIC P_sCellID : STRING(30)]]></Declaration>
      <Get Name="Get" Id="{6d189475-286d-4e02-8d7a-6352c6277a07}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[P_sCellID := sCellID;
]]></ST>
        </Implementation>
      </Get>
      <Set Name="Set" Id="{8187e086-961e-4f87-8540-0fdf96eb0619}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[sCellID := F_ToUCase(P_sCellID);
]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Property Name="P_sNextStationOnTrack" Id="{b803813b-9aaf-4e85-82f8-218f9f9b1347}">
      <Declaration><![CDATA[PROPERTY PUBLIC P_sNextStationOnTrack : STRING(30)]]></Declaration>
      <Get Name="Get" Id="{12d2266c-e012-4698-84b4-8ba60a400ef2}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[P_sNextStationOnTrack := sNextStationOnTrack;
]]></ST>
        </Implementation>
      </Get>
      <Set Name="Set" Id="{9a26e180-bf0c-4868-8917-397b31d1616f}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[
IF (LEN(P_sNextStationOnTrack) > 0) THEN
	sNextStationOnTrack := P_sNextStationOnTrack;
END_IF
]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Property Name="P_sTrackserverNetID" Id="{f4ab271d-2693-4e10-9d44-fa9a4099a6c8}">
      <Declaration><![CDATA[PROPERTY PUBLIC P_sTrackserverNetID : STRING]]></Declaration>
      <Get Name="Get" Id="{038c7f3c-fba8-4975-a833-56cbc64fb8f0}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[P_sTrackserverNetID := sTrackServerNetID;
]]></ST>
        </Implementation>
      </Get>
      <Set Name="Set" Id="{616ebaec-77fa-4482-87ee-b39f2ebc9057}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[sTrackServerNetID := P_sTrackserverNetID;
]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Property Name="P_sTrackserverURL" Id="{92aa76bc-cc3a-456f-bc80-2077a04fc128}">
      <Declaration><![CDATA[PROPERTY PUBLIC P_sTrackserverURL : STRING]]></Declaration>
      <Get Name="Get" Id="{b9d513db-0ae6-416a-9357-745bcd76d8f2}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[P_sTrackserverURL := sTrackServerUrl;
]]></ST>
        </Implementation>
      </Get>
      <Set Name="Set" Id="{23a8a54b-09bc-4372-9f66-a6a892aaabb1}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[sTrackServerUrl := P_sTrackserverURL;
]]></ST>
        </Implementation>
      </Set>
    </Property>
    <LineIds Name="FB_TrackClient_Basic">
      <LineId Id="3" Count="28" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TrackClient_Basic.M_CallAddPath">
      <LineId Id="3" Count="86" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TrackClient_Basic.M_CallAddPathSegment">
      <LineId Id="3" Count="95" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TrackClient_Basic.M_CallAddReservation">
      <LineId Id="3" Count="94" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TrackClient_Basic.M_CallAddStationDouble">
      <LineId Id="3" Count="126" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TrackClient_Basic.M_CallAddStationSingle">
      <LineId Id="3" Count="118" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TrackClient_Basic.M_CallAddTrafficLight">
      <LineId Id="3" Count="91" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TrackClient_Basic.M_CallAdjustBufferPosition">
      <LineId Id="3" Count="86" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TrackClient_Basic.M_CallEnableStation">
      <LineId Id="3" Count="86" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TrackClient_Basic.M_CallGetCellIndex">
      <LineId Id="3" Count="82" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TrackClient_Basic.M_CallGetPathSegmentVehicleCount">
      <LineId Id="3" Count="87" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TrackClient_Basic.M_CallMoveVehicleStatus">
      <LineId Id="3" Count="96" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TrackClient_Basic.M_CallMoveVehicleToBuffer">
      <LineId Id="3" Count="120" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TrackClient_Basic.M_CallMoveVehicleToDecisionPoint">
      <LineId Id="3" Count="112" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TrackClient_Basic.M_CallMoveVehicleToPosition">
      <LineId Id="3" Count="125" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TrackClient_Basic.M_CallMoveVehicleToScanner">
      <LineId Id="3" Count="108" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TrackClient_Basic.M_CallMoveVehicleToStationIn">
      <LineId Id="3" Count="112" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TrackClient_Basic.M_CallMoveVehicleToStationOut">
      <LineId Id="3" Count="112" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TrackClient_Basic.M_CallRemovePath">
      <LineId Id="3" Count="82" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TrackClient_Basic.M_CallRemovePathSegment">
      <LineId Id="3" Count="83" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TrackClient_Basic.M_CallRemoveReservation">
      <LineId Id="3" Count="82" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TrackClient_Basic.M_CallRemoveStation">
      <LineId Id="3" Count="82" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TrackClient_Basic.M_CallRemoveTrafficLight">
      <LineId Id="3" Count="82" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TrackClient_Basic.M_CallResetPath">
      <LineId Id="3" Count="78" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TrackClient_Basic.M_CallResumePath">
      <LineId Id="3" Count="78" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TrackClient_Basic.M_CallSetTrafficLightColor">
      <LineId Id="3" Count="87" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TrackClient_Basic.M_CallStartPath">
      <LineId Id="3" Count="78" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TrackClient_Basic.M_CallSuspendPath">
      <LineId Id="3" Count="78" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TrackClient_Basic.M_CallTrafficLightColor">
      <LineId Id="3" Count="87" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TrackClient_Basic.M_CallUpdateStationBuffer">
      <LineId Id="3" Count="106" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TrackClient_Basic.M_CallUpdateVehicleMappingData">
      <LineId Id="3" Count="109" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TrackClient_Basic.M_CallUpdateVehicleMontage">
      <LineId Id="3" Count="118" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TrackClient_Basic.M_CallUpdateVehicleOwner">
      <LineId Id="3" Count="96" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TrackClient_Basic.M_CallUpdateVehicleReservationData">
      <LineId Id="3" Count="109" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TrackClient_Basic.M_CallUpdateVehicleReworkData">
      <LineId Id="3" Count="93" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TrackClient_Basic.M_CarrierIDToVehicleID">
      <LineId Id="3" Count="12" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TrackClient_Basic.M_CheckStationIndex">
      <LineId Id="3" Count="13" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TrackClient_Basic.M_CheckStationsRead">
      <LineId Id="3" Count="17" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TrackClient_Basic.M_CheckVehicleEventRead">
      <LineId Id="3" Count="12" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TrackClient_Basic.M_CheckVehicleOwned">
      <LineId Id="3" Count="11" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TrackClient_Basic.M_CheckVehicleSurvail">
      <LineId Id="3" Count="11" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TrackClient_Basic.M_ClearAll">
      <LineId Id="3" Count="23" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TrackClient_Basic.M_CommandData">
      <LineId Id="92" Count="88" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TrackClient_Basic.M_CopyAndClearBufferData">
      <LineId Id="3" Count="12" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TrackClient_Basic.M_CopyBufferData">
      <LineId Id="3" Count="6" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TrackClient_Basic.M_DefinePath">
      <LineId Id="3" Count="20" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TrackClient_Basic.M_DefinePathSegment">
      <LineId Id="3" Count="24" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TrackClient_Basic.M_DefineStation">
      <LineId Id="3" Count="50" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TrackClient_Basic.M_DefineStationBufferAdjust">
      <LineId Id="3" Count="13" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TrackClient_Basic.M_DefineTrafficLight">
      <LineId Id="3" Count="19" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TrackClient_Basic.M_EnableStation">
      <LineId Id="3" Count="6" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TrackClient_Basic.M_ErrorWarning">
      <LineId Id="3" Count="32" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TrackClient_Basic.M_ErrorWarningObj">
      <LineId Id="3" Count="54" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TrackClient_Basic.M_ExtraVehicleAdd">
      <LineId Id="3" Count="28" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TrackClient_Basic.M_ExtraVehicleRemove">
      <LineId Id="3" Count="11" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TrackClient_Basic.M_Init">
      <LineId Id="3" Count="41" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TrackClient_Basic.M_InitMethodData">
      <LineId Id="3" Count="32" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TrackClient_Basic.M_InitNodeData">
      <LineId Id="3" Count="138" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TrackClient_Basic.M_InitNodeData_ADS">
      <LineId Id="3" Count="231" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TrackClient_Basic.M_InitNodeData_OPCUA">
      <LineId Id="3" Count="152" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TrackClient_Basic.M_MappingData">
      <LineId Id="3" Count="72" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TrackClient_Basic.M_ReworkData">
      <LineId Id="3" Count="198" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TrackClient_Basic.M_Run">
      <LineId Id="3" Count="177" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TrackClient_Basic.M_StateMachine">
      <LineId Id="3" Count="640" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TrackClient_Basic.M_StateMachineMethod">
      <LineId Id="3" Count="141" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TrackClient_Basic.M_StateMachineNode_ADS">
      <LineId Id="3" Count="95" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TrackClient_Basic.M_ThisCellDataIndex">
      <LineId Id="3" Count="27" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TrackClient_Basic.M_UpdateStatus">
      <LineId Id="3" Count="133" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TrackClient_Basic.M_UpdateStatusCompare">
      <LineId Id="3" Count="33" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TrackClient_Basic.M_VehicleIDToCarrierID">
      <LineId Id="3" Count="8" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TrackClient_Basic.M_VehicleToReadAdd">
      <LineId Id="3" Count="21" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TrackClient_Basic.M_VehicleToReadRemove">
      <LineId Id="3" Count="16" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TrackClient_Basic.P_bForceVehicleUpdateOPC.Get">
      <LineId Id="3" Count="0" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TrackClient_Basic.P_bForceVehicleUpdateOPC.Set">
      <LineId Id="3" Count="0" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TrackClient_Basic.P_bTrackReady.Get">
      <LineId Id="3" Count="1" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TrackClient_Basic.P_eCellType.Get">
      <LineId Id="3" Count="0" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TrackClient_Basic.P_eCellType.Set">
      <LineId Id="3" Count="0" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TrackClient_Basic.P_nTrackserverPort.Get">
      <LineId Id="3" Count="0" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TrackClient_Basic.P_nTrackserverPort.Set">
      <LineId Id="3" Count="0" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TrackClient_Basic.P_rErrorResetDelay.Get">
      <LineId Id="3" Count="0" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TrackClient_Basic.P_rErrorResetDelay.Set">
      <LineId Id="3" Count="0" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TrackClient_Basic.P_rPollingInterval.Get">
      <LineId Id="3" Count="0" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TrackClient_Basic.P_rPollingInterval.Set">
      <LineId Id="3" Count="0" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TrackClient_Basic.P_sCellID.Get">
      <LineId Id="3" Count="0" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TrackClient_Basic.P_sCellID.Set">
      <LineId Id="3" Count="0" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TrackClient_Basic.P_sNextStationOnTrack.Get">
      <LineId Id="3" Count="0" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TrackClient_Basic.P_sNextStationOnTrack.Set">
      <LineId Id="3" Count="3" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TrackClient_Basic.P_sTrackserverNetID.Get">
      <LineId Id="3" Count="0" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TrackClient_Basic.P_sTrackserverNetID.Set">
      <LineId Id="3" Count="0" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TrackClient_Basic.P_sTrackserverURL.Get">
      <LineId Id="3" Count="0" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TrackClient_Basic.P_sTrackserverURL.Set">
      <LineId Id="3" Count="0" />
      <LineId Id="2" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>